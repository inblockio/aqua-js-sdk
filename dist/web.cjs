"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name4 in all)
    __defProp(target, name4, { get: all[name4], enumerable: true });
};
var __copyProps = (to, from5, except, desc) => {
  if (from5 && typeof from5 === "object" || typeof from5 === "function") {
    for (let key of __getOwnPropNames(from5))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/platform/node-modules.ts
function registerNodeModuleShims() {
  if (typeof global !== "undefined") {
    Object.entries(nodeModules).forEach(([name4, implementation]) => {
      try {
        if (!global[name4]) {
          global[name4] = implementation;
        }
      } catch (e) {
        console.error(`Failed to register Node.js module shim for ${name4}:`, e);
      }
    });
  }
}
var fs, path, http, https, crypto2, stream, util, zlib, nodeModules;
var init_node_modules = __esm({
  "src/platform/node-modules.ts"() {
    "use strict";
    fs = {
      promises: {
        readFile: async () => "",
        writeFile: async () => {
        },
        mkdir: async () => {
        },
        readdir: async () => [],
        stat: async () => ({
          isFile: () => false,
          isDirectory: () => false
        }),
        access: async () => {
        }
      },
      readFileSync: () => "",
      writeFileSync: () => {
      },
      existsSync: () => false,
      mkdirSync: () => {
      },
      readdirSync: () => [],
      statSync: () => ({
        isFile: () => false,
        isDirectory: () => false
      })
    };
    path = {
      join: (...args) => args.join("/"),
      resolve: (...args) => args.join("/"),
      dirname: (p) => p.split("/").slice(0, -1).join("/"),
      basename: (p) => p.split("/").pop() || "",
      extname: (p) => {
        const base4 = p.split("/").pop() || "";
        return base4.includes(".") ? "." + base4.split(".").pop() : "";
      }
    };
    http = {
      createServer: () => ({
        listen: () => {
        },
        close: () => {
        }
      })
    };
    https = {
      request: () => ({
        on: () => {
        },
        end: () => {
        }
      })
    };
    crypto2 = {
      createHash: () => ({
        update: () => ({
          digest: () => ""
        })
      }),
      randomBytes: () => Buffer.from([])
    };
    stream = {
      Readable: class {
      },
      Writable: class {
      },
      Duplex: class {
      },
      Transform: class {
      }
    };
    util = {
      promisify: (fn) => fn,
      inspect: (obj) => JSON.stringify(obj)
    };
    zlib = {
      gzip: (_, cb) => cb(null, Buffer.from([])),
      gunzip: (_, cb) => cb(null, Buffer.from([]))
    };
    nodeModules = {
      fs,
      path,
      http,
      https,
      crypto: crypto2,
      stream,
      util,
      zlib
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    "use strict";
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    "use strict";
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function") throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    "use strict";
    var buffer2 = require("buffer");
    var Buffer8 = buffer2.Buffer;
    function copyProps(src3, dst) {
      for (var key in src3) {
        dst[key] = src3[key];
      }
    }
    if (Buffer8.from && Buffer8.alloc && Buffer8.allocUnsafe && Buffer8.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length3) {
      return Buffer8(arg, encodingOrOffset, length3);
    }
    SafeBuffer.prototype = Object.create(Buffer8.prototype);
    copyProps(Buffer8, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer8(arg, encodingOrOffset, length3);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer8(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer8(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size2);
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    "use strict";
    var Buffer8 = require_safe_buffer().Buffer;
    function Hash5(blockSize, finalSize) {
      this._block = Buffer8.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash5.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer8.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length3 = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length3; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length3 - offset, blockSize - assigned);
        for (var i2 = 0; i2 < remainder; i2++) {
          block[assigned + i2] = data[offset + i2];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length3;
      return this;
    };
    Hash5.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash3 = this._hash();
      return enc ? hash3.toString(enc) : hash3;
    };
    Hash5.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash5;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash5 = require_hash();
    var Buffer8 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash5.call(this, 64, 56);
    }
    inherits(Sha, Hash5);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i2 = 0; i2 < 16; ++i2) W2[i2] = M.readInt32BE(i2 * 4);
      for (; i2 < 80; ++i2) W2[i2] = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer8.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash5 = require_hash();
    var Buffer8 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash5.call(this, 64, 56);
    }
    inherits(Sha1, Hash5);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i2 = 0; i2 < 16; ++i2) W2[i2] = M.readInt32BE(i2 * 4);
      for (; i2 < 80; ++i2) W2[i2] = rotl1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer8.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash5 = require_hash();
    var Buffer8 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash5.call(this, 64, 56);
    }
    inherits(Sha256, Hash5);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i2 = 0; i2 < 16; ++i2) W2[i2] = M.readInt32BE(i2 * 4);
      for (; i2 < 64; ++i2) W2[i2] = gamma1(W2[i2 - 2]) + W2[i2 - 7] + gamma0(W2[i2 - 15]) + W2[i2 - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer8.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Sha256 = require_sha256();
    var Hash5 = require_hash();
    var Buffer8 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash5.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer8.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash5 = require_hash();
    var Buffer8 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash5.call(this, 128, 112);
    }
    inherits(Sha512, Hash5);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i2 = 0; i2 < 32; i2 += 2) {
        W2[i2] = M.readInt32BE(i2 * 4);
        W2[i2 + 1] = M.readInt32BE(i2 * 4 + 4);
      }
      for (; i2 < 160; i2 += 2) {
        var xh = W2[i2 - 15 * 2];
        var xl = W2[i2 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i2 - 2 * 2];
        xl = W2[i2 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i2 - 7 * 2];
        var Wi7l = W2[i2 - 7 * 2 + 1];
        var Wi16h = W2[i2 - 16 * 2];
        var Wi16l = W2[i2 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i2] = Wih;
        W2[i2 + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer8.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var SHA5123 = require_sha512();
    var Hash5 = require_hash();
    var Buffer8 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash5.call(this, 128, 112);
    }
    inherits(Sha384, SHA5123);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer8.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    "use strict";
    var exports2 = module2.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports2.sha = require_sha();
    exports2.sha1 = require_sha1();
    exports2.sha224 = require_sha224();
    exports2.sha256 = require_sha256();
    exports2.sha384 = require_sha384();
    exports2.sha512 = require_sha512();
  }
});

// src/platform/fs.ts
async function getFileSystem() {
  if (isNode) {
    try {
      let fs3;
      try {
        fs3 = require("fs").promises;
      } catch (e) {
        console.warn("Failed to load fs module via require, trying alternative methods");
        try {
          const dynamicImport = new Function("modulePath", "return import(modulePath)");
          fs3 = await dynamicImport("node:fs/promises");
        } catch (e2) {
          console.error("All attempts to load Node.js fs module failed:", e2);
          return getBrowserFileSystem();
        }
      }
      return {
        readFile: async (path3, options) => {
          const fsOptions = options?.encoding ? { encoding: options.encoding } : void 0;
          return await fs3.readFile(path3, fsOptions);
        },
        writeFile: async (path3, data, options) => {
          const fsOptions = options?.encoding ? { encoding: options.encoding } : void 0;
          await fs3.writeFile(path3, data, fsOptions);
        },
        exists: async (path3) => {
          try {
            await fs3.access(path3);
            return true;
          } catch {
            return false;
          }
        }
      };
    } catch (error) {
      console.error("Failed to import Node.js fs module:", error);
      return getBrowserFileSystem();
    }
  } else if (isReactNative) {
    try {
      try {
        const RNFS = require("react-native-fs");
        return {
          readFile: async (path3, options) => {
            const encoding = options?.encoding || "utf8";
            return await RNFS.readFile(path3, encoding);
          },
          writeFile: async (path3, data, options) => {
            const encoding = options?.encoding || "utf8";
            const stringData = typeof data === "string" ? data : data.toString(encoding);
            await RNFS.writeFile(path3, stringData, encoding);
          },
          exists: async (path3) => {
            return await RNFS.exists(path3);
          }
        };
      } catch (rnfsError) {
        console.warn("react-native-fs not available, falling back to AsyncStorage for limited storage");
        const AsyncStorage = require("@react-native-async-storage/async-storage");
        return {
          readFile: async (path3, _options) => {
            const data = await AsyncStorage.getItem(path3);
            if (data === null) throw new Error(`File not found: ${path3}`);
            return data;
          },
          writeFile: async (path3, data, _options) => {
            const stringData = typeof data === "string" ? data : data.toString("utf8");
            await AsyncStorage.setItem(path3, stringData);
          },
          exists: async (path3) => {
            const data = await AsyncStorage.getItem(path3);
            return data !== null;
          }
        };
      }
    } catch (error) {
      console.error("Failed to import React Native file system modules:", error);
      throw new Error("File system functionality not available in this React Native environment");
    }
  } else if (isBrowser) {
    return getBrowserFileSystem();
  } else {
    console.warn("Unknown environment detected, using browser file system implementation");
    return getBrowserFileSystem();
  }
}
function getBrowserFileSystem() {
  return {
    readFile: async (path3, _options) => {
      console.warn(`Browser environment: Cannot read file from ${path3}`);
      if (typeof localStorage !== "undefined") {
        const data = localStorage.getItem(`fs:${path3}`);
        if (data !== null) return data;
      }
      return fs.promises.readFile();
    },
    writeFile: async (path3, data, _options) => {
      console.warn(`Browser environment: Cannot write file to ${path3}`);
      if (typeof localStorage !== "undefined") {
        const stringData = typeof data === "string" ? data : data.toString("utf8");
        try {
          localStorage.setItem(`fs:${path3}`, stringData);
        } catch (e) {
          console.error("Failed to write to localStorage:", e);
        }
      }
      return fs.promises.writeFile();
    },
    exists: async (path3) => {
      if (typeof localStorage !== "undefined") {
        return localStorage.getItem(`fs:${path3}`) !== null;
      }
      return false;
    }
  };
}
var init_fs = __esm({
  "src/platform/fs.ts"() {
    "use strict";
    init_platform();
    init_node_modules();
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    "use strict";
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet5, maxline) {
      if (typeof alphabet5 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output6 = "";
      if (!(input instanceof Uint8Array)) {
        output6 = _encodeWithByteBuffer(input, alphabet5);
      } else {
        var i2 = 0;
        var base4 = alphabet5.length;
        var first = alphabet5.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j = 0, carry = input[i2]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base4;
            carry = carry / base4 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base4);
            carry = carry / base4 | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output6 += first;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output6 += alphabet5[digits[i2]];
        }
      }
      if (maxline) {
        var regex2 = new RegExp(".{1," + maxline + "}", "g");
        output6 = output6.match(regex2).join("\r\n");
      }
      return output6;
    };
    api.decode = function(input, alphabet5) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet5 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet5];
      if (!table) {
        table = _reverseAlphabets[alphabet5] = [];
        for (var i2 = 0; i2 < alphabet5.length; ++i2) {
          table[alphabet5.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base4 = alphabet5.length;
      var first = alphabet5.charAt(0);
      var bytes6 = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes6.length; ++j) {
          carry += bytes6[j] * base4;
          bytes6[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes6.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
        bytes6.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes6.reverse());
      }
      return new Uint8Array(bytes6.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet5) {
      var i2 = 0;
      var base4 = alphabet5.length;
      var first = alphabet5.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j = 0, carry = input.at(i2); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base4;
          carry = carry / base4 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base4);
          carry = carry / base4 | 0;
        }
      }
      var output6 = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output6 += first;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output6 += alphabet5[digits[i2]];
      }
      return output6;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    var baseN = require_baseN();
    var util2 = module2.exports = forge2.util = forge2.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util2.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util2.setImmediate = setImmediate;
        } else {
          util2.setImmediate = util2.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util2.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util2.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util2.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util2.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now2 = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util2.setImmediate;
        util2.setImmediate = function(callback) {
          if (Date.now() - now2 > 15) {
            now2 = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util2.nextTick = util2.setImmediate;
    })();
    util2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util2.globalScope = function() {
      if (util2.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util2.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util2.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util2.isArrayBufferView = function(x) {
      return x && util2.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util2.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util2.isArrayBuffer(b) || util2.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util2.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util2.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util2.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util2.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util2.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util2.ByteStringBuffer.prototype.putBytes = function(bytes6) {
      this.data += bytes6;
      this._optimizeConstructedString(bytes6.length);
      return this;
    };
    util2.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util2.encodeUtf8(str));
    };
    util2.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      var bytes6 = "";
      do {
        n -= 8;
        bytes6 += String.fromCharCode(i2 >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes6);
    };
    util2.ByteStringBuffer.prototype.putSignedInt = function(i2, n) {
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util2.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
      return this.putBytes(buffer2.getBytes());
    };
    util2.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util2.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util2.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util2.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util2.ByteStringBuffer.prototype.setAt = function(i2, b) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util2.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util2.ByteStringBuffer.prototype.copy = function() {
      var c = util2.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util2.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util2.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b = this.data.charCodeAt(i2);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.toString = function() {
      return util2.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util2.isArrayBuffer(b);
      var isArrayBufferView = util2.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util2.DataBuffer = DataBuffer;
    util2.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util2.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src3 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src3);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util2.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util2.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i2 = 0; i2 < n; ++i2) {
        this.data.setUint8(b);
      }
      return this;
    };
    util2.DataBuffer.prototype.putBytes = function(bytes6, encoding) {
      if (util2.isArrayBufferView(bytes6)) {
        var src3 = new Uint8Array(bytes6.buffer, bytes6.byteOffset, bytes6.byteLength);
        var len = src3.byteLength - src3.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src3);
        this.write += len;
        return this;
      }
      if (util2.isArrayBuffer(bytes6)) {
        var src3 = new Uint8Array(bytes6);
        this.accommodate(src3.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src3, this.write);
        this.write += src3.byteLength;
        return this;
      }
      if (bytes6 instanceof util2.DataBuffer || typeof bytes6 === "object" && typeof bytes6.read === "number" && typeof bytes6.write === "number" && util2.isArrayBufferView(bytes6.data)) {
        var src3 = new Uint8Array(bytes6.data.byteLength, bytes6.read, bytes6.length());
        this.accommodate(src3.byteLength);
        var dst = new Uint8Array(bytes6.data.byteLength, this.write);
        dst.set(src3);
        this.write += src3.byteLength;
        return this;
      }
      if (bytes6 instanceof util2.ByteStringBuffer) {
        bytes6 = bytes6.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes6 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes6.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.hex.decode(bytes6, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes6.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.base64.decode(bytes6, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes6 = util2.encodeUtf8(bytes6);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes6.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes6.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util2.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes6);
    };
    util2.DataBuffer.prototype.putBuffer = function(buffer2) {
      this.putBytes(buffer2);
      buffer2.clear();
      return this;
    };
    util2.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util2.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i2 >> n & 255);
      } while (n > 0);
      return this;
    };
    util2.DataBuffer.prototype.putSignedInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util2.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util2.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util2.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util2.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util2.DataBuffer.prototype.setAt = function(i2, b) {
      this.data.setUint8(i2, b);
      return this;
    };
    util2.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util2.DataBuffer.prototype.copy = function() {
      return new util2.DataBuffer(this);
    };
    util2.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src3 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src3.byteLength);
        dst.set(src3);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util2.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util2.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util2.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b = this.data.getUint8(i2);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util2.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util2.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util2.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util2.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util2.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util2.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util2.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util2.encodeUtf8(input);
      }
      return new util2.ByteBuffer(input);
    };
    util2.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util2.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i2 = 0;
      var c = 0;
      for (; n > 0; --n, ++i2) {
        b = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util2.hexToBytes = function(hex2) {
      var rval = "";
      var i2 = 0;
      if (hex2.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex2[0], 16));
      }
      for (; i2 < hex2.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex2.substr(i2, 2), 16));
      }
      return rval;
    };
    util2.bytesToHex = function(bytes6) {
      return util2.createBuffer(bytes6).toHex();
    };
    util2.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util2.encode64 = function(input, maxline) {
      var line = "";
      var output6 = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output6 += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output6 += line;
      return output6;
    };
    util2.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output6 = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output6 += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output6 += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output6 += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output6;
    };
    util2.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util2.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util2.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util2.binary.raw.encode = function(bytes6) {
      return String.fromCharCode.apply(null, bytes6);
    };
    util2.binary.raw.decode = function(str, output6, offset) {
      var out = output6;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j++] = str.charCodeAt(i2);
      }
      return output6 ? j - offset : out;
    };
    util2.binary.hex.encode = util2.bytesToHex;
    util2.binary.hex.decode = function(hex2, output6, offset) {
      var out = output6;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex2.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j = offset;
      if (hex2.length & 1) {
        i2 = 1;
        out[j++] = parseInt(hex2[0], 16);
      }
      for (; i2 < hex2.length; i2 += 2) {
        out[j++] = parseInt(hex2.substr(i2, 2), 16);
      }
      return output6 ? j - offset : out;
    };
    util2.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output6 = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output6 += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output6 += line;
      return output6;
    };
    util2.binary.base64.decode = function(input, output6, offset) {
      var out = output6;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output6 ? j - offset : out.subarray(0, j);
    };
    util2.binary.base58.encode = function(input, maxline) {
      return util2.binary.baseN.encode(input, _base58, maxline);
    };
    util2.binary.base58.decode = function(input, maxline) {
      return util2.binary.baseN.decode(input, _base58, maxline);
    };
    util2.text = {
      utf8: {},
      utf16: {}
    };
    util2.text.utf8.encode = function(str, output6, offset) {
      str = util2.encodeUtf8(str);
      var out = output6;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j++] = str.charCodeAt(i2);
      }
      return output6 ? j - offset : out;
    };
    util2.text.utf8.decode = function(bytes6) {
      return util2.decodeUtf8(String.fromCharCode.apply(null, bytes6));
    };
    util2.text.utf16.encode = function(str, output6, offset) {
      var out = output6;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k++] = str.charCodeAt(i2);
        j += 2;
      }
      return output6 ? j - offset : out;
    };
    util2.text.utf16.decode = function(bytes6) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes6.buffer));
    };
    util2.deflate = function(api, bytes6, raw) {
      bytes6 = util2.decode64(api.deflate(util2.encode64(bytes6)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes6.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes6 = bytes6.substring(start, bytes6.length - 4);
      }
      return bytes6;
    };
    util2.inflate = function(api, bytes6, raw) {
      var rval = api.inflate(util2.encode64(bytes6)).rval;
      return rval === null ? null : util2.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util2.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util2.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty3 = true;
        for (var prop in obj) {
          empty3 = false;
          break;
        }
        if (empty3) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util2.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util2.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util2.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util2.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util2.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util2.format = function(format2) {
      var re = /%./g;
      var match2;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match2 = re.exec(format2)) {
        part = format2.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code4 = match2[0][1];
        switch (code4) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          // FIXME: do proper formating for numbers, etc
          //case 'f':
          //case 'd':
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code4 + "?>");
        }
      }
      parts.push(format2.substring(last));
      return parts.join("");
    };
    util2.formatNumber = function(number7, decimals, dec_point, thousands_sep) {
      var n = number7, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i2.length > 3 ? i2.length % 3 : 0;
      return s + (j ? i2.substr(0, j) + t : "") + i2.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i2).toFixed(c).slice(2) : "");
    };
    util2.formatSize = function(size2) {
      if (size2 >= 1073741824) {
        size2 = util2.formatNumber(size2 / 1073741824, 2, ".", "") + " GiB";
      } else if (size2 >= 1048576) {
        size2 = util2.formatNumber(size2 / 1048576, 2, ".", "") + " MiB";
      } else if (size2 >= 1024) {
        size2 = util2.formatNumber(size2 / 1024, 0) + " KiB";
      } else {
        size2 = util2.formatNumber(size2, 0) + " bytes";
      }
      return size2;
    };
    util2.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util2.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util2.bytesFromIPv6(ip);
      }
      return null;
    };
    util2.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util2.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util2.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util2.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes6 = util2.hexToBytes(ip[i2]);
        if (bytes6.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes6);
      }
      return b.getBytes();
    };
    util2.bytesToIP = function(bytes6) {
      if (bytes6.length === 4) {
        return util2.bytesToIPv4(bytes6);
      }
      if (bytes6.length === 16) {
        return util2.bytesToIPv6(bytes6);
      }
      return null;
    };
    util2.bytesToIPv4 = function(bytes6) {
      if (bytes6.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes6.length; ++i2) {
        ip.push(bytes6.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util2.bytesToIPv6 = function(bytes6) {
      if (bytes6.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes6.length; i2 += 2) {
        var hex2 = util2.bytesToHex(bytes6[i2] + bytes6[i2 + 1]);
        while (hex2[0] === "0" && hex2 !== "0") {
          hex2 = hex2.substr(1);
        }
        if (hex2 === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex2);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util2.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util2 && !options.update) {
        return callback(null, util2.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util2.cores = navigator.hardwareConcurrency;
        return callback(null, util2.cores);
      }
      if (typeof Worker === "undefined") {
        util2.cores = 1;
        return callback(null, util2.cores);
      }
      if (typeof Blob === "undefined") {
        util2.cores = 2;
        return callback(null, util2.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et) ;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util2.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util2.cores);
        }
        map2(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map2(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    module2.exports = forge2.cipher = forge2.cipher || {};
    forge2.cipher.algorithms = forge2.cipher.algorithms || {};
    forge2.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge2.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge2.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge2.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge2.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge2.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge2.cipher.registerAlgorithm = function(name4, algorithm) {
      name4 = name4.toUpperCase();
      forge2.cipher.algorithms[name4] = algorithm;
    };
    forge2.cipher.getAlgorithm = function(name4) {
      name4 = name4.toUpperCase();
      if (name4 in forge2.cipher.algorithms) {
        return forge2.cipher.algorithms[name4];
      }
      return null;
    };
    var BlockCipher = forge2.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge2.util.createBuffer();
      this.output = options.output || forge2.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad4) {
      if (pad4 && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad4(this.blockSize, input, false);
        };
        this.mode.unpad = function(output6) {
          return pad4(this.blockSize, output6, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    forge2.cipher = forge2.cipher || {};
    var modes = module2.exports = forge2.cipher.modes = forge2.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output6, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output6.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output6, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output6.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding2 = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding2, padding2);
      return true;
    };
    modes.ecb.prototype.unpad = function(output6, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output6.length();
      var count = output6.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output6.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output6, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output6.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output6, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output6.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding2 = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding2, padding2);
      return true;
    };
    modes.cbc.prototype.unpad = function(output6, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output6.length();
      var count = output6.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output6.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output6, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output6.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output6.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output6.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output6, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output6.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output6.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output6.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output6, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output6.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output6.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output6.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output6, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output6.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output6.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output6.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge2.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge2.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge2.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge2.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge2.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output6, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output6.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output6.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output6.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output6, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output6.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output6, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output6.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge2.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x[i2] >>> 1 | (x[i2 - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah = this._m[i2][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size2 = 16 * multiplier;
      var m = new Array(size2);
      for (var i2 = 0; i2 < size2; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size2 = 1 << bits;
      var half = size2 >>> 1;
      var m = new Array(size2);
      m[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m[2 * i2], m[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j = 1; j < i2; ++j) {
          var m_i = m[i2];
          var m_j = m[j];
          m[i2 + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size2; ++i2) {
        var c = m[i2 ^ half];
        m[i2] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge2.util.createBuffer(iv);
      }
      if (forge2.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge2.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge2.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge2.aes = forge2.aes || {};
    forge2.aes.startEncrypting = function(key, iv, output6, mode) {
      var cipher = _createCipher({
        key,
        output: output6,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge2.aes.startDecrypting = function(key, iv, output6, mode) {
      var cipher = _createCipher({
        key,
        output: output6,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge2.aes.Algorithm = function(name4, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name4;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge2.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge2.util.createBuffer(key);
      } else if (forge2.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge2.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge2.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge2.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge2.aes._expandKey = function(key, decrypt3) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt3);
    };
    forge2.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge2.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge2.cipher.modes.gcm);
    function registerAlgorithm(name4, mode) {
      var factory = function() {
        return new forge2.aes.Algorithm(name4, mode);
      };
      forge2.cipher.registerAlgorithm(name4, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox2;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox2 = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox2[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt3) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox2[temp >>> 16 & 255] << 24 ^ sbox2[temp >>> 8 & 255] << 16 ^ sbox2[temp & 255] << 8 ^ sbox2[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox2[temp >>> 24] << 24 ^ sbox2[temp >>> 16 & 255] << 16 ^ sbox2[temp >>> 8 & 255] << 8 ^ sbox2[temp & 255];
        }
        w[i2] = w[i2 - Nk] ^ temp;
      }
      if (decrypt3) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i2 = 0, wi = end - Nb; i2 < end; i2 += Nb, wi -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w[wi];
            wnew[i2 + 1] = w[wi + 3];
            wnew[i2 + 2] = w[wi + 2];
            wnew[i2 + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i2 + (3 & -n)] = m0[sbox2[tmp >>> 24]] ^ m1[sbox2[tmp >>> 16 & 255]] ^ m2[sbox2[tmp >>> 8 & 255]] ^ m3[sbox2[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output6, decrypt3) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt3) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox2;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt3 ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt3 ? 1 : 3] ^ w[3];
      var i2 = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i2];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i2];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i2];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i2];
        a = a2;
        b = b2;
        c = c2;
      }
      output6[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i2];
      output6[decrypt3 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i2];
      output6[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i2];
      output6[decrypt3 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge2.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge2.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output6 = null;
        if (options2 instanceof forge2.util.ByteBuffer) {
          output6 = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output6;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    forge2.pki = forge2.pki || {};
    var oids = module2.exports = forge2.pki.oids = forge2.oids = forge2.oids || {};
    function _IN(id, name4) {
      oids[id] = name4;
      oids[name4] = id;
    }
    function _I_(id, name4) {
      oids[id] = name4;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge2.asn1 = forge2.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge2.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge2.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge2.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn1.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge2.util.isArray(obj1)) {
        if (!forge2.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length3;
      var longForm = b2 & 128;
      if (!longForm) {
        length3 = b2;
      } else {
        length3 = b.getInt((b2 & 127) << 3);
      }
      return length3;
    };
    function _checkBufferLength(bytes6, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes6.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes6, remaining) {
      var b2 = bytes6.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length3;
      var longForm = b2 & 128;
      if (!longForm) {
        length3 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes6, remaining, longFormBytes);
        length3 = bytes6.getInt(longFormBytes << 3);
      }
      if (length3 < 0) {
        throw new Error("Negative length: " + length3);
      }
      return length3;
    };
    asn1.fromDer = function(bytes6, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes6 === "string") {
        bytes6 = forge2.util.createBuffer(bytes6);
      }
      var byteCount = bytes6.length();
      var value = _fromDer(bytes6, bytes6.length(), 0, options);
      if (options.parseAllBytes && bytes6.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes6.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes6, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes6, remaining, 2);
      var b1 = bytes6.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes6.length();
      var length3 = _getValueLength(bytes6, remaining);
      remaining -= start - bytes6.length();
      if (length3 !== void 0 && length3 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes6.length();
          error.remaining = remaining;
          error.requested = length3;
          throw error;
        }
        length3 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length3 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes6, remaining, 2);
            if (bytes6.bytes(2) === String.fromCharCode(0, 0)) {
              bytes6.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes6.length();
            value.push(_fromDer(bytes6, remaining, depth + 1, options));
            remaining -= start - bytes6.length();
          }
        } else {
          while (length3 > 0) {
            start = bytes6.length();
            value.push(_fromDer(bytes6, length3, depth + 1, options));
            remaining -= start - bytes6.length();
            length3 -= start - bytes6.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes6.bytes(length3);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length3 > 1) {
        var savedRead = bytes6.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes6, remaining, 1);
          unused = bytes6.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes6.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes6, remaining, depth + 1, subOptions);
            var used = start - bytes6.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length3 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes6.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length3 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length3 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length3 > 0; length3 -= 2) {
            _checkBufferLength(bytes6, remaining, 2);
            value += String.fromCharCode(bytes6.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes6.getBytes(length3);
          remaining -= length3;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes6 = forge2.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge2.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes6.putByte(b1);
      if (value.length() <= 127) {
        bytes6.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes6.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes6.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes6.putBuffer(value);
      return bytes6;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes6 = forge2.util.createBuffer();
      bytes6.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i2], 10);
        do {
          b = value & 127;
          value = value >>> 7;
          if (!last) {
            b |= 128;
          }
          valueBytes.push(b);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes6.putByte(valueBytes[n]);
        }
      }
      return bytes6;
    };
    asn1.derToOid = function(bytes6) {
      var oid;
      if (typeof bytes6 === "string") {
        bytes6 = forge2.util.createBuffer(bytes6);
      }
      var b = bytes6.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value = 0;
      while (bytes6.length() > 0) {
        b = bytes6.getByte();
        value = value << 7;
        if (b & 128) {
          value += b & 127;
        } else {
          oid += "." + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push(("" + date.getUTCFullYear()).substr(2));
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format2.length; ++i2) {
        if (format2[i2].length < 2) {
          rval += "0";
        }
        rval += format2[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push("" + date.getUTCFullYear());
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format2.length; ++i2) {
        if (format2[i2].length < 2) {
          rval += "0";
        }
        rval += format2[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge2.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes6) {
      if (typeof bytes6 === "string") {
        bytes6 = forge2.util.createBuffer(bytes6);
      }
      var n = bytes6.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes6.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge2.util.isArray(v.value)) {
            var j = 0;
            for (var i2 = 0; rval && i2 < v.value.length; ++i2) {
              rval = v.value[i2].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i2], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge2.pki && forge2.pki.oids) {
            if (oid in forge2.pki.oids) {
              rval += " (" + forge2.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge2.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge2.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge2.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge2.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge2.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge2.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    module2.exports = forge2.md = forge2.md || {};
    forge2.md.algorithms = forge2.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_md();
    require_util();
    var hmac4 = module2.exports = forge2.hmac = forge2.hmac || {};
    hmac4.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md2, key) {
        if (md2 !== null) {
          if (typeof md2 === "string") {
            md2 = md2.toLowerCase();
            if (md2 in forge2.md.algorithms) {
              _md = forge2.md.algorithms[md2].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md2 + '"');
            }
          } else {
            _md = md2;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge2.util.createBuffer(key);
          } else if (forge2.util.isArray(key)) {
            var tmp = key;
            key = forge2.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge2.util.createBuffer();
          _opadding = forge2.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes6) {
        _md.update(bytes6);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS({
  "node_modules/node-forge/lib/md5.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_md();
    require_util();
    var md5 = module2.exports = forge2.md5 = forge2.md5 || {};
    forge2.md.md5 = forge2.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(16);
      var md2 = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var bits, carry = 0;
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          bits = md2.fullMessageLength[i2] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        _k[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s, w, bytes6) {
      var t, a, b, c, d, f, r, i2;
      var len = bytes6.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2] = bytes6.getInt32Le();
          f = d ^ b & (c ^ d);
          t = a + f + _k[i2] + w[i2];
          r = _r[i2];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        for (; i2 < 32; ++i2) {
          f = c ^ d & (b ^ c);
          t = a + f + _k[i2] + w[_g[i2]];
          r = _r[i2];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        for (; i2 < 48; ++i2) {
          f = b ^ c ^ d;
          t = a + f + _k[i2] + w[_g[i2]];
          r = _r[i2];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        for (; i2 < 64; ++i2) {
          f = c ^ (b | ~d);
          t = a + f + _k[i2] + w[_g[i2]];
          r = _r[i2];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    var pem = module2.exports = forge2.pem = forge2.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header2;
      if (msg.procType) {
        header2 = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header2);
      }
      if (msg.contentDomain) {
        header2 = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header2);
      }
      if (msg.dekInfo) {
        header2 = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header2.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header2);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge2.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match2;
      while (true) {
        match2 = rMessage.exec(str);
        if (!match2) {
          break;
        }
        var type = match2[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge2.util.decode64(match2[3])
        };
        rval.push(msg);
        if (!match2[2]) {
          continue;
        }
        var lines = match2[2].split(rCRLF);
        var li = 0;
        while (match2 && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match2 = line.match(rHeader);
          if (match2) {
            var header2 = { name: match2[1], values: [] };
            var values = match2[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header2.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header2.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header2.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header2.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header2.name === "DEK-Info") {
              if (header2.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header2);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header2) {
      var rval = header2.name + ": ";
      var values = [];
      var insertSpace = function(match2, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header2.values.length; ++i2) {
        values.push(header2.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length3 = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length3) {
        if (length3 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length3 = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge2.des = forge2.des || {};
    forge2.des.startEncrypting = function(key, iv, output6, mode) {
      var cipher = _createCipher({
        key,
        output: output6,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge2.des.startDecrypting = function(key, iv, output6, mode) {
      var cipher = _createCipher({
        key,
        output: output6,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge2.des.Algorithm = function(name4, mode) {
      var self2 = this;
      self2.name = name4;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge2.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge2.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge2.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge2.cipher.modes.ctr);
    function registerAlgorithm(name4, mode) {
      var factory = function() {
        return new forge2.des.Algorithm(name4, mode);
      };
      forge2.cipher.registerAlgorithm(name4, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left2 = key.getInt32();
        var right2 = key.getInt32();
        tmp = (left2 >>> 4 ^ right2) & 252645135;
        right2 ^= tmp;
        left2 ^= tmp << 4;
        tmp = (right2 >>> -16 ^ left2) & 65535;
        left2 ^= tmp;
        right2 ^= tmp << -16;
        tmp = (left2 >>> 2 ^ right2) & 858993459;
        right2 ^= tmp;
        left2 ^= tmp << 2;
        tmp = (right2 >>> -16 ^ left2) & 65535;
        left2 ^= tmp;
        right2 ^= tmp << -16;
        tmp = (left2 >>> 1 ^ right2) & 1431655765;
        right2 ^= tmp;
        left2 ^= tmp << 1;
        tmp = (right2 >>> 8 ^ left2) & 16711935;
        left2 ^= tmp;
        right2 ^= tmp << 8;
        tmp = (left2 >>> 1 ^ right2) & 1431655765;
        right2 ^= tmp;
        left2 ^= tmp << 1;
        tmp = left2 << 8 | right2 >>> 20 & 240;
        left2 = right2 << 24 | right2 << 8 & 16711680 | right2 >>> 8 & 65280 | right2 >>> 24 & 240;
        right2 = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left2 = left2 << 2 | left2 >>> 26;
            right2 = right2 << 2 | right2 >>> 26;
          } else {
            left2 = left2 << 1 | left2 >>> 27;
            right2 = right2 << 1 | right2 >>> 27;
          }
          left2 &= -15;
          right2 &= -15;
          var lefttmp = pc2bytes0[left2 >>> 28] | pc2bytes1[left2 >>> 24 & 15] | pc2bytes2[left2 >>> 20 & 15] | pc2bytes3[left2 >>> 16 & 15] | pc2bytes4[left2 >>> 12 & 15] | pc2bytes5[left2 >>> 8 & 15] | pc2bytes6[left2 >>> 4 & 15];
          var righttmp = pc2bytes7[right2 >>> 28] | pc2bytes8[right2 >>> 24 & 15] | pc2bytes9[right2 >>> 20 & 15] | pc2bytes10[right2 >>> 16 & 15] | pc2bytes11[right2 >>> 12 & 15] | pc2bytes12[right2 >>> 8 & 15] | pc2bytes13[right2 >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output6, decrypt3) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt3 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt3 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left2 = input[0];
      var right2 = input[1];
      tmp = (left2 >>> 4 ^ right2) & 252645135;
      right2 ^= tmp;
      left2 ^= tmp << 4;
      tmp = (left2 >>> 16 ^ right2) & 65535;
      right2 ^= tmp;
      left2 ^= tmp << 16;
      tmp = (right2 >>> 2 ^ left2) & 858993459;
      left2 ^= tmp;
      right2 ^= tmp << 2;
      tmp = (right2 >>> 8 ^ left2) & 16711935;
      left2 ^= tmp;
      right2 ^= tmp << 8;
      tmp = (left2 >>> 1 ^ right2) & 1431655765;
      right2 ^= tmp;
      left2 ^= tmp << 1;
      left2 = left2 << 1 | left2 >>> 31;
      right2 = right2 << 1 | right2 >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i2 = looping[j]; i2 != endloop; i2 += loopinc) {
          var right1 = right2 ^ keys[i2];
          var right22 = (right2 >>> 4 | right2 << 28) ^ keys[i2 + 1];
          tmp = left2;
          left2 = right2;
          right2 = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right22 >>> 24 & 63] | spfunction3[right22 >>> 16 & 63] | spfunction5[right22 >>> 8 & 63] | spfunction7[right22 & 63]);
        }
        tmp = left2;
        left2 = right2;
        right2 = tmp;
      }
      left2 = left2 >>> 1 | left2 << 31;
      right2 = right2 >>> 1 | right2 << 31;
      tmp = (left2 >>> 1 ^ right2) & 1431655765;
      right2 ^= tmp;
      left2 ^= tmp << 1;
      tmp = (right2 >>> 8 ^ left2) & 16711935;
      left2 ^= tmp;
      right2 ^= tmp << 8;
      tmp = (right2 >>> 2 ^ left2) & 858993459;
      left2 ^= tmp;
      right2 ^= tmp << 2;
      tmp = (left2 >>> 16 ^ right2) & 65535;
      right2 ^= tmp;
      left2 ^= tmp << 16;
      tmp = (left2 >>> 4 ^ right2) & 252645135;
      right2 ^= tmp;
      left2 ^= tmp << 4;
      output6[0] = left2;
      output6[1] = right2;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge2.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge2.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output6 = null;
        if (options2 instanceof forge2.util.ByteBuffer) {
          output6 = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output6;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge2.pkcs5 = forge2.pkcs5 || {};
    var crypto9;
    if (forge2.util.isNodejs && !forge2.options.usePureJavaScript) {
      crypto9 = require("crypto");
    }
    module2.exports = forge2.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md2, callback) {
      if (typeof md2 === "function") {
        callback = md2;
        md2 = null;
      }
      if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && crypto9.pbkdf2 && (md2 === null || typeof md2 !== "object") && (crypto9.pbkdf2Sync.length > 4 || (!md2 || md2 === "sha1"))) {
        if (typeof md2 !== "string") {
          md2 = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto9.pbkdf2Sync.length === 4) {
            return crypto9.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto9.pbkdf2Sync(p, s, c, dkLen, md2).toString("binary");
        }
        if (crypto9.pbkdf2Sync.length === 4) {
          return crypto9.pbkdf2(p, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto9.pbkdf2(p, s, c, dkLen, md2, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md2 === "undefined" || md2 === null) {
        md2 = "sha1";
      }
      if (typeof md2 === "string") {
        if (!(md2 in forge2.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md2);
        }
        md2 = forge2.md[md2].create();
      }
      var hLen = md2.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge2.hmac.create();
      prf.start(md2, p);
      var dk = "";
      var xor3, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge2.util.int32ToBytes(i2));
          xor3 = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor3 = forge2.util.xorBytes(xor3, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor3 : xor3.substr(0, r);
        }
        return dk;
      }
      var i2 = 1, j;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge2.util.int32ToBytes(i2));
        xor3 = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor3 = forge2.util.xorBytes(xor3, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge2.util.setImmediate(inner);
        }
        dk += i2 < len ? xor3 : xor3.substr(0, r);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha2568 = module2.exports = forge2.sha256 = forge2.sha256 || {};
    forge2.md.sha256 = forge2.md.algorithms.sha256 = sha2568;
    sha2568.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(64);
      var md2 = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes6) {
      var t1, t2, s0, s1, ch, maj, i2, a, b, c, d, e, f, g, h;
      var len = bytes6.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2] = bytes6.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i2] = t1 + w[i2 - 7] + t2 + w[i2 - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i2] + w[i2];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    var _crypto = null;
    if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require("crypto");
    }
    var prng = module2.exports = forge2.prng = forge2.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md2 = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md2.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge2.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge2.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes6 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes6.length;
          b.putBytes(bytes6);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge2.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge2.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes6 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes6.length;
          b.putBytes(bytes6);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes6) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes6);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md3 = ctx.plugin.md.create();
        md3.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md3.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md3.digest().getBytes();
        md3.start();
        md3.update(ctx.keyBytes);
        var seedBytes = md3.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge2.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge2.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b.putInt32(entropy[i3]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes6) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes6.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes6) {
        var count = bytes6.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes6.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n) {
        var bytes6 = "";
        for (var x = 0; x < n; x += 8) {
          bytes6 += String.fromCharCode(i3 >> x & 255);
        }
        ctx.collect(bytes6);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes6) {
                worker.postMessage({ forge: { prng: { err, bytes: bytes6 } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_aes();
    require_sha2562();
    require_prng();
    require_util();
    (function() {
      if (forge2.random && forge2.random.getBytes) {
        module2.exports = forge2.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge2.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge2.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge2.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge2.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge2.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge2.md.sha256;
        function spawnPrng() {
          var ctx = forge2.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge2.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge2.options.usePureJavaScript || !forge2.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge2.random) {
          forge2.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge2.random[key] = _ctx[key];
          }
        }
        forge2.random.createInstance = spawnPrng;
        module2.exports = forge2.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge2.rc2 = forge2.rc2 || {};
    forge2.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge2.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T; i2 < 128; i2++) {
        L.putByte(piTable[L.at(i2 - 1) + L.at(i2 - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L.setAt(i2, piTable[L.at(i2 + 1) ^ L.at(i2 + T8)]);
      }
      return L;
    };
    var createCipher3 = function(key, bits, encrypt3) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j, K = [];
      key = forge2.rc2.expandKey(key, bits);
      for (i2 = 0; i2 < 64; i2++) {
        K.push(key.getInt16Le());
      }
      if (encrypt3) {
        mixRound = function(R) {
          for (i2 = 0; i2 < 4; i2++) {
            R[i2] += K[j] + (R[(i2 + 3) % 4] & R[(i2 + 2) % 4]) + (~R[(i2 + 3) % 4] & R[(i2 + 1) % 4]);
            R[i2] = rol(R[i2], s[i2]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i2 = 0; i2 < 4; i2++) {
            R[i2] += K[R[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i2 = 3; i2 >= 0; i2--) {
            R[i2] = ror(R[i2], s[i2]);
            R[i2] -= K[j] + (R[(i2 + 3) % 4] & R[(i2 + 2) % 4]) + (~R[(i2 + 3) % 4] & R[(i2 + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i2 = 3; i2 >= 0; i2--) {
            R[i2] -= K[R[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt3) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt3 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr3 = 0; ctr3 < plan[ptr][0]; ctr3++) {
            plan[ptr][1](R);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt3) {
              _iv.putInt16Le(R[i2]);
            } else {
              R[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output6) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge2.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge2.util.createBuffer();
          _output = output6 || new forge2.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad4) {
          var rval = true;
          if (encrypt3) {
            if (pad4) {
              rval = pad4(8, _input, !encrypt3);
            } else {
              var padding2 = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding2, padding2);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt3) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad4) {
                rval = pad4(8, _output, !encrypt3);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge2.rc2.startEncrypting = function(key, iv, output6) {
      var cipher = forge2.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output6);
      return cipher;
    };
    forge2.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher3(key, bits, true);
    };
    forge2.rc2.startDecrypting = function(key, iv, output6) {
      var cipher = forge2.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output6);
      return cipher;
    };
    forge2.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher3(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    module2.exports = forge2.jsbn = forge2.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a) this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a) this.fromString(a, 256);
        else this.fromString(a, b);
    }
    forge2.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i2++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i2, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i2] & 32767;
        var h = this.data[i2++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i2, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i2] & 16383;
        var h = this.data[i2++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i2) {
      var c = BI_RC[s.charCodeAt(i2)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i2 = this.t - 1; i2 >= 0; --i2) r.data[i2] = this.data[i2];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0) this.data[0] = x;
      else if (x < -1) this.data[0] = x + this.DV;
      else this.t = 0;
    }
    function nbv(i2) {
      var r = nbi();
      r.fromInt(i2);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 256) k = 8;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s.length, mi = false, sh = 0;
      while (--i2 >= 0) {
        var x = k == 8 ? s[i2] & 255 : intAt(s, i2);
        if (x < 0) {
          if (s.charAt(i2) == "-") mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
    }
    function bnToString(b) {
      if (this.s < 0) return "-" + this.negate().toString(b);
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i2 = this.t;
      var p = this.DB - i2 * this.DB % k;
      if (i2-- > 0) {
        if (p < this.DB && (d = this.data[i2] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i2 >= 0) {
          if (p < k) {
            d = (this.data[i2] & (1 << p) - 1) << k - p;
            d |= this.data[--i2] >> (p += this.DB - k);
          } else {
            d = this.data[i2] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i2;
            }
          }
          if (d > 0) m = true;
          if (m) r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0) return r;
      var i2 = this.t;
      r = i2 - a.t;
      if (r != 0) return this.s < 0 ? -r : r;
      while (--i2 >= 0) if ((r = this.data[i2] - a.data[i2]) != 0) return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) r.data[i2 + n] = this.data[i2];
      for (i2 = n - 1; i2 >= 0; --i2) r.data[i2] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i2 = n; i2 < this.t; ++i2) r.data[i2 - n] = this.data[i2];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r.data[i2 + ds + 1] = this.data[i2] >> cbs | c;
        c = (this.data[i2] & bm) << bs;
      }
      for (i2 = ds - 1; i2 >= 0; --i2) r.data[i2] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i2 = ds + 1; i2 < this.t; ++i2) {
        r.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
        r.data[i2 - ds] = this.data[i2] >> bs;
      }
      if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] - a.data[i2];
        r.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c -= a.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1) r.data[i2++] = this.DV + c;
      else if (c > 0) r.data[i2++] = c;
      r.t = i2;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i2 = x.t;
      r.t = i2 + y.t;
      while (--i2 >= 0) r.data[i2] = 0;
      for (i2 = 0; i2 < y.t; ++i2) r.data[i2 + x.t] = x.am(0, y.data[i2], r, i2, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i2 = r.t = 2 * x.t;
      while (--i2 >= 0) r.data[i2] = 0;
      for (i2 = 0; i2 < x.t - 1; ++i2) {
        var c = x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
        if ((r.data[i2 + x.t] += x.am(i2 + 1, 2 * x.data[i2], r, 2 * i2 + 1, c, x.t - i2 - 1)) >= x.DV) {
          r.data[i2 + x.t] -= x.DV;
          r.data[i2 + x.t + 1] = 1;
        }
      }
      if (r.t > 0) r.data[r.t - 1] += x.am(i2, x.data[i2], r, 2 * i2, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0) return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null) q.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
      }
      if (r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0) return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i2 = r.t, j = i2 - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys) y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i2] == y0 ? this.DM : Math.floor(r.data[i2] * d1 + (r.data[i2 - 1] + e) * d2);
        if ((r.data[i2] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i2] < --qd) r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms) BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0) r.rShiftTo(nsh, r);
      if (ts < 0) BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x = this.data[0];
      if ((x & 1) == 0) return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j = x.data[i2] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i2] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i2 + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i2, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i2 = nbits(e) - 1;
      g.copyTo(r);
      while (--i2 >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i2) > 0) z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven()) z = new Classic(m);
      else z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix(b) {
      if (b == null) b = 10;
      if (this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i2 = 0; i2 < s.length; ++i2) {
        var x = intAt(s, i2);
        if (x < 0) {
          if (s.charAt(i2) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2) this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0) x[0] &= (1 << t) - 1;
        else x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i2 * this.DB % 8, d, k = 0;
      if (i2-- > 0) {
        if (p < this.DB && (d = this.data[i2] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i2 >= 0) {
          if (p < 8) {
            d = (this.data[i2] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i2] >> (p += this.DB - 8);
          } else {
            d = this.data[i2] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i2;
            }
          }
          if ((d & 128) != 0) d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128)) ++k;
          if (k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i2, f, m = Math.min(a.t, this.t);
      for (i2 = 0; i2 < m; ++i2) r.data[i2] = op(this.data[i2], a.data[i2]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i2 = m; i2 < this.t; ++i2) r.data[i2] = op(this.data[i2], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i2 = m; i2 < a.t; ++i2) r.data[i2] = op(f, a.data[i2]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i2 = 0; i2 < this.t; ++i2) r.data[i2] = this.DM & ~this.data[i2];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0) this.rShiftTo(-n, r);
      else this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0) this.lShiftTo(-n, r);
      else this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0) return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0) ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0) return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2) r += cbit(this.data[i2] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t) return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i2 = 0, c = 0, m = Math.min(a.t, this.t);
      while (i2 < m) {
        c += this.data[i2] + a.data[i2];
        r.data[i2++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i2 < this.t) {
          c += this.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i2 < a.t) {
          c += a.data[i2];
          r.data[i2++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0) r.data[i2++] = c;
      else if (c < -1) r.data[i2++] = this.DV + c;
      r.t = i2;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0) return;
      while (this.t <= w) this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t) this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i2 = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i2;
      while (i2 > 0) r.data[--i2] = 0;
      var j;
      for (j = r.t - this.t; i2 < j; ++i2) r.data[i2 + this.t] = this.am(0, a.data[i2], r, i2, 0, this.t);
      for (j = Math.min(a.t, n); i2 < j; ++i2) this.am(0, a.data[i2], r, i2, 0, n - i2);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i2 = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i2 >= 0) r.data[i2] = 0;
      for (i2 = Math.max(n - this.t, 0); i2 < a.t; ++i2)
        r.data[this.t + i2 - n] = this.am(n - i2, a.data[i2], r, 0, 0, this.t + i2 - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
      else if (x.compareTo(this.m) < 0) return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i2 = e.bitLength(), k, r = nbv(1), z;
      if (i2 <= 0) return r;
      else if (i2 < 18) k = 1;
      else if (i2 < 48) k = 3;
      else if (i2 < 144) k = 4;
      else if (i2 < 768) k = 5;
      else k = 6;
      if (i2 < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i2 = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i2 >= k1) w = e.data[j] >> i2 - k1 & km;
        else {
          w = (e.data[j] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j > 0) w |= e.data[j - 1] >> this.DB + i2 - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i2 -= n) < 0) {
          i2 += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0) z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i2) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i2 = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0) return x;
      if (i2 < g) g = i2;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i2 = x.getLowestSetBit()) > 0) x.rShiftTo(i2, x);
        if ((i2 = y.getLowestSetBit()) > 0) y.rShiftTo(i2, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0) y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0) return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0) r = this.data[0] % n;
        else for (var i2 = this.t - 1; i2 >= 0; --i2) r = (d * r + this.data[i2]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven()) b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven()) d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac) a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac) c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d.compareTo(m) >= 0) return d.subtract(m);
      if (d.signum() < 0) d.addTo(m, d);
      else return d;
      if (d.signum() < 0) return d.add(m);
      else return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i2, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x.data[0] == lowprimes[i2]) return true;
        return false;
      }
      if (x.isEven()) return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m = lowprimes[i2], j = i2 + 1;
        while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while (i2 < j) if (m % lowprimes[i2++] == 0) return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0) return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i2 = 0; i2 < t; ++i2) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          for (var i2 = 0; i2 < x.length; ++i2) {
            x[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha12 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha13 = module2.exports = forge2.sha1 = forge2.sha1 || {};
    forge2.md.sha1 = forge2.md.algorithms.sha1 = sha13;
    sha13.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(80);
      var md2 = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes6) {
      var t, a, b, c, d, e, f, i2;
      var len = bytes6.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t = bytes6.getInt32();
          w[i2] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 20; ++i2) {
          t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
          t = t << 1 | t >>> 31;
          w[i2] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 32; ++i2) {
          t = w[i2 - 3] ^ w[i2 - 8] ^ w[i2 - 14] ^ w[i2 - 16];
          t = t << 1 | t >>> 31;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 40; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 60; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i2 < 80; ++i2) {
          t = w[i2 - 6] ^ w[i2 - 16] ^ w[i2 - 28] ^ w[i2 - 32];
          t = t << 2 | t >>> 30;
          w[i2] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    require_random();
    require_sha12();
    var pkcs1 = module2.exports = forge2.pkcs1 = forge2.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md2 = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md2) {
        md2 = forge2.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md2.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge2.random.getBytes(md2.digestLength);
      } else if (seed.length !== md2.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md2.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var maskedDB = forge2.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var maskedSeed = forge2.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md2 = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md2 === void 0) {
        md2 = forge2.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      if (keyLength < 2 * md2.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md2.digestLength + 1);
      var maskedDB = em.substring(1 + md2.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var seed = forge2.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var db = forge2.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md2.digestLength);
      var error = y !== "\0";
      for (var i2 = 0; i2 < md2.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md2.digestLength;
      for (var j = md2.digestLength; j < db.length; j++) {
        var code4 = db.charCodeAt(j);
        var is_0 = code4 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code4 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash3) {
      if (!hash3) {
        hash3 = forge2.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash3.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash3.start();
        hash3.update(seed + c);
        t += hash3.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge2.prime) {
        module2.exports = forge2.prime;
        return;
      }
      var prime = module2.exports = forge2.prime = forge2.prime || {};
      var BigInteger = forge2.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge2.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i2 = 0; i2 < x.length; ++i2) {
              x[i2] = b.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge2.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge2.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex2 = num.toString(16);
            e.target.postMessage({
              hex: hex2,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100) return 27;
        if (bits <= 150) return 18;
        if (bits <= 200) return 15;
        if (bits <= 250) return 12;
        if (bits <= 300) return 9;
        if (bits <= 350) return 8;
        if (bits <= 400) return 7;
        if (bits <= 500) return 6;
        if (bits <= 600) return 5;
        if (bits <= 800) return 4;
        if (bits <= 1250) return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge2.util.isNodejs ? require("crypto") : null;
    var asn1 = forge2.asn1;
    var util2 = forge2.util;
    forge2.pki = forge2.pki || {};
    module2.exports = forge2.pki.rsa = forge2.rsa = forge2.rsa || {};
    var pki2 = forge2.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge2.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md2) {
      var oid;
      if (md2.algorithm in pki2.oids) {
        oid = pki2.oids[md2.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md2.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest3 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md2.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest3);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge2.util.bytesToHex(forge2.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki2.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge2.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge2.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge2.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki2.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge2.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge2.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge2.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki2.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge2.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i2 = 0; i2 < x.length; ++i2) {
            x[i2] = b.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki2.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki2.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki2.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki2.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge2.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki2.privateKeyFromPem(priv),
                publicKey: pki2.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki2.privateKeyFromAsn1(
                  asn1.fromDer(forge2.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki2.privateKeyFromAsn1(
                  asn1.fromDer(forge2.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki2.privateKeyFromPem(keypair.privateKey),
              publicKey: pki2.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki2.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki2.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge2.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki2.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest3, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest4, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge2.oids.md2 || oid === forge2.oids.md5 || oid === forge2.oids.sha1 || oid === forge2.oids.sha224 || oid === forge2.oids.sha256 || oid === forge2.oids.sha384 || oid === forge2.oids.sha512 || oid === forge2.oids["sha512-224"] || oid === forge2.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge2.oids.md2 || oid === forge2.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest4 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest4, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest4 === d2;
            }
          };
        }
        var d = pki2.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest3, d, key.n.bitLength());
      };
      return key;
    };
    pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki2.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge2.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md2, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md2;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md2, key.n.bitLength());
        return pki2.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki2.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki2.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge2.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge2.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge2.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge2.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge2.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge2.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge2.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge2.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge2.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki2.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki2.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki2.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n = forge2.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge2.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki2.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki2.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki2.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge2.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes2 = forge2.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes2.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge2.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge2.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki2.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki2.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex2 = b.toString(16);
      if (hex2[0] >= "8") {
        hex2 = "00" + hex2;
      }
      var bytes6 = forge2.util.hexToBytes(hex2);
      if (bytes6.length > 1 && // leading 0x00 for positive integer
      (bytes6.charCodeAt(0) === 0 && (bytes6.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes6.charCodeAt(0) === 255 && (bytes6.charCodeAt(1) & 128) === 128)) {
        return bytes6.substr(1);
      }
      return bytes6;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100) return 27;
      if (bits <= 150) return 18;
      if (bits <= 200) return 15;
      if (bits <= 250) return 12;
      if (bits <= 300) return 9;
      if (bits <= 350) return 8;
      if (bits <= 400) return 7;
      if (bits <= 500) return 6;
      if (bits <= 600) return 5;
      if (bits <= 800) return 4;
      if (bits <= 1250) return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge2.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes6 = forge2.util.hexToBytes(x.toString(16));
      var buffer2 = new Uint8Array(bytes6.length);
      for (var i2 = 0; i2 < bytes6.length; ++i2) {
        buffer2[i2] = bytes6.charCodeAt(i2);
      }
      return buffer2;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge2.asn1;
    var pki2 = forge2.pki = forge2.pki || {};
    module2.exports = pki2.pbe = forge2.pbe = forge2.pbe || {};
    var oids = pki2.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki2.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge2.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge2.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md2 = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
        var iv = forge2.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge2.util.ByteBuffer(salt);
        var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge2.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki2.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki2.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge2.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki2.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki2.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));
        rval = pki2.encryptPrivateKeyInfo(rval, password, options);
        return pki2.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge2.random.getBytesSync(8);
          cipherFn = forge2.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge2.random.getBytesSync(8);
          cipherFn = forge2.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki2.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge2.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge2.pem.encode(msg);
    };
    pki2.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge2.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge2.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge2.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge2.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge2.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge2.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge2.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki2.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki2.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md2) {
      var j, l;
      if (typeof md2 === "undefined" || md2 === null) {
        if (!("sha1" in forge2.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md2 = forge2.md.sha1.create();
      }
      var u = md2.digestLength;
      var v = md2.blockLength;
      var result = new forge2.util.ByteBuffer();
      var passBuf = new forge2.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge2.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge2.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge2.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i2 = 1; i2 <= c; i2++) {
        var buf2 = new forge2.util.ByteBuffer();
        buf2.putBytes(D.bytes());
        buf2.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md2.start();
          md2.update(buf2.getBytes());
          buf2 = md2.digest();
        }
        var B = new forge2.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf2.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge2.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge2.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf2);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki2.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki2.oids["pkcs5PBES2"]:
          return pki2.pbe.getCipherForPBES2(oid, params, password);
        case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki2.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki2.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki2.oids["aes128-CBC"] && oid !== pki2.oids["aes192-CBC"] && oid !== pki2.oids["aes256-CBC"] && oid !== pki2.oids["des-EDE3-CBC"] && oid !== pki2.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge2.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki2.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge2.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge2.des.createDecryptionCipher;
          break;
      }
      var md2 = prfOidToMessageDigest(capture.prfOid);
      var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge2.util.createBuffer(capture.salt);
      var count = forge2.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge2.des.startDecrypting;
          break;
        case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge2.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md2 = prfOidToMessageDigest(capture.prfOid);
      var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md2);
      md2.start();
      var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md2);
      return cipherFn(key, iv);
    };
    pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md2) {
      if (typeof md2 === "undefined" || md2 === null) {
        if (!("md5" in forge2.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md2 = forge2.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash3(md2, password + salt)];
      for (var length3 = 16, i2 = 1; length3 < dkLen; ++i2, length3 += 16) {
        digests.push(hash3(md2, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash3(md2, bytes6) {
      return md2.start().update(bytes6).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki2.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge2.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge2.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge2.asn1;
    var p7v = module2.exports = forge2.pkcs7asn1 = forge2.pkcs7asn1 || {};
    forge2.pkcs7 = forge2.pkcs7 || {};
    forge2.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    forge2.mgf = forge2.mgf || {};
    var mgf1 = module2.exports = forge2.mgf.mgf1 = forge2.mgf1 = forge2.mgf1 || {};
    mgf1.create = function(md2) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed, maskLen) {
          var t = new forge2.util.ByteBuffer();
          var len = Math.ceil(maskLen / md2.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c = new forge2.util.ByteBuffer();
            c.putInt32(i2);
            md2.start();
            md2.update(seed + c.getBytes());
            t.putBuffer(md2.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_mgf1();
    module2.exports = forge2.mgf = forge2.mgf || {};
    forge2.mgf.mgf1 = forge2.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge2.pss = forge2.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash3 = options.md;
      var mgf = options.mgf;
      var hLen = hash3.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge2.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge2.random;
      var pssobj = {};
      pssobj.encode = function(md2, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md2.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge2.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h = hash3.digest().getBytes();
        var ps = new forge2.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge2.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h_ = hash3.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge2.asn1;
    var pki2 = module2.exports = forge2.pki = forge2.pki || {};
    var oids = pki2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge2.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki2.RDNAttributesAsArray = function(rdn, md2) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i2 = 0; i2 < set.value.length; ++i2) {
          obj = {};
          attr = set.value[i2];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md2) {
            md2.update(obj.type);
            md2.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq2 = attributes[si];
        var type = asn1.derToOid(seq2.value[0].value);
        var values = seq2.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        // deprecated alias
        case "sha1WithRSASignature":
          return forge2.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge2.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge2.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge2.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge2.md.sha512.create();
        case "RSASSA-PSS":
          return forge2.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        // deprecated alias
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash3, mgf;
          hash3 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash3 === void 0 || forge2.md[hash3] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge2.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge2.mgf[mgf].create(forge2.md[hash3].create());
          hash3 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash3 === void 0 || forge2.md[hash3] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          scheme = forge2.pss.create(
            forge2.md[hash3].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki2.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificateFromAsn1(obj, computeHash);
    };
    pki2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki2.publicKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki2.publicKeyFromAsn1(obj);
    };
    pki2.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki2.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md2 = options.md || forge2.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes6;
      switch (type) {
        case "RSAPublicKey":
          bytes6 = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes6 = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md2.start();
      md2.update(bytes6);
      var digest3 = md2.digest();
      if (options.encoding === "hex") {
        var hex2 = digest3.toHex();
        if (options.delimiter) {
          return hex2.match(/.{2}/g).join(options.delimiter);
        }
        return hex2;
      } else if (options.encoding === "binary") {
        return digest3.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest3;
    };
    pki2.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = /* @__PURE__ */ new Date();
      cert.validity.notAfter = /* @__PURE__ */ new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
          ext = cert.extensions[i2];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md2) {
        cert.md = md2 || forge2.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki2.getTBSCertificate(cert);
        var bytes6 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes6.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md2 = child.md;
        if (md2 === null) {
          md2 = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate2 = child.tbsCertificate || pki2.getTBSCertificate(child);
          var bytes6 = asn1.toDer(tbsCertificate2);
          md2.update(bytes6.getBytes());
        }
        if (md2 !== null) {
          rval = _verifySignature({
            certificate: cert,
            md: md2,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i2 = cert.issuer;
        var s = parent.subject;
        if (i2.hash && s.hash) {
          rval = i2.hash === s.hash;
        } else if (i2.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i2.attributes.length; ++n) {
            iattr = i2.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
          var ext = cert.extensions[i2];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge2.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge2.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge2.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge2.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes6 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes6.getBytes());
      }
      var imd = forge2.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge2.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki2.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              // rfc822Name
              case 1:
              // dNSName
              case 2:
              // uniformResourceIdentifier (URI)
              case 6:
                break;
              // IPAddress
              case 7:
                altName.ip = forge2.util.bytesToIP(gn.value);
                break;
              // registeredID
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge2.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge2.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge2.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes6 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes6.getBytes());
      }
      var smd = forge2.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki2.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki2.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md2) {
        csr.md = md2 || forge2.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
        var bytes6 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes6.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md2 = csr.md;
        if (md2 === null) {
          md2 = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          var bytes6 = asn1.toDer(cri);
          md2.update(bytes6.getBytes());
        }
        if (md2 !== null) {
          rval = _verifySignature({
            certificate: csr,
            md: md2,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge2.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki2.oids) {
            attr.name = pki2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki2.oids) {
            attr.type = pki2.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki2.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki2.oids) {
          e.name = pki2.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki2.oids) {
          e.id = pki2.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq2 = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq2.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq2.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge2.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq2 = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq2.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq2.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge2.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq2.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq2 = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge2.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq2.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge2.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq2);
      }
      return rval;
    }
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge2.util.hexToBytes(cert.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert.subject),
        // SubjectPublicKeyInfo
        pki2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki2.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki2.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki2.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki2.certificateToAsn1 = function(cert) {
      var tbsCertificate2 = cert.tbsCertificate || pki2.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate2,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq2);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq2.value.push(pki2.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki2.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki2.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge2.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        var match2 = getBySubject(cert2.subject);
        if (!match2) {
          return false;
        }
        if (!forge2.util.isArray(match2)) {
          match2 = [match2];
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match2.length; ++i3) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match2[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash3 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash3)) {
            var value = caStore.certs[hash3];
            if (!forge2.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i3 = 0; i3 < value.length; ++i3) {
                certList.push(value[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match2 = getBySubject(cert2.subject);
        if (!forge2.util.isArray(match2)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match2.length; ++i3) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match2[i3])).getBytes();
          if (der1 === der2) {
            result = match2[i3];
            match2.splice(i3, 1);
          }
        }
        if (match2.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md2 = forge2.md.sha1.create();
          subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md2);
          subject.hash = md2.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert = certs[i2];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki2.verifyCertificateChain = function(caStore, chain3, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain3 = chain3.slice(0);
      var certs = chain3.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain3.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent = chain3[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge2.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki2.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki2.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error === null && i2 < cert.extensions.length; ++i2) {
            var ext = cert.extensions[i2];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || chain3.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain3.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "node_modules/node-forge/lib/pkcs12.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha12();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var pki2 = forge2.pki;
    var p12 = module2.exports = forge2.pkcs12 = forge2.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i2 = 0; i2 < safeContents.length; i2++) {
        for (var j = 0; j < safeContents[i2].safeBags.length; j++) {
          var bag = safeContents[i2].safeBags[j];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: function(filter) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter) {
            localKeyId = filter.localKeyId;
          } else if ("localKeyIdHex" in filter) {
            localKeyId = forge2.util.hexToBytes(filter.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
            rval[filter.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter.bagType
            );
          }
          if ("friendlyName" in filter) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter.friendlyName,
              filter.bagType
            );
          }
          return rval;
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki2.oids.data) {
        var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md2 = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki2.oids.sha1:
            md2 = forge2.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki2.oids.sha256:
            md2 = forge2.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki2.oids.sha384:
            md2 = forge2.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki2.oids.sha512:
            md2 = forge2.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki2.oids.md5:
            md2 = forge2.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md2 === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge2.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge2.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md2
        );
        var mac = forge2.hmac.create();
        mac.start(md2, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge2.util.createBuffer();
        for (var i2 = 0; i2 < data.value.length; ++i2) {
          value.putBytes(data.value[i2].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i2 = 0; i2 < authSafe.value.length; i2++) {
        var contentInfo = authSafe.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki2.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki2.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error("Unsupported PKCS#12 contentType.");
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data,
        forge2.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error = new Error("Cannot read EncryptedContentInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki2.oids.data) {
        var error = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki2.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge2.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i2 = 0; i2 < safeContents.value.length; i2++) {
        var safeBag = safeContents.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error("Cannot read SafeBag.");
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki2.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki2.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          /* fall through */
          case pki2.oids.keyBag:
            try {
              bag.key = pki2.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          /* Nothing more to do. */
          case pki2.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki2.oids.x509Certificate) {
                var error2 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error2.oid = asn1.derToOid(capture.certId);
                throw error2;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki2.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error("Unsupported PKCS#12 SafeBag type.");
            error.oid = bag.type;
            throw error;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 " + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i2 = 0; i2 < attributes.length; ++i2) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i2], attributeValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 BagAttribute.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki2.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki2.oids[oid]] = [];
          for (var j = 0; j < capture.values.length; ++j) {
            decodedAttrs[pki2.oids[oid]].push(capture.values[j].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge2.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge2.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki2.certificateFromPem(pairedCert);
          }
          var sha13 = forge2.md.sha1.create();
          sha13.update(asn1.toDer(pki2.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha13.digest().getBytes();
        } else {
          localKeyId = forge2.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain3 = [];
      if (cert !== null) {
        if (forge2.util.isArray(cert)) {
          chain3 = cert;
        } else {
          chain3 = [cert];
        }
      }
      var certSafeBags = [];
      for (var i2 = 0; i2 < chain3.length; ++i2) {
        cert = chain3[i2];
        if (typeof cert === "string") {
          cert = pki2.certificateFromPem(cert);
        }
        var certBagAttrs = i2 === 0 ? bagAttrs : void 0;
        var certAsn1 = pki2.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki2.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki2.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki2.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki2.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki2.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki2.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha13 = forge2.md.sha1.create();
        var macSalt = new forge2.util.ByteBuffer(
          forge2.random.getBytes(options.saltSize)
        );
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge2.hmac.create();
        mac.start(sha13, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki2.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki2.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge2.pbe.generatePkcs12Key;
  }
});

// node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "node_modules/node-forge/lib/pki.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var pki2 = module2.exports = forge2.pki = forge2.pki || {};
    pki2.pemToDer = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge2.util.createBuffer(msg.body);
    };
    pki2.privateKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki2.privateKeyFromAsn1(obj);
    };
    pki2.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki2.privateKeyToAsn1(key)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki2.privateKeyInfoToPem = function(pki3, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki3).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
  }
});

// node_modules/node-forge/lib/tls.js
var require_tls = __commonJS({
  "node_modules/node-forge/lib/tls.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_asn1();
    require_hmac();
    require_md5();
    require_pem();
    require_pki();
    require_random();
    require_sha12();
    require_util();
    var prf_TLS1 = function(secret, label, seed, length3) {
      var rval = forge2.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge2.util.createBuffer();
      var hmac4 = forge2.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length3 / 16);
      var sha1itr = Math.ceil(length3 / 20);
      hmac4.start("MD5", s1);
      var md5bytes = forge2.util.createBuffer();
      ai.putBytes(seed);
      for (var i2 = 0; i2 < md5itr; ++i2) {
        hmac4.start(null, null);
        hmac4.update(ai.getBytes());
        ai.putBuffer(hmac4.digest());
        hmac4.start(null, null);
        hmac4.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac4.digest());
      }
      hmac4.start("SHA1", s2);
      var sha1bytes = forge2.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i2 = 0; i2 < sha1itr; ++i2) {
        hmac4.start(null, null);
        hmac4.update(ai.getBytes());
        ai.putBuffer(hmac4.digest());
        hmac4.start(null, null);
        hmac4.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac4.digest());
      }
      rval.putBytes(forge2.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length3
      ));
      return rval;
    };
    var hmac_sha1 = function(key2, seqNum, record) {
      var hmac4 = forge2.hmac.create();
      hmac4.start("SHA1", key2);
      var b = forge2.util.createBuffer();
      b.putInt32(seqNum[0]);
      b.putInt32(seqNum[1]);
      b.putByte(record.type);
      b.putByte(record.version.major);
      b.putByte(record.version.minor);
      b.putInt16(record.length);
      b.putBytes(record.fragment.bytes());
      hmac4.update(b.getBytes());
      return hmac4.digest().getBytes();
    };
    var deflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes6 = c.deflate(record.fragment.getBytes());
        record.fragment = forge2.util.createBuffer(bytes6);
        record.length = bytes6.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes6 = c.inflate(record.fragment.getBytes());
        record.fragment = forge2.util.createBuffer(bytes6);
        record.length = bytes6.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b.getByte();
          break;
        case 2:
          len = b.getInt16();
          break;
        case 3:
          len = b.getInt24();
          break;
        case 4:
          len = b.getInt32();
          break;
      }
      return forge2.util.createBuffer(b.getBytes(len));
    };
    var writeVector = function(b, lenBytes, v) {
      b.putInt(v.length(), lenBytes << 3);
      b.putBuffer(v);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls.CipherSuites) {
        var cs = tls.CipherSuites[key2];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c.error(c, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length3) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length3) {
      var msg = null;
      var client = c.entity === tls.ConnectionEnd.client;
      if (length3 < 38) {
        c.error(c, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b = record.fragment;
        var remaining = b.length();
        msg = {
          version: {
            major: b.getByte(),
            minor: b.getByte()
          },
          random: forge2.util.createBuffer(b.getBytes(32)),
          session_id: readVector(b, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b.getBytes(2);
          msg.compression_method = b.getByte();
        } else {
          msg.cipher_suites = readVector(b, 2);
          msg.compression_methods = readVector(b, 1);
        }
        remaining = length3 - (remaining - b.length());
        if (remaining > 0) {
          var exts = readVector(b, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i2 = 0; i2 < msg.extensions.length; ++i2) {
              var ext = msg.extensions[i2];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge2.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge2.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = c.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length3) {
      var msg = tls.parseHelloMessage(c, record, length3);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length3) {
      var msg = tls.parseHelloMessage(c, record, length3);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge2.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version3;
        for (var i2 = 1; i2 < tls.SupportedVersions.length; ++i2) {
          version3 = tls.SupportedVersions[i2];
          if (version3.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = { major: version3.major, minor: version3.minor };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = c.verifyClient !== false ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length3) {
      if (length3 < 3) {
        return c.error(c, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_list: readVector(b, 3)
      };
      var cert, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge2.asn1.fromDer(cert);
          cert = forge2.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c.error(c, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length3) {
      if (length3 > 0) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length3) {
      if (length3 < 48) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b, 2).getBytes()
      };
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge2.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version3 = c.session.clientHelloVersion;
        if (version3.major !== sp.pre_master_secret.charCodeAt(0) || version3.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge2.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length3) {
      if (length3 < 3) {
        return c.error(c, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_types: readVector(b, 1),
        certificate_authorities: readVector(b, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length3) {
      if (length3 < 2) {
        return c.error(c, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var msg = {
        signature: readVector(b, 2).getBytes()
      };
      var verify = forge2.util.createBuffer();
      verify.putBuffer(c.session.md5.digest());
      verify.putBuffer(c.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert = c.session.clientCertificate;
        if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length3) {
      if (length3 > 0) {
        return c.error(c, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error.alert.description = ret;
            }
          }
          return c.error(c, error);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = function(c2, signature) {
        if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c2, signature)
          }));
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
        c2.expect = SCC;
        tls.flush(c2);
        c2.process();
      };
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 1) {
        return c.error(c, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if (c.session.resuming && client || !c.session.resuming && !client) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if (!c.session.resuming && client || c.session.resuming && !client) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length3) {
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var vd = record.fragment.getBytes();
      b = forge2.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      if (b.getBytes() !== vd) {
        return c.error(c, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if (c.session.resuming && client || !c.session.resuming && !client) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b = record.fragment;
      var alert = {
        level: b.getByte(),
        description: b.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length3 = b.getInt24();
      if (length3 > b.length()) {
        c.fragmented = record;
        record.fragment = forge2.util.createBuffer();
        b.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b.read -= 4;
      var bytes6 = b.bytes(length3 + 4);
      b.read += 4;
      if (type in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge2.md.md5.create(),
            sha1: forge2.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes6);
          c.session.sha1.update(bytes6);
        }
        hsTable[c.entity][c.expect][type](c, record, length3);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length3 = b.getInt16();
      var payload = b.getBytes(length3);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length3 > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge2.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R2, __, R4],
      /*SCE*/
      [__, R1, R2, __, R4],
      /*SKE*/
      [__, R1, R2, __, R4],
      /*SCR*/
      [__, R1, R2, __, R4],
      /*SHD*/
      [__, R1, R2, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R2, __, R4],
      /*SAD*/
      [__, R1, R2, R3, R4],
      /*SER*/
      [__, R1, R2, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R2, __, R4],
      /*CCE*/
      [__, R1, R2, __, R4],
      /*CKE*/
      [__, R1, R2, __, R4],
      /*CCV*/
      [__, R1, R2, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R2, __, R4],
      /*CAD*/
      [__, R1, R2, R3, R4],
      /*CER*/
      [__, R1, R2, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length3 = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length3 += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random, length3);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var createMode = function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c2, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c2.error(c2, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c2, record, state.read)) {
          c2.error(c2, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c2.fail;
      };
      state.write.update = function(c2, record) {
        if (!state.write.compressFunction(c2, record, state.write)) {
          c2.error(c2, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c2.error(c2, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c2.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = /* @__PURE__ */ new Date();
      var utc = +d + d.getTimezoneOffset() * 6e4;
      var rval = forge2.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge2.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b = forge2.util.createBuffer();
      b.putByte(alert.level);
      b.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge2.util.createBuffer();
      for (var i2 = 0; i2 < c.cipherSuites.length; ++i2) {
        var cs = c.cipherSuites[i2];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge2.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge2.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge2.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge2.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge2.util.createBuffer(c.virtualHost));
        var snList = forge2.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length3 = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length3);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge2.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length3 = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length3);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge2.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var cert = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert = c.getCertificate(c, hint);
      }
      var certList = forge2.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge2.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i2 = 0; i2 < cert.length; ++i2) {
            var msg = forge2.pem.decode(cert[i2])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge2.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge2.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge2.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge2.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert;
          } else {
            c.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c.error(c, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length3 = 3 + certList.length();
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length3);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b = forge2.util.createBuffer();
      b.putByte(c.session.clientHelloVersion.major);
      b.putByte(c.session.clientHelloVersion.minor);
      b.putBytes(forge2.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b.getBytes();
      var key2 = c.session.serverCertificate.publicKey;
      b = key2.encrypt(sp.pre_master_secret);
      var length3 = b.length + 2;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length3);
      rval.putInt16(b.length);
      rval.putBytes(b);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length3 = 0;
      var rval = forge2.util.createBuffer();
      if (length3 > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length3);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b = forge2.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      b = b.getBytes();
      c.getSignature = c.getSignature || function(c2, b2, callback2) {
        var privateKey = null;
        if (c2.getPrivateKey) {
          try {
            privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
            privateKey = forge2.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c2.error(c2, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c2.error(c2, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b2 = privateKey.sign(b2, null);
        }
        callback2(c2, b2);
      };
      c.getSignature(c, b, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length3 = signature.length + 2;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length3);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge2.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge2.util.createBuffer();
      for (var key2 in c.caStore.certs) {
        var cert = c.caStore.certs[key2];
        var dn = forge2.pki.distinguishedNameToAsn1(cert.subject);
        var byteBuffer = forge2.asn1.toDer(dn);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length3 = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length3);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge2.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c) {
      var b = forge2.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b.length());
      rval.putBuffer(b);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge2.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge2.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes6 = record.fragment.bytes();
        c.session.md5.update(bytes6);
        c.session.sha1.update(bytes6);
        bytes6 = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge2.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge2.util.createBuffer(data)
          }));
        }
      }
      for (var i2 = 0; i2 < records.length && !c.fail; ++i2) {
        var rec = records[i2];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i2 = 0; i2 < c.records.length; ++i2) {
        var record = c.records[i2];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i2].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge2.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge2.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge2.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge2.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge2.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge2.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge2.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge2.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge2.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge2.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge2.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge2.pki.certificateError.unknown_ca;
        default:
          return forge2.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c, chain3) {
      try {
        var options = {};
        for (var key2 in c.verifyOptions) {
          options[key2] = c.verifyOptions[key2];
        }
        options.verify = function(vfd, depth, chain4) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain4);
          if (ret !== true) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              var error = new Error("The application rejected the certificate.");
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge2.pki.verifyCertificateChain(c.caStore, chain3, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge2.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache2, capacity) {
      var rval = null;
      if (cache2 && cache2.getSession && cache2.setSession && cache2.order) {
        rval = cache2;
      } else {
        rval = {};
        rval.cache = cache2 || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache2) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache2[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge2.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i2 in rval.order) {
              if (rval.order[i2] === key3) {
                rval.order.splice(i2, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge2.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge2.util.isArray(options.caStore)) {
          caStore = forge2.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge2.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key2]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge2.util.createBuffer(),
        tlsData: forge2.util.createBuffer(),
        data: forge2.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c2, ex) {
          ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c2, tls.createAlert(c2, ex.alert));
            tls.flush(c2);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c2.fail = true;
          }
          options.error(c2, ex);
          if (fatal) {
            c2.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = { major: tls.Version.major, minor: tls.Version.minor };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof clearFail === "undefined");
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = function(c2, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c2.entity][c2.expect];
        if (aligned in handlers) {
          handlers[aligned](c2, record);
        } else {
          tls.handleUnexpected(c2, record);
        }
      };
      var _readRecordHeader = function(c2) {
        var rval = 0;
        var b = c2.input;
        var len = b.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c2.record = {
            type: b.getByte(),
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            length: b.getInt16(),
            fragment: forge2.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c2.record.version.major === c2.version.major;
          if (compatibleVersion && c2.session && c2.session.version) {
            compatibleVersion = c2.record.version.minor === c2.version.minor;
          }
          if (!compatibleVersion) {
            c2.error(c2, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c2) {
        var rval = 0;
        var b = c2.input;
        var len = b.length();
        if (len < c2.record.length) {
          rval = c2.record.length - len;
        } else {
          c2.record.fragment.putBytes(b.getBytes(c2.record.length));
          b.compact();
          var s = c2.state.current.read;
          if (s.update(c2, c2.record)) {
            if (c2.fragmented !== null) {
              if (c2.fragmented.type === c2.record.type) {
                c2.fragmented.fragment.putBuffer(c2.record.fragment);
                c2.record = c2.fragmented;
              } else {
                c2.error(c2, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c2.record.ready = true;
          }
        }
        return rval;
      };
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge2.md.md5.create(),
            sha1: forge2.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data) {
        var rval = 0;
        if (data) {
          c.input.putBytes(data);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge2.util.createBuffer(data)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge2.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    module2.exports = forge2.tls = forge2.tls || {};
    for (key in tls) {
      if (typeof tls[key] !== "function") {
        forge2.tls[key] = tls[key];
      }
    }
    var key;
    forge2.tls.prf_tls1 = prf_TLS1;
    forge2.tls.hmac_sha1 = hmac_sha1;
    forge2.tls.createSessionCache = tls.createSessionCache;
    forge2.tls.createConnection = tls.createConnection;
  }
});

// node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "node_modules/node-forge/lib/aesCipherSuites.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_aes();
    require_tls();
    var tls = module2.exports = forge2.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = c.entity === forge2.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge2.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge2.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge2.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt3) {
      if (!decrypt3) {
        var padding2 = blockSize - input.length() % blockSize;
        input.fillWithByte(padding2 - 1, padding2);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output6, decrypt3) {
      var rval = true;
      if (decrypt3) {
        var len = output6.length();
        var paddingLength = output6.last();
        for (var i2 = len - 1 - paddingLength; i2 < len - 1; ++i2) {
          rval = rval && output6.at(i2) == paddingLength;
        }
        if (rval) {
          output6.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = forge2.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge2.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = compareMacs(s.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key, mac1, mac2) {
      var hmac4 = forge2.hmac.create();
      hmac4.start("SHA1", key);
      hmac4.update(mac1);
      mac1 = hmac4.digest().getBytes();
      hmac4.start(null, null);
      hmac4.update(mac2);
      mac2 = hmac4.digest().getBytes();
      return mac1 === mac2;
    }
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha5125 = module2.exports = forge2.sha512 = forge2.sha512 || {};
    forge2.md.sha512 = forge2.md.algorithms.sha512 = sha5125;
    var sha3843 = forge2.sha384 = forge2.sha512.sha384 = forge2.sha512.sha384 || {};
    sha3843.create = function() {
      return sha5125.create("SHA-384");
    };
    forge2.md.sha384 = forge2.md.algorithms.sha384 = sha3843;
    forge2.sha512.sha256 = forge2.sha512.sha256 || {
      create: function() {
        return sha5125.create("SHA-512/256");
      }
    };
    forge2.md["sha512/256"] = forge2.md.algorithms["sha512/256"] = forge2.sha512.sha256;
    forge2.sha512.sha224 = forge2.sha512.sha224 || {
      create: function() {
        return sha5125.create("SHA-512/224");
      }
    };
    forge2.md["sha512/224"] = forge2.md.algorithms["sha512/224"] = forge2.sha512.sha224;
    sha5125.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md2 = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength128 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _h = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h[i2] = _state[i2].slice(0);
        }
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i2 = 0; i2 < _h.length; ++i2) {
          h[i2] = _h[i2].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i2][1]);
          }
        }
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes6) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi, lo, w2, w7, w15, w16;
      var len = bytes6.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w[i2][0] = bytes6.getInt32() >>> 0;
          w[i2][1] = bytes6.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w2 = w[i2 - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i2 - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i2 - 7];
          w16 = w[i2 - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i2][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/node-forge/lib/asn1-validator.js"(exports2) {
    "use strict";
    var forge2 = require_forge();
    require_asn1();
    var asn1 = forge2.asn1;
    exports2.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports2.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_jsbn();
    require_random();
    require_sha5122();
    require_util();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge2.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge2.pki = forge2.pki || {};
    module2.exports = forge2.pki.ed25519 = forge2.ed25519 = forge2.ed25519 || {};
    var ed255192 = forge2.ed25519;
    ed255192.constants = {};
    ed255192.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed255192.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed255192.constants.SEED_BYTE_LENGTH = 32;
    ed255192.constants.SIGN_BYTE_LENGTH = 64;
    ed255192.constants.HASH_BYTE_LENGTH = 64;
    ed255192.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge2.random.getBytesSync(ed255192.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed255192.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed255192.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed255192.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed255192.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < 32; ++i2) {
        sk[i2] = seed[i2];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed255192.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge2.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge2.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge2.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge2.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed255192.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge2.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge2.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge2.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed255192.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed255192.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed255192.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed255192.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed255192.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < pk.length; ++i2) {
        pk[i2] = privateKey[32 + i2];
      }
      return pk;
    };
    ed255192.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed255192.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed255192.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed255192.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed255192.constants.SEED_BYTE_LENGTH + " or " + ed255192.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed255192.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH);
      for (var i2 = 0; i2 < sig.length; ++i2) {
        sig[i2] = signedMsg[i2];
      }
      return sig;
    };
    ed255192.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed255192.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed255192.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed255192.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed255192.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH + msg.length);
      var m = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH + msg.length);
      var i2;
      for (i2 = 0; i2 < ed255192.constants.SIGN_BYTE_LENGTH; ++i2) {
        sm[i2] = sig[i2];
      }
      for (i2 = 0; i2 < msg.length; ++i2) {
        sm[i2 + ed255192.constants.SIGN_BYTE_LENGTH] = msg[i2];
      }
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer2 = new NativeBuffer(message.length());
      for (var i2 = 0; i2 < buffer2.length; ++i2) {
        buffer2[i2] = message.at(i2);
      }
      return buffer2;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X2 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y2 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha5125(msg, msgLen) {
      var md2 = forge2.md.sha512.create();
      var buffer2 = new ByteBuffer(msg);
      md2.update(buffer2.getBytes(msgLen), "binary");
      var hash3 = md2.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash3, "binary");
      }
      var out = new NativeBuffer(ed255192.constants.HASH_BYTE_LENGTH);
      for (var i2 = 0; i2 < 64; ++i2) {
        out[i2] = hash3.charCodeAt(i2);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p = [gf(), gf(), gf(), gf()];
      var i2;
      var d = sha5125(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i2 = 0; i2 < 32; ++i2) {
        sk[i2 + 32] = pk[i2];
      }
      return 0;
    }
    function crypto_sign(sm, m, n, sk) {
      var i2, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var d = sha5125(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i2 = 0; i2 < n; ++i2) {
        sm[64 + i2] = m[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        sm[32 + i2] = d[32 + i2];
      }
      var r = sha5125(sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i2 = 32; i2 < 64; ++i2) {
        sm[i2] = sk[i2];
      }
      var h = sha5125(sm, n + 64);
      reduce(h);
      for (i2 = 32; i2 < 64; ++i2) {
        x[i2] = 0;
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x[i2] = r[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        for (j = 0; j < 32; j++) {
          x[i2 + j] += h[i2] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i2, mlen;
      var t = new NativeBuffer(32);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) {
        return -1;
      }
      if (unpackneg(q, pk)) {
        return -1;
      }
      for (i2 = 0; i2 < n; ++i2) {
        m[i2] = sm[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        m[i2 + 32] = pk[i2];
      }
      var h = sha5125(m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add2(p, q);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i2 = 0; i2 < n; ++i2) {
          m[i2] = 0;
        }
        return -1;
      }
      for (i2 = 0; i2 < n; ++i2) {
        m[i2] = sm[i2 + 64];
      }
      mlen = n;
      return mlen;
    }
    function modL(r, x) {
      var carry, i2, j, k;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i2] * L[j - (i2 - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i2] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; ++j) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; ++j) {
        x[j] -= carry * L[j];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x[i2 + 1] += x[i2] >> 8;
        r[i2] = x[i2] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        x[i2] = r[i2];
        r[i2] = 0;
      }
      modL(r, x);
    }
    function add2(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      for (var i2 = 0; i2 < 4; ++i2) {
        sel25519(p[i2], q[i2], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function pack25519(o, n) {
      var i2, j, b;
      var m = gf(), t = gf();
      for (i2 = 0; i2 < 16; ++i2) {
        t[i2] = n[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; ++j) {
        m[0] = t[0] - 65517;
        for (i2 = 1; i2 < 15; ++i2) {
          m[i2] = t[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
          m[i2 - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o[2 * i2] = t[i2] & 255;
        o[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        M(r[0], r[0], I);
      }
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p[31] >> 7) {
        Z(r[0], gf0, r[0]);
      }
      M(r[3], r[0], r[1]);
      return 0;
    }
    function unpack25519(o, n) {
      var i2;
      for (i2 = 0; i2 < 16; ++i2) {
        o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function pow2523(o, i2) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i2[a];
      }
      for (a = 250; a >= 0; --a) {
        S(c, c);
        if (a !== 1) {
          M(c, c, i2);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function neq25519(a, b) {
      var c = new NativeBuffer(32);
      var d = new NativeBuffer(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function vn(x, xi, y, yi, n) {
      var i2, d = 0;
      for (i2 = 0; i2 < n; ++i2) {
        d |= x[xi + i2] ^ y[yi + i2];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function par25519(a) {
      var d = new NativeBuffer(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function scalarmult(p, q, s) {
      var b, i2;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p, q, b);
        add2(q, p);
        add2(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X2);
      set25519(q[1], Y2);
      set25519(q[2], gf1);
      M(q[3], X2, Y2);
      scalarmult(p, q, s);
    }
    function set25519(r, a) {
      var i2;
      for (i2 = 0; i2 < 16; i2++) {
        r[i2] = a[i2] | 0;
      }
    }
    function inv25519(o, i2) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i2[a];
      }
      for (a = 253; a >= 0; --a) {
        S(c, c);
        if (a !== 2 && a !== 4) {
          M(c, c, i2);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function car25519(o) {
      var i2, v, c = 1;
      for (i2 = 0; i2 < 16; ++i2) {
        v = o[i2] + c + 65535;
        c = Math.floor(v / 65536);
        o[i2] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i2 = 0; i2 < 16; ++i2) {
        t = c & (p[i2] ^ q[i2]);
        p[i2] ^= t;
        q[i2] ^= t;
      }
    }
    function gf(init) {
      var i2, r = new Float64Array(16);
      if (init) {
        for (i2 = 0; i2 < init.length; ++i2) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    function A(o, a, b) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o[i2] = a[i2] + b[i2];
      }
    }
    function Z(o, a, b) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o[i2] = a[i2] - b[i2];
      }
    }
    function S(o, a) {
      M(o, a, a);
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
  }
});

// node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "node_modules/node-forge/lib/kem.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    require_random();
    require_jsbn();
    module2.exports = forge2.kem = forge2.kem || {};
    var BigInteger = forge2.jsbn.BigInteger;
    forge2.kem.rsa = {};
    forge2.kem.rsa.create = function(kdf2, options) {
      options = options || {};
      var prng = options.prng || forge2.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r;
        do {
          r = new BigInteger(
            forge2.util.bytesToHex(prng.getBytesSync(byteLength)),
            16
          ).mod(publicKey.n);
        } while (r.compareTo(BigInteger.ONE) <= 0);
        r = forge2.util.hexToBytes(r.toString(16));
        var zeros = byteLength - r.length;
        if (zeros > 0) {
          r = forge2.util.fillString(String.fromCharCode(0), zeros) + r;
        }
        var encapsulation = publicKey.encrypt(r, "NONE");
        var key = kdf2.generate(r, keyLength);
        return { encapsulation, key };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r = privateKey.decrypt(encapsulation, "NONE");
        return kdf2.generate(r, keyLength);
      };
      return kem;
    };
    forge2.kem.kdf1 = function(md2, digestLength) {
      _createKDF(this, md2, 0, digestLength || md2.digestLength);
    };
    forge2.kem.kdf2 = function(md2, digestLength) {
      _createKDF(this, md2, 1, digestLength || md2.digestLength);
    };
    function _createKDF(kdf2, md2, counterStart, digestLength) {
      kdf2.generate = function(x, length3) {
        var key = new forge2.util.ByteBuffer();
        var k = Math.ceil(length3 / digestLength) + counterStart;
        var c = new forge2.util.ByteBuffer();
        for (var i2 = counterStart; i2 < k; ++i2) {
          c.putInt32(i2);
          md2.start();
          md2.update(x + c.getBytes());
          var hash3 = md2.digest();
          key.putBytes(hash3.getBytes(digestLength));
        }
        key.truncate(key.length() - length3);
        return key.getBytes();
      };
    }
  }
});

// node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "node_modules/node-forge/lib/log.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_util();
    module2.exports = forge2.log = forge2.log || {};
    forge2.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge2.log.LEVEL_LOCKED = 1 << 1;
    forge2.log.NO_LEVEL_CHECK = 1 << 2;
    forge2.log.INTERPOLATE = 1 << 3;
    for (i2 = 0; i2 < forge2.log.levels.length; ++i2) {
      level = forge2.log.levels[i2];
      sLevelInfo[level] = {
        index: i2,
        name: level.toUpperCase()
      };
    }
    var level;
    var i2;
    forge2.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i3 = 0; i3 < sLoggers.length; ++i3) {
        var logger2 = sLoggers[i3];
        if (logger2.flags & forge2.log.NO_LEVEL_CHECK) {
          logger2.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger2.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger2.f(logger2, message);
          }
        }
      }
    };
    forge2.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
        " [" + message.category + "] " + message.message;
      }
    };
    forge2.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge2.util.format.apply(this, args);
      }
    };
    forge2.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge2.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i2 = 0; i2 < levels.length; ++i2) {
        (function(level2) {
          forge2.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge2.log.logMessage(msg);
          };
        })(levels[i2]);
      }
    }
    var levels;
    var i2;
    forge2.log.makeLogger = function(logFunction) {
      var logger2 = {
        flags: 0,
        f: logFunction
      };
      forge2.log.setLevel(logger2, "none");
      return logger2;
    };
    forge2.log.setLevel = function(logger2, level2) {
      var rval = false;
      if (logger2 && !(logger2.flags & forge2.log.LEVEL_LOCKED)) {
        for (var i3 = 0; i3 < forge2.log.levels.length; ++i3) {
          var aValidLevel = forge2.log.levels[i3];
          if (level2 == aValidLevel) {
            logger2.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge2.log.lock = function(logger2, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger2.flags |= forge2.log.LEVEL_LOCKED;
      } else {
        logger2.flags &= ~forge2.log.LEVEL_LOCKED;
      }
    };
    forge2.log.addLogger = function(logger2) {
      sLoggers.push(logger2);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f = function(logger2, message) {
          forge2.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger = forge2.log.makeLogger(f);
      } else {
        f = function(logger2, message) {
          forge2.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge2.log.makeLogger(f);
      }
      forge2.log.setLevel(logger, "debug");
      forge2.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger;
    var levelHandlers;
    var f;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge2.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge2.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge2.log.consoleLogger = sConsoleLogger;
  }
});

// node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "node_modules/node-forge/lib/md.all.js"(exports2, module2) {
    "use strict";
    module2.exports = require_md();
    require_md5();
    require_sha12();
    require_sha2562();
    require_sha5122();
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var p7 = module2.exports = forge2.pkcs7 = forge2.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge2.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge2.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge2.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge2.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i2 = 0; i2 < certs.length; ++i2) {
              msg.certificates.push(forge2.pki.certificateFromAsn1(certs[i2]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
            certs.push(forge2.pki.certificateToAsn1(msg.certificates[i2]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge2.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge2.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge2.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge2.pki.oids.sha1:
            case forge2.pki.oids.sha256:
            case forge2.pki.oids.sha384:
            case forge2.pki.oids.sha512:
            case forge2.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
              var attr = authenticatedAttributes[i2];
              if (!contentType && attr.type === forge2.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge2.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge2.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge2.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge2.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge2.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge2.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge2.md[forge2.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge2.md[forge2.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes6 = asn1.toDer(content);
        bytes6.getByte();
        asn1.getBerValueLength(bytes6);
        bytes6 = bytes6.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes6);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge2.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge2.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge2.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes6 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes6);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge2.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge2.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var r = msg.recipients[i2];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match2 = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match2 = false;
                break;
              }
            }
            if (match2) {
              return r;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge2.pki.oids.rsaEncryption:
              case forge2.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge2.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge2.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge2.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge2.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge2.util.createBuffer(forge2.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge2.util.createBuffer(
              forge2.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var recipient = msg.recipients[i2];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge2.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge2.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge2.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i2 = 0; i2 < infos.length; ++i2) {
        ret.push(_recipientFromAsn1(infos[i2]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i2 = 0; i2 < recipients.length; ++i2) {
        ret.push(_recipientToAsn1(recipients[i2]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
          var attr = obj.unauthenticatedAttributes[i2];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i2 = 0; i2 < signers.length; ++i2) {
        ret.push(_signerToAsn1(signers[i2]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge2.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge2.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge2.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge2.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge2.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge2.util.isArray(capture.encryptedContent)) {
          for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
            if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i2].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge2.util.createBuffer(capture.encParameter.value),
          content: forge2.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge2.util.isArray(capture.content)) {
          for (var i2 = 0; i2 < capture.content.length; ++i2) {
            if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i2].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge2.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge2.pki.oids["aes128-CBC"]:
          case forge2.pki.oids["aes192-CBC"]:
          case forge2.pki.oids["aes256-CBC"]:
            ciph = forge2.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge2.pki.oids["desCBC"]:
          case forge2.pki.oids["des-EDE3-CBC"]:
            ciph = forge2.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/node-forge/lib/ssh.js"(exports2, module2) {
    "use strict";
    var forge2 = require_forge();
    require_aes();
    require_hmac();
    require_md5();
    require_sha12();
    require_util();
    var ssh = module2.exports = forge2.ssh = forge2.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge2.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge2.util.encode64(pubbuffer.bytes(), 64);
      var length3 = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length3 + "\r\n";
      ppk += pub;
      var privbuffer = forge2.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge2.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding2 = _sha1(privbuffer.bytes());
        padding2.truncate(padding2.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding2);
        var aeskey = forge2.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge2.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge2.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge2.util.encode64(encrypted.bytes(), 64);
      }
      length3 = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length3 + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge2.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac4 = forge2.hmac.create();
      hmac4.start("sha1", mackey);
      hmac4.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac4.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type = "ssh-rsa";
      comment = comment || "";
      var buffer2 = forge2.util.createBuffer();
      _addStringToBuffer(buffer2, type);
      _addBigIntegerToBuffer(buffer2, key.e);
      _addBigIntegerToBuffer(buffer2, key.n);
      return type + " " + forge2.util.encode64(buffer2.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge2.pki.privateKeyToPem(privateKey);
      }
      return forge2.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md2 = options.md || forge2.md.md5.create();
      var type = "ssh-rsa";
      var buffer2 = forge2.util.createBuffer();
      _addStringToBuffer(buffer2, type);
      _addBigIntegerToBuffer(buffer2, key.e);
      _addBigIntegerToBuffer(buffer2, key.n);
      md2.start();
      md2.update(buffer2.getBytes());
      var digest3 = md2.digest();
      if (options.encoding === "hex") {
        var hex2 = digest3.toHex();
        if (options.delimiter) {
          return hex2.match(/.{2}/g).join(options.delimiter);
        }
        return hex2;
      } else if (options.encoding === "binary") {
        return digest3.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest3;
    };
    function _addBigIntegerToBuffer(buffer2, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes6 = forge2.util.hexToBytes(hexVal);
      buffer2.putInt32(bytes6.length);
      buffer2.putBytes(bytes6);
    }
    function _addStringToBuffer(buffer2, val) {
      buffer2.putInt32(val.length);
      buffer2.putString(val);
    }
    function _sha1() {
      var sha = forge2.md.sha1.create();
      var num = arguments.length;
      for (var i2 = 0; i2 < num; ++i2) {
        sha.update(arguments[i2]);
      }
      return sha.digest();
    }
  }
});

// node_modules/node-forge/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-forge/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls();
    require_util();
  }
});

// src/platform/browser.ts
var forge, BufferPolyfill, Buffer2, browserCrypto;
var init_browser = __esm({
  "src/platform/browser.ts"() {
    "use strict";
    forge = __toESM(require_lib(), 1);
    try {
      if (typeof global !== "undefined" && global.Buffer) {
        BufferPolyfill = global.Buffer;
      } else if (typeof window !== "undefined" && window.Buffer) {
        BufferPolyfill = window.Buffer;
      } else {
        const bufferModule = require("buffer");
        BufferPolyfill = bufferModule.Buffer;
      }
    } catch (e) {
      console.warn("Buffer not available, using fallback implementation");
      BufferPolyfill = class MinimalBuffer {
        static from(data) {
          return data;
        }
        static isBuffer() {
          return false;
        }
      };
    }
    Buffer2 = BufferPolyfill;
    browserCrypto = {
      // Minimal implementation of crypto.verify
      verify: (_algorithm, data, publicKey, signature) => {
        try {
          const publicKeyObj = forge.pki.publicKeyFromPem(publicKey);
          const md2 = forge.md.sha256.create();
          md2.update(data.toString("binary"));
          return publicKeyObj.verify(md2.digest().bytes(), signature.toString("binary"));
        } catch (e) {
          console.error("Verification error:", e);
          return false;
        }
      },
      // Minimal implementation of crypto.createSign
      createSign: (_algorithm) => {
        let data = Buffer2.from("");
        const signer = {
          update: function(chunk) {
            const chunkBuffer = typeof chunk === "string" ? Buffer2.from(chunk) : chunk instanceof Buffer2 ? chunk : Buffer2.from(chunk.toString(), "binary");
            data = Buffer2.concat([data, chunkBuffer]);
            return signer;
          },
          sign: function(key) {
            try {
              const privateKey = forge.pki.privateKeyFromPem(key);
              const md2 = forge.md.sha256.create();
              md2.update(data.toString("binary"));
              const signature = privateKey.sign(md2);
              return Buffer2.from(signature, "binary");
            } catch (e) {
              console.error("Signing error:", e);
              throw new Error("Failed to sign data");
            }
          }
        };
        return signer;
      },
      // Minimal implementation of crypto.createVerify
      createVerify: (_algorithm) => {
        let data = Buffer2.from("");
        const verifier = {
          update: function(chunk) {
            const chunkBuffer = typeof chunk === "string" ? Buffer2.from(chunk) : chunk instanceof Buffer2 ? chunk : Buffer2.from(chunk.toString(), "binary");
            data = Buffer2.concat([data, chunkBuffer]);
            return verifier;
          },
          verify: function(key, signature) {
            try {
              const publicKey = forge.pki.publicKeyFromPem(key);
              const md2 = forge.md.sha256.create();
              md2.update(data.toString("binary"));
              const sig = typeof signature === "string" ? Buffer2.from(signature, "base64") : signature instanceof Buffer2 ? signature : Buffer2.from(signature.toString(), "binary");
              return publicKey.verify(md2.digest().bytes(), sig.toString("binary"));
            } catch (e) {
              console.error("Verification error:", e);
              return false;
            }
          }
        };
        return verifier;
      }
    };
  }
});

// src/platform/crypto.ts
async function getCrypto() {
  if (isNode) {
    try {
      const nodeCrypto = await (async () => {
        try {
          return await import("crypto");
        } catch (e) {
          throw new Error("Node.js crypto module not available");
        }
      })();
      return {
        verify: nodeCrypto.verify,
        createSign: nodeCrypto.createSign,
        createVerify: nodeCrypto.createVerify
      };
    } catch (error) {
      console.error("Failed to import Node.js crypto module:", error);
      return await getBrowserCrypto();
    }
  } else if (isReactNative) {
    try {
      const forge2 = require_lib();
      return {
        verify: (_algorithm, data, publicKey, signature) => {
          try {
            const publicKeyObj = forge2.pki.publicKeyFromPem(publicKey);
            const md2 = forge2.md.sha256.create();
            md2.update(data.toString("binary"));
            return publicKeyObj.verify(md2.digest().bytes(), signature.toString("binary"));
          } catch (e) {
            console.error("Verification error:", e);
            return false;
          }
        },
        createSign: (_algorithm) => {
          let data = Buffer.from("");
          return {
            update: (chunk) => {
              const chunkBuffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
              data = Buffer.concat([data, chunkBuffer]);
              return this;
            },
            sign: (key) => {
              try {
                const privateKey = forge2.pki.privateKeyFromPem(key);
                const md2 = forge2.md.sha256.create();
                md2.update(data.toString("binary"));
                const signature = privateKey.sign(md2);
                return Buffer.from(signature, "binary");
              } catch (e) {
                console.error("Signing error:", e);
                throw new Error("Failed to sign data");
              }
            }
          };
        },
        createVerify: (_algorithm) => {
          let data = Buffer.from("");
          return {
            update: (chunk) => {
              const chunkBuffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
              data = Buffer.concat([data, chunkBuffer]);
              return this;
            },
            verify: (key, signature) => {
              try {
                const publicKey = forge2.pki.publicKeyFromPem(key);
                const md2 = forge2.md.sha256.create();
                md2.update(data.toString("binary"));
                const sig = typeof signature === "string" ? Buffer.from(signature, "base64") : signature;
                return publicKey.verify(md2.digest().bytes(), sig.toString("binary"));
              } catch (e) {
                console.error("Verification error:", e);
                return false;
              }
            }
          };
        }
      };
    } catch (error) {
      console.error("Failed to create React Native compatible crypto implementation:", error);
      throw new Error("Crypto functionality not available in this React Native environment");
    }
  } else if (isBrowser) {
    return await getBrowserCrypto();
  } else {
    console.warn("Unknown environment detected, using browser crypto implementation");
    return await getBrowserCrypto();
  }
}
async function getBrowserCrypto() {
  try {
    return browserCrypto;
  } catch (error) {
    console.error("Failed to create browser compatible crypto implementation:", error);
    throw new Error("Crypto functionality not available in this browser environment");
  }
}
async function getForge() {
  try {
    return await Promise.resolve().then(() => __toESM(require_lib(), 1));
  } catch (error) {
    console.error("Failed to import node-forge:", error);
    throw new Error("Forge functionality not available");
  }
}
var init_crypto = __esm({
  "src/platform/crypto.ts"() {
    "use strict";
    init_platform();
    init_browser();
  }
});

// src/platform/index.ts
var platform_exports = {};
__export(platform_exports, {
  checkInternetConnectivity: () => checkInternetConnectivity,
  createHttpServer: () => createHttpServer,
  getCrypto: () => getCrypto,
  getFileSystem: () => getFileSystem,
  getForge: () => getForge,
  isBrowser: () => isBrowser,
  isNode: () => isNode,
  isReactNative: () => isReactNative
});
async function createHttpServer(requestListener) {
  if (isNode) {
    try {
      const { createServer } = await import("http");
      return createServer(requestListener);
    } catch (error) {
      console.error("Failed to create HTTP server:", error);
      return null;
    }
  } else if (isReactNative) {
    console.warn("HTTP server is not supported in React Native. Consider using a different approach.");
    return {
      listen: (port2, host2, callback) => {
        console.warn(`[Mock] HTTP server would listen on ${host2}:${port2}`);
        if (callback) callback();
      },
      close: () => {
        console.warn("[Mock] HTTP server would close");
      }
    };
  } else {
    console.warn("HTTP server is only supported in Node.js environment");
    return null;
  }
}
async function checkInternetConnectivity() {
  if (isBrowser || isReactNative) {
    return new Promise((resolve) => {
      const isOnline = typeof navigator !== "undefined" && navigator.onLine;
      if (!isOnline) {
        resolve(false);
        return;
      }
      fetch("https://www.google.com/favicon.ico", {
        mode: "no-cors",
        cache: "no-store"
      }).then(() => resolve(true)).catch(() => resolve(false));
      setTimeout(() => resolve(false), 5e3);
    });
  } else if (isNode) {
    try {
      const { request } = await import("https");
      return new Promise((resolve) => {
        const req = request(
          "https://www.google.com",
          { method: "HEAD", timeout: 5e3 },
          (res) => {
            resolve(res.statusCode >= 200 && res.statusCode < 300);
            res.resume();
          }
        );
        req.on("error", () => resolve(false));
        req.on("timeout", () => {
          req.destroy();
          resolve(false);
        });
        req.end();
      });
    } catch (error) {
      return false;
    }
  }
  return false;
}
var isReactNative, isNode, isBrowser;
var init_platform = __esm({
  "src/platform/index.ts"() {
    "use strict";
    init_fs();
    init_crypto();
    isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
    isBrowser = typeof window !== "undefined" && !isReactNative;
  }
});

// node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@multiformats/base-x/src/index.js"(exports2, module2) {
    "use strict";
    function base4(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i2 = 0; i2 < ALPHABET.length; i2++) {
        var x = ALPHABET.charAt(i2);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i2;
      }
      var BASE2 = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE2) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE2);
      function encode13(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length3 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size2);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i3 = 0;
          for (var it1 = size2 - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE2 >>> 0;
            carry = carry / BASE2 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length3 = i3;
          pbegin++;
        }
        var it2 = size2 - length3;
        while (it2 !== size2 && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size2; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length3 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size2);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i3 = 0;
          for (var it3 = size2 - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
            carry += BASE2 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length3 = i3;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size2 - length3;
        while (it4 !== size2 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size2 - it4));
        var j2 = zeroes;
        while (it4 !== size2) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode17(string4) {
        var buffer2 = decodeUnsafe(string4);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE2 + " character");
      }
      return {
        encode: encode13,
        decodeUnsafe,
        decode: decode17
      };
    }
    module2.exports = base4;
  }
});

// node_modules/multibase/src/util.js
var require_util2 = __commonJS({
  "node_modules/multibase/src/util.js"(exports2, module2) {
    "use strict";
    var textDecoder4 = new TextDecoder();
    var decodeText = (bytes6) => textDecoder4.decode(bytes6);
    var textEncoder4 = new TextEncoder();
    var encodeText = (text) => textEncoder4.encode(text);
    function concat4(arrs, length3) {
      const output6 = new Uint8Array(length3);
      let offset = 0;
      for (const arr of arrs) {
        output6.set(arr, offset);
        offset += arr.length;
      }
      return output6;
    }
    module2.exports = { decodeText, encodeText, concat: concat4 };
  }
});

// node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/multibase/src/base.js"(exports2, module2) {
    "use strict";
    var { encodeText } = require_util2();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name4, code4, factory, alphabet5) {
        this.name = name4;
        this.code = code4;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet5;
        this.codec = factory(alphabet5);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf2) {
        return this.codec.encode(buf2);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string4) {
        for (const char of string4) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string4}'`);
          }
        }
        return this.codec.decode(string4);
      }
    };
    module2.exports = Base;
  }
});

// node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/multibase/src/rfc4648.js"(exports2, module2) {
    "use strict";
    var decode17 = (string4, alphabet5, bitsPerChar) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet5.length; ++i2) {
        codes[alphabet5[i2]] = i2;
      }
      let end = string4.length;
      while (string4[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string4[i2]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string4[i2]);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode13 = (data, alphabet5, bitsPerChar) => {
      const pad4 = alphabet5[alphabet5.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer2 = buffer2 << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet5[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet5[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad4) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46483 = (bitsPerChar) => (alphabet5) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode13(input, alphabet5, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode17(input, alphabet5, bitsPerChar);
        }
      };
    };
    module2.exports = { rfc4648: rfc46483 };
  }
});

// node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "node_modules/multibase/src/constants.js"(exports2, module2) {
    "use strict";
    var baseX3 = require_src();
    var Base = require_base();
    var { rfc4648: rfc46483 } = require_rfc4648();
    var { decodeText, encodeText } = require_util2();
    var identity6 = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity6, ""],
      ["base2", "0", rfc46483(1), "01"],
      ["base8", "7", rfc46483(3), "01234567"],
      ["base10", "9", baseX3, "0123456789"],
      ["base16", "f", rfc46483(4), "0123456789abcdef"],
      ["base16upper", "F", rfc46483(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc46483(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc46483(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc46483(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc46483(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc46483(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc46483(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc46483(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc46483(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc46483(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX3, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX3, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX3, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX3, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc46483(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc46483(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc46483(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc46483(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module2.exports = {
      names,
      codes
    };
  }
});

// node_modules/multibase/src/index.js
var require_src2 = __commonJS({
  "node_modules/multibase/src/index.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat: concat4 } = require_util2();
    function multibase(nameOrCode, buf2) {
      if (!buf2) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name: name4, codeBuf } = encoding(nameOrCode);
      validEncode(name4, buf2);
      return concat4([codeBuf, buf2], codeBuf.length + buf2.length);
    }
    function encode13(nameOrCode, buf2) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf2));
      return concat4([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode17(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name4, buf2) {
      const enc = encoding(name4);
      enc.decode(decodeText(buf2));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports2 = module2.exports = multibase;
    exports2.encode = encode13;
    exports2.decode = decode17;
    exports2.isEncoded = isEncoded;
    exports2.encoding = encoding;
    exports2.encodingFromData = encodingFromData;
    var names = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports2.names = names;
    exports2.codes = codes;
  }
});

// node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
  "node_modules/canonicalize/lib/canonicalize.js"(exports2, module2) {
    "use strict";
    module2.exports = function serialize(object2) {
      if (typeof object2 === "number" && isNaN(object2)) {
        throw new Error("NaN is not allowed");
      }
      if (typeof object2 === "number" && !isFinite(object2)) {
        throw new Error("Infinity is not allowed");
      }
      if (object2 === null || typeof object2 !== "object") {
        return JSON.stringify(object2);
      }
      if (object2.toJSON instanceof Function) {
        return serialize(object2.toJSON());
      }
      if (Array.isArray(object2)) {
        const values2 = object2.reduce((t, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return `${t}${comma}${serialize(value)}`;
        }, "");
        return `[${values2}]`;
      }
      const values = Object.keys(object2).sort().reduce((t, cv) => {
        if (object2[cv] === void 0 || typeof object2[cv] === "symbol") {
          return t;
        }
        const comma = t.length === 0 ? "" : ",";
        return `${t}${comma}${serialize(cv)}:${serialize(object2[cv])}`;
      }, "");
      return `{${values}}`;
    };
  }
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex = __esm({
  "node_modules/viem/_esm/utils/data/isHex.js"() {
    "use strict";
  }
});

// node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = __esm({
  "node_modules/viem/_esm/utils/data/size.js"() {
    "use strict";
    init_isHex();
  }
});

// node_modules/viem/_esm/errors/version.js
var version2;
var init_version = __esm({
  "node_modules/viem/_esm/errors/version.js"() {
    "use strict";
    version2 = "1.21.3";
  }
});

// node_modules/viem/_esm/errors/utils.js
var getVersion;
var init_utils = __esm({
  "node_modules/viem/_esm/errors/utils.js"() {
    "use strict";
    init_version();
    getVersion = () => `viem@${version2}`;
  }
});

// node_modules/viem/_esm/errors/base.js
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}
var BaseError;
var init_base = __esm({
  "node_modules/viem/_esm/errors/base.js"() {
    "use strict";
    init_utils();
    BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: getVersion()
        });
        const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [
            `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk(this, fn);
      }
    };
  }
});

// node_modules/viem/_esm/errors/data.js
var SizeExceedsPaddingSizeError;
var init_data = __esm({
  "node_modules/viem/_esm/errors/data.js"() {
    "use strict";
    init_base();
    SizeExceedsPaddingSizeError = class extends BaseError {
      constructor({ size: size2, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/pad.js
function pad2(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex2 = hex_.replace("0x", "");
  if (hex2.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex2.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes6, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes6;
  if (bytes6.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes6.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i2 = 0; i2 < size2; i2++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i2 : size2 - i2 - 1] = bytes6[padEnd ? i2 : bytes6.length - i2 - 1];
  }
  return paddedBytes;
}
var init_pad = __esm({
  "node_modules/viem/_esm/utils/data/pad.js"() {
    "use strict";
    init_data();
  }
});

// node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, SizeOverflowError;
var init_encoding = __esm({
  "node_modules/viem/_esm/errors/encoding.js"() {
    "use strict";
    init_base();
    IntegerOutOfRangeError = class extends BaseError {
      constructor({ max, min, signed, size: size2, value }) {
        super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    SizeOverflowError = class extends BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
var init_fromHex = __esm({
  "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
    "use strict";
    init_encoding();
    init_size();
  }
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex3(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex2 = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad2(hex2, { size: opts.size });
  }
  return hex2;
}
function bytesToHex3(value, opts = {}) {
  let string4 = "";
  for (let i2 = 0; i2 < value.length; i2++) {
    string4 += hexes2[value[i2]];
  }
  const hex2 = `0x${string4}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad2(hex2, { dir: "right", size: opts.size });
  }
  return hex2;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex2 = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad2(hex2, { size: size2 });
  return hex2;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex3(value, opts);
}
var hexes2, encoder;
var init_toHex = __esm({
  "node_modules/viem/_esm/utils/encoding/toHex.js"() {
    "use strict";
    init_encoding();
    init_pad();
    init_fromHex();
    hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
    encoder = /* @__PURE__ */ new TextEncoder();
  }
});

// node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes3(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes3(value, opts);
  return stringToBytes2(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes6 = new Uint8Array(1);
  bytes6[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes6, { size: opts.size });
    return pad2(bytes6, { size: opts.size });
  }
  return bytes6;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes3(hex_, opts = {}) {
  let hex2 = hex_;
  if (opts.size) {
    assertSize(hex2, { size: opts.size });
    hex2 = pad2(hex2, { dir: "right", size: opts.size });
  }
  let hexString = hex2.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length3 = hexString.length / 2;
  const bytes6 = new Uint8Array(length3);
  for (let index = 0, j = 0; index < length3; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes6[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes6;
}
function numberToBytes(value, opts) {
  const hex2 = numberToHex(value, opts);
  return hexToBytes3(hex2);
}
function stringToBytes2(value, opts = {}) {
  const bytes6 = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes6, { size: opts.size });
    return pad2(bytes6, { dir: "right", size: opts.size });
  }
  return bytes6;
}
var encoder2, charCodeMap;
var init_toBytes = __esm({
  "node_modules/viem/_esm/utils/encoding/toBytes.js"() {
    "use strict";
    init_base();
    init_isHex();
    init_pad();
    init_fromHex();
    init_toHex();
    encoder2 = /* @__PURE__ */ new TextEncoder();
    charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/_assert.js
function number3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var init_assert = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/_assert.js"() {
    "use strict";
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
function fromBig2(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
  return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
}
function split2(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h, l } = fromBig2(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK642, _32n2, rotlSH2, rotlSL2, rotlBH2, rotlBL2;
var init_u64 = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/_u64.js"() {
    "use strict";
    U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n2 = /* @__PURE__ */ BigInt(32);
    rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
    rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
    rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
    rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes4(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  if (!u8a2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var u8a2, u323, isLE3, Hash2, toStr;
var init_utils2 = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/utils.js"() {
    "use strict";
    u8a2 = (a) => a instanceof Uint8Array;
    u323 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    isLE3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE3)
      throw new Error("Non little-endian hardware is not supported");
    Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    toStr = {}.toString;
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
function keccakP2(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL2[t];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI = SHA3_PI2[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H2[round];
    s[1] ^= SHA3_IOTA_L2[round];
  }
  B.fill(0);
}
var SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2, _0n10, _1n10, _2n8, _7n2, _256n2, _0x71n2, SHA3_IOTA_H2, SHA3_IOTA_L2, rotlH2, rotlL2, Keccak2, gen2, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_2562, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/sha3.js"() {
    "use strict";
    init_assert();
    init_u64();
    init_utils2();
    [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
    _0n10 = /* @__PURE__ */ BigInt(0);
    _1n10 = /* @__PURE__ */ BigInt(1);
    _2n8 = /* @__PURE__ */ BigInt(2);
    _7n2 = /* @__PURE__ */ BigInt(7);
    _256n2 = /* @__PURE__ */ BigInt(256);
    _0x71n2 = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R = _1n10, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI2.push(2 * (5 * y + x));
      SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n10;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n10 ^ (R >> _7n2) * _0x71n2) % _256n2;
        if (R & _2n8)
          t ^= _1n10 << (_1n10 << /* @__PURE__ */ BigInt(j)) - _1n10;
      }
      _SHA3_IOTA2.push(t);
    }
    [SHA3_IOTA_H2, SHA3_IOTA_L2] = /* @__PURE__ */ split2(_SHA3_IOTA2, true);
    rotlH2 = (h, l, s) => s > 32 ? rotlBH2(h, l, s) : rotlSH2(h, l, s);
    rotlL2 = (h, l, s) => s > 32 ? rotlBL2(h, l, s) : rotlSL2(h, l, s);
    Keccak2 = class _Keccak extends Hash2 {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        number3(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u323(this.state);
      }
      keccak() {
        keccakP2(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        exists2(this);
        const { blockLen, state } = this;
        data = toBytes4(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i2 = 0; i2 < take; i2++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        exists2(this, false);
        bytes2(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes6) {
        number3(bytes6);
        return this.xofInto(new Uint8Array(bytes6));
      }
      digestInto(out) {
        output2(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen2 = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak2(blockLen, suffix, outputLen));
    sha3_224 = /* @__PURE__ */ gen2(6, 144, 224 / 8);
    sha3_256 = /* @__PURE__ */ gen2(6, 136, 256 / 8);
    sha3_384 = /* @__PURE__ */ gen2(6, 104, 384 / 8);
    sha3_512 = /* @__PURE__ */ gen2(6, 72, 512 / 8);
    keccak_224 = /* @__PURE__ */ gen2(1, 144, 224 / 8);
    keccak_2562 = /* @__PURE__ */ gen2(1, 136, 256 / 8);
    keccak_384 = /* @__PURE__ */ gen2(1, 104, 384 / 8);
    keccak_512 = /* @__PURE__ */ gen2(1, 72, 512 / 8);
    genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
    shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
  }
});

// node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes6 = keccak_2562(isHex(value, { strict: false }) ? toBytes3(value) : value);
  if (to === "bytes")
    return bytes6;
  return toHex(bytes6);
}
var init_keccak256 = __esm({
  "node_modules/viem/_esm/utils/hash/keccak256.js"() {
    "use strict";
    init_sha3();
    init_isHex();
    init_toBytes();
    init_toHex();
  }
});

// node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash3 = keccak256(stringToBytes2(hexAddress), "bytes");
  const address2 = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hash3[i2 >> 1] >> 4 >= 8 && address2[i2]) {
      address2[i2] = address2[i2].toUpperCase();
    }
    if ((hash3[i2 >> 1] & 15) >= 8 && address2[i2 + 1]) {
      address2[i2 + 1] = address2[i2 + 1].toUpperCase();
    }
  }
  return `0x${address2.join("")}`;
}
var init_getAddress = __esm({
  "node_modules/viem/_esm/utils/address/getAddress.js"() {
    "use strict";
    init_toBytes();
    init_keccak256();
  }
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER: EMPTY_BUFFER3 } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    function concat4(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER3;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf2 = list[i2];
        target.set(buf2, offset);
        offset += buf2.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output6, offset, length3) {
      for (let i2 = 0; i2 < length3; i2++) {
        output6[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer2, mask) {
      for (let i2 = 0; i2 < buffer2.length; i2++) {
        buffer2[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer(buf2) {
      if (buf2.length === buf2.buffer.byteLength) {
        return buf2.buffer;
      }
      return buf2.buffer.slice(buf2.byteOffset, buf2.byteOffset + buf2.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf2;
      if (data instanceof ArrayBuffer) {
        buf2 = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf2 = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf2 = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf2;
    }
    module2.exports = {
      concat: concat4,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output6, offset, length3) {
          if (length3 < 48) _mask(source, mask, output6, offset, length3);
          else bufferUtil.mask(source, mask, output6, offset, length3);
        };
        module2.exports.unmask = function(buffer2, mask) {
          if (buffer2.length < 32) _unmask(buffer2, mask);
          else bufferUtil.unmask(buffer2, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants2();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code4) {
      return code4 >= 1e3 && code4 <= 1014 && code4 !== 1004 && code4 !== 1005 && code4 !== 1006 || code4 >= 3e3 && code4 <= 4999;
    }
    function _isValidUTF8(buf2) {
      const len = buf2.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf2[i2] & 128) === 0) {
          i2++;
        } else if ((buf2[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf2[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2 + 2] & 192) !== 128 || buf2[i2] === 224 && (buf2[i2 + 1] & 224) === 128 || // Overlong
          buf2[i2] === 237 && (buf2[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf2[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2 + 2] & 192) !== 128 || (buf2[i2 + 3] & 192) !== 128 || buf2[i2] === 240 && (buf2[i2 + 1] & 240) === 128 || // Overlong
          buf2[i2] === 244 && buf2[i2 + 1] > 143 || buf2[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf2) {
        return buf2.length < 24 ? _isValidUTF8(buf2) : isUtf8(buf2);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf2) {
          return buf2.length < 32 ? _isValidUTF8(buf2) : isValidUTF8(buf2);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER: EMPTY_BUFFER3,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat: concat4, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf2 = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf2.buffer,
            buf2.byteOffset + n,
            buf2.length - n
          );
          return new FastBuffer(buf2.buffer, buf2.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf2 = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf2.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf2.buffer, buf2.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf2.buffer,
              buf2.byteOffset + n,
              buf2.length - n
            );
          }
          n -= buf2.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf2 = this.consume(2);
        if ((buf2[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf2[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf2[0] & 128) === 128;
        this._opcode = buf2[0] & 15;
        this._payloadLength = buf2[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf2[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf2 = this.consume(8);
        const num = buf2.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf2.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER3;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf2) => {
          if (err) return cb(err);
          if (buf2.length) {
            this._messageLength += buf2.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf2);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat4(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat4(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf2 = concat4(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf2)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf2, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf2, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER3);
            this.end();
          } else {
            const code4 = data.readUInt16BE(0);
            if (!isValidStatusCode(code4)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code4}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf2 = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf2)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code4, buf2);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver2;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER: EMPTY_BUFFER3, kWebSocket, NOOP } = require_constants2();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code4, data, mask, cb) {
        let buf2;
        if (code4 === void 0) {
          buf2 = EMPTY_BUFFER3;
        } else if (typeof code4 !== "number" || !isValidStatusCode(code4)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf2 = Buffer.allocUnsafe(2);
          buf2.writeUInt16BE(code4, 0);
        } else {
          const length3 = Buffer.byteLength(data);
          if (length3 > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf2 = Buffer.allocUnsafe(2 + length3);
          buf2.writeUInt16BE(code4, 0);
          if (typeof data === "string") {
            buf2.write(data, 2);
          } else {
            buf2.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf2.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf2, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf2, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf2) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf2, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i2 = 0; i2 < sender._queue.length; i2++) {
        const params = sender._queue[i2];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code4, message) {
            const event = new CloseEvent("close", {
              code: code4,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event2,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name4, elem) {
      if (dest[name4] === void 0) dest[name4] = [elem];
      else dest[name4].push(elem);
    }
    function parse4(header2) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code4 = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header2.length; i2++) {
        code4 = header2.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code4] === 1) {
            if (start === -1) start = i2;
          } else if (i2 !== 0 && (code4 === 32 || code4 === 9)) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code4 === 59 || code4 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            const name4 = header2.slice(start, end);
            if (code4 === 44) {
              push(offers, name4, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name4;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code4] === 1) {
            if (start === -1) start = i2;
          } else if (code4 === 32 || code4 === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code4 === 59 || code4 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            push(params, header2.slice(start, end), true);
            if (code4 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code4 === 61 && start !== -1 && end === -1) {
            paramName = header2.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code4] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1) start = i2;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code4] === 1) {
              if (start === -1) start = i2;
            } else if (code4 === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code4 === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code4 === 34 && header2.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code4] === 1) {
            if (start === -1) start = i2;
          } else if (start !== -1 && (code4 === 32 || code4 === 9)) {
            if (end === -1) end = i2;
          } else if (code4 === 59 || code4 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            let value = header2.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code4 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code4 === 32 || code4 === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i2;
      const token = header2.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format2(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format: format2, parse: parse4 };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https2 = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes5, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER: EMPTY_BUFFER3,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format: format2, parse: parse4 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket3 = class _WebSocket3 extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address2, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER3;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket3.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address2 !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address2, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket3.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket3.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket3.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code4, data) {
        if (this.readyState === _WebSocket3.CLOSED) return;
        if (this.readyState === _WebSocket3.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket3.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket3.CLOSING;
        this._sender.close(code4, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket3.CONNECTING || this.readyState === _WebSocket3.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket3.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket3.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER3, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket3.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket3.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER3, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket3.CONNECTING || this.readyState === _WebSocket3.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket3.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket3.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER3, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket3.CLOSED) return;
        if (this.readyState === _WebSocket3.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket3.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address2, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address2 instanceof URL2) {
        parsedUrl = address2;
      } else {
        try {
          parsedUrl = new URL2(address2);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address2}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes5(16).toString("base64");
      const request = isSecure ? https2.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format2({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address2);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest3 = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest3) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse4(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream2, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream2.setHeader) {
        stream2[kAborted] = true;
        stream2.abort();
        if (stream2.socket && !stream2.socket.destroyed) {
          stream2.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream2.destroy(err);
        stream2.once("error", websocket.emit.bind(websocket, "error"));
        stream2.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length3 = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length3;
        else websocket._bufferedAmount += length3;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code4, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code4;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code4 === 1005) websocket.close();
      else websocket.close(code4, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream2) {
      stream2.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket3.CLOSED) return;
      if (websocket.readyState === WebSocket3.OPEN) {
        websocket._readyState = WebSocket3.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var WebSocket3 = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream2) {
      stream2.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse4(header2) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header2.length; i2++) {
        const code4 = header2.charCodeAt(i2);
        if (end === -1 && tokenChars[code4] === 1) {
          if (start === -1) start = i2;
        } else if (i2 !== 0 && (code4 === 32 || code4 === 9)) {
          if (end === -1 && start !== -1) end = i2;
        } else if (code4 === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1) end = i2;
          const protocol2 = header2.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header2.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse4 };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http2 = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version3 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version3 !== 13 && version3 !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8"
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code4, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code4 || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest3 = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest3}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map2) {
      for (const event of Object.keys(map2)) server.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code4, message, headers) {
      message = message || http2.STATUS_CODES[code4];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code4} ${http2.STATUS_CODES[code4]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code4, message, headers) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code4, message, headers);
      }
    }
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto2 && browserCrypto2.getRandomValues !== void 0) {
          this._crypto = browserCrypto2;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length3) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length3);
        for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
        }
        return out;
      }
    };
    exports2.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function wipe(array) {
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = 0;
      }
      return array;
    }
    exports2.wipe = wipe;
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof require !== "undefined") {
          const nodeCrypto = require("crypto");
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length3) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer2 = this._crypto.randomBytes(length3);
        if (buffer2.length !== length3) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length3);
        for (let i2 = 0; i2 < out.length; i2++) {
          out[i2] = buffer2[i2];
        }
        (0, wipe_1.wipe)(buffer2);
        return out;
      }
    };
    exports2.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length3) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length3);
      }
    };
    exports2.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports2.mul = Math.imul || imulShim;
    function add2(a, b) {
      return a + b | 0;
    }
    exports2.add = add2;
    function sub(a, b) {
      return a - b | 0;
    }
    exports2.sub = sub;
    function rotl4(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports2.rotl = rotl4;
    function rotr4(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports2.rotr = rotr4;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports2.isInteger = Number.isInteger || isIntegerShim;
    exports2.MAX_SAFE_INTEGER = 9007199254740991;
    exports2.isSafeInteger = function(n) {
      return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports2.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports2.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports2.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports2.writeUint16BE = writeUint16BE;
    exports2.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports2.writeUint16LE = writeUint16LE;
    exports2.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports2.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports2.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports2.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint32LE = readUint32LE;
    function writeUint32BE2(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports2.writeUint32BE = writeUint32BE2;
    exports2.writeInt32BE = writeUint32BE2;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports2.writeUint32LE = writeUint32LE;
    exports2.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE2(value / 4294967296 >>> 0, out, offset);
      writeUint32BE2(value >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64BE = writeUint64BE;
    exports2.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64LE = writeUint64LE;
    exports2.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul3 = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        result += array[i2] * mul3;
        mul3 *= 256;
      }
      return result;
    }
    exports2.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul3 = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        result += array[i2] * mul3;
        mul3 *= 256;
      }
      return result;
    }
    exports2.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports2.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports2.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports2.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports2.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports2.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports2.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports2.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports2.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random2 = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomStringForEntropy = exports2.randomString = exports2.randomUint32 = exports2.randomBytes = exports2.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports2.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes5(length3, prng = exports2.defaultRandomSource) {
      return prng.randomBytes(length3);
    }
    exports2.randomBytes = randomBytes5;
    function randomUint32(prng = exports2.defaultRandomSource) {
      const buf2 = randomBytes5(4, prng);
      const result = (0, binary_1.readUint32LE)(buf2);
      (0, wipe_1.wipe)(buf2);
      return result;
    }
    exports2.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString2(length3, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length3 > 0) {
        const buf2 = randomBytes5(Math.ceil(length3 * 256 / maxByte), prng);
        for (let i2 = 0; i2 < buf2.length && length3 > 0; i2++) {
          const randomByte = buf2[i2];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length3--;
          }
        }
        (0, wipe_1.wipe)(buf2);
      }
      return out;
    }
    exports2.randomString = randomString2;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      const length3 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString2(length3, charset, prng);
    }
    exports2.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify3(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i2, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i2 = 0; i2 < node.length; i2++) {
            if (i2) out += ",";
            out += stringify3(node[i2]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          var value = stringify3(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    "use strict";
    module2.exports = encode13;
    var MSB3 = 128;
    var REST3 = 127;
    var MSBALL3 = ~REST3;
    var INT3 = Math.pow(2, 31);
    function encode13(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode13.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT3) {
        out[offset++] = num & 255 | MSB3;
        num /= 128;
      }
      while (num & MSBALL3) {
        out[offset++] = num & 255 | MSB3;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode13.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    "use strict";
    module2.exports = read3;
    var MSB3 = 128;
    var REST3 = 127;
    function read3(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read3.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST3) << shift : (b & REST3) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB3);
      read3.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    "use strict";
    var N13 = Math.pow(2, 7);
    var N23 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N53 = Math.pow(2, 35);
    var N63 = Math.pow(2, 42);
    var N73 = Math.pow(2, 49);
    var N83 = Math.pow(2, 56);
    var N93 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// src/web.ts
var web_exports = {};
__export(web_exports, {
  Aqua: () => Aqua,
  Aquafier: () => Aquafier,
  AquafierChainable: () => AquafierChainable,
  Err: () => Err,
  ErrResult: () => ErrResult,
  LogType: () => LogType,
  LogTypeEmojis: () => LogTypeEmojis,
  None: () => None,
  NoneOption: () => NoneOption,
  Ok: () => Ok,
  OkResult: () => OkResult,
  OrderRevisionInAquaTree: () => OrderRevisionInAquaTree,
  SignConfigs: () => SignConfigs,
  Some: () => Some,
  SomeOption: () => SomeOption,
  WitnessConfigs: () => WitnessConfigs,
  checkFileHashAlreadyNotarized: () => checkFileHashAlreadyNotarized,
  checkInternetConnection: () => checkInternetConnection,
  cliGreenify: () => cliGreenify,
  cliRedify: () => cliRedify,
  cliYellowfy: () => cliYellowfy,
  createAqua: () => createAqua,
  createCredentials: () => createCredentials,
  createNewAquaTree: () => createNewAquaTree,
  default: () => web_default,
  dict2Leaves: () => dict2Leaves,
  estimateWitnessGas: () => estimateWitnessGas,
  findFormKey: () => findFormKey,
  findNextRevisionHashByArrayofRevisions: () => findNextRevisionHashByArrayofRevisions,
  formatMwTimestamp: () => formatMwTimestamp,
  getAquaTreeFileName: () => getAquaTreeFileName,
  getAquaTreeFileObject: () => getAquaTreeFileObject,
  getChainIdFromNetwork: () => getChainIdFromNetwork,
  getEntropy: () => getEntropy,
  getFileHashSum: () => getFileHashSum,
  getFileNameCheckingPaths: () => getFileNameCheckingPaths,
  getGenesisHash: () => getGenesisHash,
  getHashSum: () => getHashSum,
  getLatestVH: () => getLatestVH,
  getMerkleRoot: () => getMerkleRoot,
  getPreviousVerificationHash: () => getPreviousVerificationHash,
  getTimestamp: () => getTimestamp,
  getWallet: () => getWallet,
  isAquaTree: () => isAquaTree,
  isErr: () => isErr,
  isNone: () => isNone,
  isOk: () => isOk,
  isSome: () => isSome,
  log_dim: () => log_dim,
  log_red: () => log_red,
  log_success: () => log_success,
  log_yellow: () => log_yellow,
  maybeUpdateFileIndex: () => maybeUpdateFileIndex,
  prepareNonce: () => prepareNonce,
  printGraphData: () => printGraphData,
  printLogs: () => printLogs,
  printlinkedGraphData: () => printlinkedGraphData,
  recoverWalletAddress: () => recoverWalletAddress,
  reorderAquaTreeRevisionsProperties: () => reorderAquaTreeRevisionsProperties,
  reorderRevisionsProperties: () => reorderRevisionsProperties,
  verifyMerkleIntegrity: () => verifyMerkleIntegrity
});
module.exports = __toCommonJS(web_exports);
init_node_modules();

// src/types.ts
var LogType = /* @__PURE__ */ ((LogType2) => {
  LogType2["SUCCESS"] = "success";
  LogType2["INFO"] = "info";
  LogType2["ERROR"] = "error";
  LogType2["FINAL_ERROR"] = "final_error";
  LogType2["WARNING"] = "warning";
  LogType2["HINT"] = "hint";
  LogType2["DEBUGDATA"] = "debug_data";
  LogType2["ARROW"] = "arrow";
  LogType2["FILE"] = "file";
  LogType2["LINK"] = "link";
  LogType2["SIGNATURE"] = "signature";
  LogType2["WITNESS"] = "witness";
  LogType2["FORM"] = "form";
  LogType2["SCALAR"] = "scalar";
  LogType2["EMPTY"] = "empty";
  LogType2["TREE"] = "tree";
  return LogType2;
})(LogType || {});
var LogTypeEmojis = {
  ["success" /* SUCCESS */]: "\u2705",
  ["info" /* INFO */]: "\u2728",
  ["error" /* ERROR */]: "\u274C",
  ["final_error" /* FINAL_ERROR */]: "\u274C",
  ["warning" /* WARNING */]: "\u{1F6A8}",
  ["hint" /* HINT */]: "\u{1F4A1}",
  ["debug_data" /* DEBUGDATA */]: "\u{1F41E}",
  ["arrow" /* ARROW */]: "\u27A1\uFE0F",
  ["file" /* FILE */]: "\u{1F4C4}",
  ["link" /* LINK */]: "\u{1F517}",
  ["signature" /* SIGNATURE */]: "\u{1F50F}",
  ["witness" /* WITNESS */]: "\u{1F440}",
  ["form" /* FORM */]: "\u{1F4DD}",
  ["scalar" /* SCALAR */]: "\u23FA\uFE0F ",
  ["tree" /* TREE */]: "\u{1F33F}",
  ["empty" /* EMPTY */]: ""
};

// src/utils.ts
var import_ethers = require("ethers");
var import_sha = __toESM(require_sha2(), 1);
var import_merkletreejs = require("merkletreejs");

// src/type_guards.ts
var OkResult = class {
  constructor(data) {
    this.data = data;
    this.tag = "ok";
  }
  isOk() {
    return true;
  }
  isErr() {
    return false;
  }
  // Utility methods
  map(fn) {
    return Ok(fn(this.data));
  }
  unwrap() {
    return this.data;
  }
  unwrapOr(_default) {
    return this.data;
  }
};
var ErrResult = class {
  constructor(data) {
    this.data = data;
    this.tag = "err";
  }
  isOk() {
    return false;
  }
  isErr() {
    return true;
  }
  // Utility methods
  map(_fn) {
    return Err(this.data);
  }
  unwrap() {
    throw new Error(`Attempted to unwrap an Err value: ${JSON.stringify(this.data)}`);
  }
  unwrapOr(defaultValue) {
    return defaultValue;
  }
};
function Ok(value) {
  return new OkResult(value);
}
function Err(error) {
  return new ErrResult(error);
}
function isOk(result) {
  return result.isOk();
}
function isErr(result) {
  return result.isErr();
}
var SomeOption = class {
  constructor(value) {
    this.value = value;
    this.tag = "some";
  }
  isSome() {
    return true;
  }
  isNone() {
    return false;
  }
  // Utility methods
  map(fn) {
    return Some(fn(this.value));
  }
  unwrap() {
    return this.value;
  }
  unwrapOr(_default) {
    return this.value;
  }
};
var NoneOption = class {
  constructor() {
    this.tag = "none";
  }
  isSome() {
    return false;
  }
  isNone() {
    return true;
  }
  // Utility methods
  map(_fn) {
    return None();
  }
  unwrap() {
    throw new Error("Attempted to unwrap a None value");
  }
  unwrapOr(defaultValue) {
    return defaultValue;
  }
};
function Some(value) {
  return new SomeOption(value);
}
function None() {
  return new NoneOption();
}
function isSome(option2) {
  return option2.isSome();
}
function isNone(option2) {
  return option2.isNone();
}

// src/utils.ts
function isAquaTree(content) {
  return content && typeof content === "object" && "revisions" in content && "file_index" in content;
}
function reorderRevisionsProperties(revision) {
  const reordered = {};
  const sortedKeys = Object.keys(revision).sort();
  for (const key of sortedKeys) {
    reordered[key] = revision[key];
  }
  return reordered;
}
function reorderAquaTreeRevisionsProperties(aquaTree) {
  const reorderedRevisions = {};
  for (const [hash3, revision] of Object.entries(aquaTree.revisions)) {
    reorderedRevisions[hash3] = reorderRevisionsProperties(revision);
  }
  return {
    ...aquaTree,
    revisions: reorderedRevisions
  };
}
function getPreviousVerificationHash(aquaTree, currentHash) {
  let previousHash = "";
  let hashes3 = Object.keys(aquaTree.revisions);
  let index = hashes3.indexOf(currentHash);
  if (index > 0) {
    previousHash = hashes3[index - 1];
  }
  return previousHash;
}
function findFormKey(revision, key) {
  const keys = Object.keys(revision);
  return keys.find(
    (k) => k === key || k === `forms_${key}` || k.startsWith(`forms_${key}`)
  );
}
function maybeUpdateFileIndex(aquaTree, verificationHash, revisionType, aquaFileName, formFileName, linkVerificationHash, linkFileName) {
  let logs = [];
  const validRevisionTypes = ["file", "form", "link"];
  if (!validRevisionTypes.includes(revisionType)) {
    logs.push({
      logType: "error" /* ERROR */,
      log: `\u274C Invalid revision type for file index: ${revisionType}`
    });
    return Err(logs);
  }
  switch (revisionType) {
    case "form":
      aquaTree.file_index[verificationHash] = formFileName;
      break;
    case "file":
      aquaTree.file_index[verificationHash] = aquaFileName;
      break;
    case "link":
      aquaTree.file_index[linkVerificationHash] = linkFileName;
  }
  logs.push({
    logType: "success" /* SUCCESS */,
    log: `\u2705 File index of aqua tree updated successfully.`
  });
  return Ok(aquaTree);
}
function dict2Leaves(obj) {
  return Object.keys(obj).sort().map((key) => getHashSum(`${key}:${obj[key]}`));
}
function getFileHashSum(fileContent) {
  return getHashSum(fileContent);
}
function getHashSum(data) {
  let hash3 = (0, import_sha.default)("sha256").update(data).digest("hex");
  return hash3;
}
function createNewAquaTree() {
  return {
    revisions: {},
    file_index: {},
    tree: {},
    treeMapping: {}
  };
}
function checkFileHashAlreadyNotarized(fileHash, aquaTree) {
  const existingRevision = Object.values(aquaTree.revisions).find(
    (revision) => revision.file_hash && revision.file_hash === fileHash
  );
  if (existingRevision) {
    return true;
  } else {
    return false;
  }
}
function prepareNonce() {
  return getHashSum(Date.now().toString());
}
async function getWallet(mnemonic) {
  const wallet = import_ethers.Wallet.fromPhrase(mnemonic.trim());
  const { ethers: ethers5 } = await import("ethers");
  const walletAddress = ethers5.getAddress(wallet.address);
  return [wallet, walletAddress, wallet.publicKey, wallet.privateKey];
}
function getEntropy() {
  if (typeof window !== "undefined" && window.crypto) {
    return crypto.getRandomValues(new Uint8Array(16));
  } else {
    const nodeCrypto = require("crypto");
    return new Uint8Array(nodeCrypto.randomBytes(16));
  }
}
var getFileNameCheckingPaths = (fileObjects, fileName) => {
  let fileObjectItem = fileObjects.find((e) => {
    if (e.fileName) {
      if (e.fileName.includes("/") || fileName.includes("/")) {
        let eFileName = e.fileName;
        let parentFileName = fileName;
        if (e.fileName.includes("/")) {
          eFileName = e.fileName.split("/").pop();
        }
        if (fileName.includes("/")) {
          parentFileName = fileName.split("/").pop();
        }
        return eFileName == parentFileName;
      } else {
        return e.fileName == fileName;
      }
    } else {
      return void 0;
    }
  });
  return fileObjectItem;
};
function createCredentials() {
  console.log("Credential file  does not exist. Creating wallet");
  const entropy = getEntropy();
  const mnemonic = import_ethers.Mnemonic.fromEntropy(entropy);
  let credentialsObject = {
    mnemonic: mnemonic.phrase,
    nostr_sk: "",
    did_key: "",
    alchemy_key: "ZaQtnup49WhU7fxrujVpkFdRz4JaFRtZ",
    // project defualt key
    witness_eth_network: "sepolia",
    witness_method: "metamask"
  };
  try {
    return credentialsObject;
  } catch (error) {
    console.error("\u274C Failed to write mnemonic:", error);
    throw Err(error);
  }
}
function formatMwTimestamp(ts) {
  return ts.replace(/-/g, "").replace(/:/g, "").replace("T", "").replace("Z", "");
}
var estimateWitnessGas = async (wallet_address, witness_event_verification_hash, ethNetwork, smart_contract_address, providerUrl) => {
  let logData = [];
  try {
    let provider;
    try {
      if (providerUrl) {
        provider = new import_ethers.ethers.JsonRpcProvider(providerUrl, ethNetwork);
        await provider.getNetwork();
      } else {
        provider = import_ethers.ethers.getDefaultProvider(ethNetwork, {
          // Increase the timeout to handle potential rate limiting
          staticNetwork: true,
          timeout: 3e4
        });
      }
    } catch (error) {
      logData.push({
        log: `Provider connection error: ${error}`,
        logType: "error" /* ERROR */
      });
      throw error;
    }
    const tx = {
      from: import_ethers.ethers.getAddress(wallet_address),
      to: import_ethers.ethers.getAddress(smart_contract_address),
      // Replace with actual contract address
      data: "0x9cef4ea1" + witness_event_verification_hash.replace("0x", "")
      // Function selector + hash
    };
    const balance = await provider.getBalance(wallet_address);
    const balanceInEth = import_ethers.ethers.formatEther(balance);
    logData.push({
      log: `Sender Balance: ${balanceInEth} ETH`,
      logType: "debug_data" /* DEBUGDATA */
    });
    const estimatedGas = await provider.estimateGas(tx);
    logData.push({
      log: `Estimated Gas: ${estimatedGas.toString()} units`,
      logType: "debug_data" /* DEBUGDATA */
    });
    const feeData = await provider.getFeeData();
    logData.push({
      log: `Fee data: ", ${feeData}`,
      logType: "debug_data" /* DEBUGDATA */
    });
    const gasPrice = feeData.gasPrice ? feeData.gasPrice : BigInt(0);
    logData.push({
      log: `Gas Price: ${import_ethers.ethers.formatUnits(gasPrice, "gwei")} Gwei`,
      logType: "debug_data" /* DEBUGDATA */
    });
    const gasCost = estimatedGas * gasPrice;
    const gasCostInEth = import_ethers.ethers.formatEther(gasCost);
    logData.push({
      log: `Estimated Gas Fee: ${gasCostInEth} ETH`,
      logType: "debug_data" /* DEBUGDATA */
    });
    const hasEnoughBalance = balance >= gasCost;
    return [
      {
        error: null,
        gasEstimate: estimatedGas.toString(),
        gasFee: gasCostInEth,
        balance: balanceInEth,
        hasEnoughBalance
      },
      logData
    ];
  } catch (error) {
    logData.push({
      log: `Error estimating gas: ", ${error}`,
      logType: "debug_data" /* DEBUGDATA */
    });
    return [{ error: error.message, hasEnoughBalance: false }, logData];
  }
};
function verifyMerkleIntegrity(merkleBranch, merkleRoot) {
  if (merkleBranch.length === 0) {
    return false;
  }
  let witnessMerkleProofLeaves = merkleBranch;
  let hexRoot = getMerkleRoot(witnessMerkleProofLeaves);
  let merkleRootOk = hexRoot === merkleRoot;
  return merkleRootOk;
}
var getMerkleRoot = (leaves) => {
  const tree2 = new import_merkletreejs.MerkleTree(leaves, getHashSum, {
    duplicateOdd: false
  });
  const hexRoot = tree2.getHexRoot();
  return hexRoot;
};
var getLatestVH = (aquaTree) => {
  const verificationHashes = Object.keys(aquaTree.revisions);
  return verificationHashes[verificationHashes.length - 1];
};
var getTimestamp = () => {
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const timestamp = formatMwTimestamp(now2.slice(0, now2.indexOf(".")));
  return timestamp;
};
async function checkInternetConnection() {
  try {
    const { checkInternetConnectivity: checkInternetConnectivity2 } = await Promise.resolve().then(() => (init_platform(), platform_exports));
    return await checkInternetConnectivity2();
  } catch (error) {
    console.error("Error checking internet connection:", error);
    return false;
  }
}
function printLogs(logs, enableVerbose = true) {
  if (enableVerbose) {
    logs.forEach((element) => {
      console.log(
        `${element.ident ? element.ident : ""} ${LogTypeEmojis[element.logType]} ${element.log}`
      );
    });
  } else {
    let containsError = logs.filter((element) => element.logType == "error");
    if (containsError.length > 0) {
      logs.forEach((element) => {
        if (element.logType == "error") {
          console.log(
            `${element.ident ? element.ident : ""} ${LogTypeEmojis[element.logType]} ${element.log}`
          );
        }
      });
    } else {
      if (logs.length > 0) {
        let lastLog = logs[logs.length - 1];
        console.log(`${LogTypeEmojis[lastLog.logType]} ${lastLog.log}`);
      }
    }
  }
}
function printlinkedGraphData(node, prefix = "", _isLast = true) {
  let revisionTypeEmoji = LogTypeEmojis[node.revisionType];
  let isSuccessorFailureEmoji = node.isValidationSucessful ? LogTypeEmojis["success"] : LogTypeEmojis["error"];
  console.log(
    `${prefix}\u2514${isSuccessorFailureEmoji.trim()} ${revisionTypeEmoji.trim()} ${node.hash}`
  );
  if (node.revisionType === "link") {
    console.log(`${prefix}	Tree ${node.hash.slice(-4)}`);
    for (let i2 = 0; i2 < node.linkVerificationGraphData.length; i2++) {
      const el = node.linkVerificationGraphData[i2];
      printlinkedGraphData(el, `${prefix}	`, false);
    }
  }
  const newPrefix = prefix;
  node.verificationGraphData.forEach((child, index) => {
    const isChildLast = index === node.verificationGraphData.length - 1;
    printlinkedGraphData(child, newPrefix, !isChildLast);
  });
}
function printGraphData(node, prefix = "", isLast = true, isLinkChild = false) {
  const revisionTypeEmoji = LogTypeEmojis[node.revisionType];
  const statusEmoji = node.isValidationSucessful ? LogTypeEmojis["success"] : LogTypeEmojis["error"];
  const connector = isLinkChild ? isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 " : "";
  console.log(`${prefix}${connector}${statusEmoji.trim()} ${revisionTypeEmoji.trim()} ${node.hash}`);
  if (node.revisionType === "link" && node.linkVerificationGraphData.length > 0) {
    const linkPrefix = prefix + (isLinkChild ? "    " : "");
    console.log(`${linkPrefix}    Tree ${node.hash.slice(-4)}`);
    node.linkVerificationGraphData.forEach((linkNode, index) => {
      const isLinkLast = index === node.linkVerificationGraphData.length - 1;
      printGraphData(linkNode, linkPrefix + "    ", isLinkLast, true);
    });
  }
  node.verificationGraphData.forEach((child) => {
    printGraphData(child, prefix, false, false);
  });
}
function OrderRevisionInAquaTree(params) {
  let allHashes = Object.keys(params.revisions);
  let orderdHashes = [];
  if (allHashes.length == 1) {
    return params;
  }
  for (let hash3 of allHashes) {
    let revision = params.revisions[hash3];
    if (revision.previous_verification_hash == "") {
      orderdHashes.push(hash3);
      break;
    }
  }
  while (true) {
    let nextRevisionHash = findNextRevisionHash(
      orderdHashes[orderdHashes.length - 1],
      params
    );
    if (nextRevisionHash == "") {
      break;
    } else {
      orderdHashes.push(nextRevisionHash);
    }
  }
  let newAquaTree = {
    ...params,
    revisions: {}
  };
  for (let hash3 of orderdHashes) {
    let revision = params.revisions[hash3];
    newAquaTree.revisions[hash3] = revision;
  }
  return newAquaTree;
}
function getGenesisHash(aquaTree) {
  let aquaTreeGenesisHash = null;
  let allAquuaTreeHashes = Object.keys(aquaTree.revisions);
  for (let hash3 of allAquuaTreeHashes) {
    let revisionItem = aquaTree.revisions[hash3];
    if (revisionItem.previous_verification_hash == "" || revisionItem.previous_verification_hash == null || revisionItem.previous_verification_hash == void 0) {
      aquaTreeGenesisHash = hash3;
      break;
    }
  }
  return aquaTreeGenesisHash;
}
function findNextRevisionHash(previousVerificationHash, aquaTree) {
  let hashOfRevision = "";
  let allHashes = Object.keys(aquaTree.revisions);
  for (let hash3 of allHashes) {
    let revision = aquaTree.revisions[hash3];
    if (revision.previous_verification_hash == previousVerificationHash) {
      hashOfRevision = hash3;
      break;
    }
  }
  return hashOfRevision;
}
function findNextRevisionHashByArrayofRevisions(previousVerificationHash, revisions) {
  let revisionItem = null;
  for (let revision of revisions) {
    if (revision.previous_verification_hash == previousVerificationHash) {
      revisionItem = revision;
      break;
    }
  }
  return revisionItem;
}
function getAquaTreeFileName(aquaTree) {
  let mainAquaHash = "";
  let revisionHashes = Object.keys(aquaTree.revisions);
  for (let revisionHash of revisionHashes) {
    let revisionData = aquaTree.revisions[revisionHash];
    if (revisionData.previous_verification_hash == null || revisionData.previous_verification_hash == "") {
      mainAquaHash = revisionHash;
      break;
    }
  }
  return aquaTree.file_index[mainAquaHash] ?? "";
}
function getAquaTreeFileObject(fileInfo) {
  let mainAquaFileName = "";
  let mainAquaHash = "";
  let revisionHashes = Object.keys(fileInfo.aquaTree.revisions);
  for (let revisionHash of revisionHashes) {
    let revisionData = fileInfo.aquaTree.revisions[revisionHash];
    if (revisionData.previous_verification_hash == null || revisionData.previous_verification_hash == "") {
      mainAquaHash = revisionHash;
      break;
    }
  }
  mainAquaFileName = fileInfo.aquaTree.file_index[mainAquaHash];
  return fileInfo.fileObject.find((e) => e.fileName == mainAquaFileName);
}
function getChainIdFromNetwork(network2) {
  const networkMap = {
    "mainnet": "0x1",
    // Ethereum Mainnet
    "goerli": "0x5",
    // Goerli Testnet
    "sepolia": "0xaa36a7",
    // Sepolia Testnet
    "polygon": "0x89",
    // Polygon Mainnet
    "mumbai": "0x13881",
    // Mumbai Testnet
    "arbitrum": "0xa4b1",
    // Arbitrum One
    "optimism": "0xa",
    // Optimism
    "avalanche": "0xa86a",
    // Avalanche C-Chain
    "bsc": "0x38"
    // Binance Smart Chain
    // Add more networks as needed
  };
  const chainId = networkMap[network2.toLowerCase()];
  if (!chainId) {
    throw new Error(`Unsupported network: ${network2}`);
  }
  return chainId;
}

// src/aquatreevisualization.ts
function findNode(tree2, hash3) {
  if (tree2.hash === hash3) {
    return tree2;
  }
  for (let i2 = 0; i2 < tree2.children.length; i2++) {
    const child = tree2.children[i2];
    const result = findNode(child, hash3);
    if (result) {
      return result;
    }
  }
  return null;
}
function findPaths(tree2, path3) {
  let paths = {};
  path3.push(tree2.hash);
  if (tree2.children.length === 0) {
    paths[tree2.hash] = path3;
  } else {
    for (let i2 = 0; i2 < tree2.children.length; i2++) {
      const child = tree2.children[i2];
      const childPaths = findPaths(child, [...path3]);
      paths = { ...paths, ...childPaths };
    }
  }
  return paths;
}
function findHashWithLongestPath(tree2) {
  let paths = findPaths(tree2, []);
  let hash3 = "";
  let longestPathLength = 0;
  for (let key in paths) {
    if (paths[key].length > longestPathLength) {
      hash3 = key;
      longestPathLength = paths[key].length;
    }
  }
  return {
    paths,
    latestHash: hash3
  };
}
function createAquaTreeTree(aquaTree) {
  let obj = aquaTree;
  let revisionTree = { children: [] };
  for (let revisionHash in obj.revisions) {
    const revision = obj.revisions[revisionHash];
    const parentHash = revision.previous_verification_hash;
    if (parentHash === "") {
      revisionTree.hash = revisionHash;
      revisionTree.children = [];
    } else {
      const parentNode = findNode(revisionTree, parentHash);
      if (parentNode) {
        parentNode.children.push({
          hash: revisionHash,
          children: []
        });
      }
    }
  }
  return revisionTree;
}
function createAquaTree(aquaTree) {
  if (!aquaTree.revisions || aquaTree.revisions === null || Object.keys(aquaTree.revisions).length === 0) {
    return null;
  }
  let aquaTreeWithReorderdRevisionPrperties = reorderAquaTreeRevisionsProperties(aquaTree);
  let tree2 = createAquaTreeTree(aquaTreeWithReorderdRevisionPrperties);
  let pathResult = findHashWithLongestPath(tree2);
  return {
    ...aquaTreeWithReorderdRevisionPrperties,
    tree: tree2,
    treeMapping: pathResult
  };
}
function logAquaTree(node, prefix = "", isLast = true) {
  console.log(prefix + (isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + node.hash);
  const newPrefix = prefix + (isLast ? "    " : "\u2502   ");
  node.children.forEach((child, index) => {
    const isChildLast = index === node.children.length - 1;
    logAquaTree(child, newPrefix, isChildLast);
  });
}

// src/core/content.ts
async function createContentRevisionUtil(aquaTreeView, fileObject, enableScalar) {
  let logs = [];
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const timestamp = formatMwTimestamp(now2.slice(0, now2.indexOf(".")));
  let revisionType = "file";
  const verificationHashes = Object.keys(aquaTreeView.aquaTree.revisions);
  let lastRevisionHash = verificationHashes[verificationHashes.length - 1];
  let verificationData = {
    previous_verification_hash: lastRevisionHash,
    local_timestamp: timestamp,
    revision_type: revisionType
  };
  let fileHash = getHashSum(fileObject.fileContent);
  let alreadyNotarized = checkFileHashAlreadyNotarized(
    fileHash,
    aquaTreeView.aquaTree
  );
  if (alreadyNotarized) {
    logs.push({
      log: `File ${fileObject.fileName} has already been notarized.`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  verificationData["content"] = fileObject.fileContent;
  verificationData["file_hash"] = fileHash;
  verificationData["file_nonce"] = prepareNonce();
  verificationData["version"] = `https://aqua-protocol.org/docs/v3/schema_2 | SHA256 | Method: ${enableScalar ? "scalar" : "tree"}`;
  const leaves = dict2Leaves(verificationData);
  let verification_hash = "";
  if (!enableScalar) {
    verification_hash = "0x" + getHashSum(JSON.stringify(verificationData));
    verificationData.leaves = leaves;
  } else {
    verification_hash = getMerkleRoot(leaves);
  }
  const revisions = aquaTreeView.aquaTree.revisions;
  revisions[verification_hash] = verificationData;
  maybeUpdateFileIndex(
    aquaTreeView.aquaTree,
    verificationData,
    revisionType,
    fileObject.fileName,
    "",
    "",
    ""
  );
  let aquaTreeWithOrderdRevision = reorderAquaTreeRevisionsProperties(
    aquaTreeView.aquaTree
  );
  let aquaTreeWithTree = createAquaTree(aquaTreeWithOrderdRevision);
  logs.push({
    log: `content revision created succesfully`,
    logType: "success" /* SUCCESS */
  });
  let result = {
    aquaTree: aquaTreeWithTree,
    aquaTrees: null,
    logData: logs
  };
  return Ok(result);
}
function getFileByHashUtil(aquaTree, hash3) {
  let logs = [];
  let res = aquaTree.file_index[hash3];
  if (res) {
    logs.push({
      log: `File with hash  found`,
      logType: "success" /* SUCCESS */
    });
    return Ok(res);
  } else {
    logs.push({
      log: `File with hash ot found`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
}

// src/core/forms.ts
async function createFormRevisionUtil(aquaTreeView, fileObject, enableScalar = false) {
  let logs = [];
  let targetHash = "";
  let revisionType = "form";
  if (aquaTreeView.revision == null || aquaTreeView.revision == void 0 || aquaTreeView.revision.length == 0) {
    logs.push({
      log: `using the last revision `,
      logType: "info" /* INFO */
    });
    const verificationHashes = Object.keys(aquaTreeView.aquaTree.revisions);
    targetHash = verificationHashes[verificationHashes.length - 1];
  }
  let verificationData = {
    previous_verification_hash: targetHash,
    //previousVerificationHash,
    local_timestamp: getTimestamp(),
    revision_type: revisionType
  };
  let fileHash = getHashSum(fileObject.fileContent);
  let alreadyFormified = checkFileHashAlreadyNotarized(fileHash, aquaTreeView.aquaTree);
  if (alreadyFormified) {
    logs.push({
      log: "Error: The form is already part of the aqua tree.",
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  verificationData["file_hash"] = fileHash;
  verificationData["file_nonce"] = prepareNonce();
  verificationData["version"] = `https://aqua-protocol.org/docs/v3/schema_2 | SHA256 | Method: ${enableScalar ? "scalar" : "tree"}`;
  let formDataJson = {};
  try {
    formDataJson = JSON.parse(fileObject.fileContent);
  } catch (parseError) {
    logs.push({
      log: "Error: The file does not contain valid JSON data.",
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  let form_data_sorted_keys = Object.keys(formDataJson);
  let form_data_sorted_with_prefix = {};
  for (let key of form_data_sorted_keys) {
    form_data_sorted_with_prefix[`forms_${key}`] = formDataJson[key];
  }
  verificationData = {
    ...verificationData,
    ...form_data_sorted_with_prefix
  };
  const leaves = dict2Leaves(verificationData);
  let verificationHash = "";
  if (enableScalar) {
    logs.push({
      log: `Scalar enabled`,
      logType: "scalar" /* SCALAR */
    });
    let stringifiedData = JSON.stringify(verificationData);
    verificationHash = "0x" + getHashSum(stringifiedData);
  } else {
    verificationData.leaves = leaves;
    verificationHash = getMerkleRoot(leaves);
  }
  const aquaTree = aquaTreeView.aquaTree;
  aquaTree.revisions[verificationHash] = verificationData;
  let aquaTreeUpdatedResult = maybeUpdateFileIndex(aquaTree, verificationHash, revisionType, fileObject.fileName, fileObject.fileName, "", "");
  if (isErr(aquaTreeUpdatedResult)) {
    logs.push(...aquaTreeUpdatedResult.data);
    return Err(logs);
  }
  let aquaTreeUpdated = aquaTreeUpdatedResult.data;
  let aquaTreeWithTree = createAquaTree(aquaTreeUpdated);
  logs.push({
    log: `Form  revision created succesfully`,
    logType: "success" /* SUCCESS */
  });
  let result = {
    aquaTree: aquaTreeWithTree,
    //aquaTreeWithTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(result);
}
function hideFormElementsUtil(aquaTreeView, keyToHide) {
  let logs = [];
  let targetRevisionHash = "";
  if (aquaTreeView.revision.length > 1) {
    targetRevisionHash = aquaTreeView.revision;
  } else {
    targetRevisionHash = getLatestVH(aquaTreeView.aquaTree);
  }
  const targetRevision = aquaTreeView.aquaTree.revisions[targetRevisionHash];
  if (targetRevisionHash == "" || targetRevision == void 0) {
    logs.push({
      log: `Error: Revision hash not found in file`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  const formKey = findFormKey(targetRevision, keyToHide);
  if (!formKey) {
    logs.push({
      log: `Error: Form key '${formKey}' not found`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  const revisions = aquaTreeView.aquaTree.revisions;
  const deletedKey = `${formKey}.deleted`;
  let newRevision = {};
  for (let key in targetRevision) {
    if (formKey == key) {
      newRevision[deletedKey] = null;
    } else {
      newRevision[key] = targetRevision[key];
    }
  }
  revisions[targetRevisionHash] = newRevision;
  let data = {
    aquaTree: aquaTreeView.aquaTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(data);
}
function unHideFormElementsUtil(aquaTreeView, keyToUnHide, content) {
  let logs = [];
  let targetRevisionHash = "";
  if (aquaTreeView.revision.length > 1) {
    targetRevisionHash = aquaTreeView.revision;
  } else {
    targetRevisionHash = getLatestVH(aquaTreeView.aquaTree);
  }
  const targetRevision = aquaTreeView.aquaTree.revisions[targetRevisionHash];
  if (targetRevisionHash == "" || targetRevision == void 0) {
    logs.push({
      log: `Error: Revision hash not found in file`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  const formKey = findFormKey(targetRevision, keyToUnHide);
  if (!formKey) {
    logs.push({
      log: `Error: Form key '${formKey}' not found`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  const revisions = aquaTreeView.aquaTree.revisions;
  if (formKey.endsWith(".deleted")) {
    const originalKey = formKey.replace(".deleted", "");
    let newRevision = {};
    for (let key in targetRevision) {
      if (formKey == key) {
        newRevision[originalKey] = content;
      } else {
        newRevision[key] = targetRevision[key];
      }
    }
    revisions[targetRevisionHash] = newRevision;
  } else {
    targetRevision[formKey] = content;
  }
  let data = {
    aquaTree: aquaTreeView.aquaTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(data);
}

// src/core/link.ts
async function linkAquaTreeUtil(aquaTreeView, linkAquaTreeView, enableScalar) {
  let logs = [];
  const timestamp = getTimestamp();
  let previous_verification_hash = aquaTreeView.revision;
  if (!aquaTreeView.revision || aquaTreeView.revision === "") {
    previous_verification_hash = getLatestVH(aquaTreeView.aquaTree);
  }
  let newRevision = {
    previous_verification_hash,
    local_timestamp: timestamp,
    revision_type: "link",
    version: `https://aqua-protocol.org/docs/v3/schema_2 | SHA256 | Method: ${enableScalar ? "scalar" : "tree"}`
  };
  const linkVHs = [getLatestVH(linkAquaTreeView.aquaTree)];
  const linkFileHashes = [getHashSum(linkAquaTreeView.fileObject.fileContent)];
  linkFileHashes.forEach((fh) => {
    if (!(fh in linkAquaTreeView.aquaTree.file_index)) {
      return Err(logs);
    }
    console.error(
      `${fh} detected in file index. You are not allowed to interlink Aqua files of the same file`
    );
    process.exit(1);
  });
  const linkData = {
    link_type: "aqua",
    //link_require_indepth_verification: true,
    link_verification_hashes: linkVHs,
    link_file_hashes: linkFileHashes
  };
  newRevision = {
    ...newRevision,
    ...linkData
  };
  let revisionData = reorderRevisionsProperties(newRevision);
  const leaves = dict2Leaves(revisionData);
  let verificationHash = "";
  if (enableScalar) {
    logs.push({
      log: `Scalar enabled`,
      logType: "scalar" /* SCALAR */
    });
    let stringifiedData = JSON.stringify(revisionData);
    verificationHash = "0x" + getHashSum(stringifiedData);
  } else {
    revisionData.leaves = leaves;
    verificationHash = getMerkleRoot(leaves);
  }
  let updatedAquaTree = {
    revisions: {
      ...aquaTreeView.aquaTree.revisions,
      [verificationHash]: revisionData
    },
    file_index: {
      ...aquaTreeView.aquaTree.file_index,
      [linkVHs[0]]: linkAquaTreeView.fileObject.fileName
    }
  };
  let aquaTreeWithTree = createAquaTree(updatedAquaTree);
  let orderedAquaTreeWithTree = reorderAquaTreeRevisionsProperties(aquaTreeWithTree);
  logs.push({
    log: "Linking successful",
    logType: "link" /* LINK */
  });
  let resutData = {
    aquaTree: orderedAquaTreeWithTree,
    logData: logs,
    aquaTrees: []
  };
  return Ok(resutData);
}
async function linkAquaTreesToMultipleAquaTreesUtil(aquaTreeViews, linkAquaTreeView, enableScalar) {
  let logs = [];
  let aquaTree = aquaTreeViews;
  for (const linkAquaTree of linkAquaTreeView) {
    const result = await linkAquaTreeUtil(aquaTree, linkAquaTree, enableScalar);
    if (isOk(result)) {
      const resData = result.data;
      aquaTree = {
        aquaTree: resData.aquaTree,
        fileObject: aquaTreeViews.fileObject,
        revision: ""
      };
      logs.push(...resData.logData);
    } else {
      logs.push(...result.data);
    }
  }
  let resutData = {
    aquaTree: aquaTree.aquaTree,
    logData: logs,
    aquaTrees: []
  };
  return Ok(resutData);
}
async function linkMultipleAquaTreesUtil(aquaTreeViews, linkAquaTreeView, enableScalar) {
  let logs = [];
  let aquaTrees = [];
  for (const aquaTree of aquaTreeViews) {
    const result = await linkAquaTreeUtil(aquaTree, linkAquaTreeView, enableScalar);
    if (isOk(result)) {
      const resData = result.data;
      aquaTrees.push(resData.aquaTree);
      logs.push(...resData.logData);
    } else {
      logs.push(...result.data);
    }
  }
  let resutData = {
    aquaTree: null,
    logData: logs,
    aquaTrees
  };
  return Ok(resutData);
}

// src/core/revision.ts
function checkIfFileAlreadyNotarizedUtil(aquaTree, fileObject) {
  let keys = Object.keys(aquaTree.revisions);
  let firstRevision = aquaTree.revisions[keys[0]];
  let fileHash = getHashSum(fileObject.fileContent);
  return firstRevision.file_hash == fileHash;
}
function fetchFilesToBeReadUtil(aquaTree) {
  let hashAndfiles = /* @__PURE__ */ new Map();
  let keys = Object.keys(aquaTree.file_index);
  keys.forEach((item) => {
    hashAndfiles.set(item, aquaTree.file_index[item]);
  });
  let filesWithoutContentInRevisions = [];
  hashAndfiles.forEach((value, key) => {
    const revision = aquaTree.revisions[key];
    let fileName = value;
    if (revision != void 0 && revision.content != void 0) {
      console.warn(
        `\u2713 File ${fileName} skipped: content already exists in revision ${key}`
      );
    } else {
      filesWithoutContentInRevisions.push(fileName);
    }
  });
  return filesWithoutContentInRevisions;
}
function removeLastRevisionUtil(aquaTree) {
  let logs = [];
  const revisions = aquaTree.revisions;
  const verificationHashes = Object.keys(revisions);
  const lastRevisionHash = verificationHashes[verificationHashes.length - 1];
  const lastRevision = aquaTree.revisions[lastRevisionHash];
  switch (lastRevision.revision_type) {
    case "file":
      delete aquaTree.file_index[lastRevision.file_hash];
      break;
    case "link":
      for (const vh of lastRevision.link_verification_hashes) {
        delete aquaTree.file_index[vh];
      }
  }
  delete aquaTree.revisions[lastRevisionHash];
  logs.push({
    log: `Most recent revision ${lastRevisionHash} has been removed`,
    logType: "info" /* INFO */
  });
  let newAquaTree = createAquaTree(aquaTree);
  let result = {
    aquaTree: newAquaTree,
    aquaTrees: null,
    logData: logs
  };
  if (Object.keys(aquaTree.revisions).length === 0) {
    logs.push({
      log: `The last  revision has been deleted  there are no revisions left.`,
      logType: "hint" /* HINT */
    });
    result.aquaTree = null;
    return Ok(result);
  } else {
    logs.push({
      log: `A revision  has been removed.`,
      logType: "success" /* SUCCESS */
    });
    return Ok(result);
  }
}
async function createGenesisRevision(fileObject, isForm, enableContent, enableScalar) {
  let logs = [];
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const timestamp = formatMwTimestamp(now2.slice(0, now2.indexOf(".")));
  let revisionType = "file";
  if (isForm) {
    revisionType = "form";
  }
  let verificationData = {
    previous_verification_hash: "",
    local_timestamp: timestamp,
    revision_type: revisionType
  };
  verificationData["version"] = `https://aqua-protocol.org/docs/v3/schema_2 | SHA256 | Method: ${enableScalar ? "scalar" : "tree"}`;
  verificationData["file_hash"] = getHashSum(fileObject.fileContent);
  verificationData["file_nonce"] = prepareNonce();
  switch (revisionType) {
    case "file":
      if (enableContent) {
        verificationData["content"] = fileObject.fileContent;
        logs.push({
          log: `Content flag detected.`,
          logType: "file" /* FILE */
        });
      }
      break;
    case "form":
      let formDataJson = {};
      try {
        formDataJson = JSON.parse(fileObject.fileContent);
      } catch (parseError) {
        logs.push({
          log: `Error: The file ${fileObject.fileName} does not contain valid JSON data.`,
          logType: "error" /* ERROR */
        });
        return Err(logs);
      }
      let formDataSortedKeys = Object.keys(formDataJson);
      let formDataSortedWithPrefix = {};
      for (let key of formDataSortedKeys) {
        const formValue = formDataJson[key];
        let value;
        if (typeof formValue == "string" || typeof formValue == "number") {
          value = formValue;
        } else {
          value = JSON.stringify(formValue);
        }
        formDataSortedWithPrefix[`forms_${key}`] = value;
      }
      verificationData = {
        ...verificationData,
        ...formDataSortedWithPrefix
      };
      break;
    default:
      logs.push({
        log: `Genesis revision can either be form  or file.`,
        logType: "error" /* ERROR */
      });
      return Err(logs);
  }
  let sortedVerificationData = reorderRevisionsProperties(verificationData);
  const leaves = dict2Leaves(sortedVerificationData);
  let verificationHash = "";
  if (enableScalar) {
    logs.push({
      log: `Scalar enabled`,
      logType: "scalar" /* SCALAR */
    });
    let stringifiedData = JSON.stringify(sortedVerificationData);
    let hashSumData = getHashSum(stringifiedData);
    verificationHash = "0x" + hashSumData;
  } else {
    sortedVerificationData.leaves = leaves;
    verificationHash = getMerkleRoot(leaves);
  }
  const aquaTree = createNewAquaTree();
  aquaTree.revisions[verificationHash] = sortedVerificationData;
  let aquaTreeUpdatedResult;
  if (revisionType == "file") {
    aquaTreeUpdatedResult = maybeUpdateFileIndex(
      aquaTree,
      verificationHash,
      revisionType,
      fileObject.fileName,
      "",
      "",
      ""
    );
  } else {
    aquaTreeUpdatedResult = maybeUpdateFileIndex(
      aquaTree,
      verificationHash,
      revisionType,
      "",
      fileObject.fileName,
      "",
      ""
    );
  }
  if (isErr(aquaTreeUpdatedResult)) {
    logs.push(...aquaTreeUpdatedResult.data);
    return Err(logs);
  }
  let aquaTreeUpdated = aquaTreeUpdatedResult.data;
  let aquaTreeWithTree = createAquaTree(aquaTreeUpdated);
  logs.push({
    log: `Genesis revision created succesfully`,
    logType: "success" /* SUCCESS */
  });
  let result = {
    aquaTree: aquaTreeWithTree,
    //aquaTreeWithTree,
    aquaTrees: null,
    logData: logs
  };
  return Ok(result);
}
function getRevisionByHashUtil(aquaTree, revisionHash) {
  let logs = [];
  const verificationHashes = Object.keys(aquaTree.revisions);
  if (verificationHashes.includes(revisionHash)) {
    return Ok(aquaTree.revisions[revisionHash]);
  } else {
    logs.push({
      log: `\u274C Revision with hash : ${revisionHash} not found`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
}
function getLastRevisionUtil(aquaTree) {
  let logs = [];
  const verificationHashes = Object.keys(aquaTree.revisions);
  if (verificationHashes.length == 0) {
    logs.push({
      log: `\u274C aqua object has no revisions`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  const lastRevisionHash = verificationHashes[verificationHashes.length - 1];
  return Ok(aquaTree.revisions[lastRevisionHash]);
}

// src/signature/sign_metamask.ts
var import_ethers2 = require("ethers");
var MetaMaskSigner = class {
  constructor(options = {}) {
    this.port = options.port || 3001;
    this.host = options.host || "localhost";
    this.serverUrl = `http://${this.host}:${this.port}`;
    this.maxAttempts = options.maxAttempts || 24;
    this.pollInterval = options.pollInterval || 5e3;
    this.server = null;
    this.lastResult = null;
    this.reactNativeOptions = options.reactNativeOptions || {
      deepLinkUrl: "metamask://",
      callbackUrl: "aqua-js-sdk://callback"
    };
  }
  /**
  * Creates a standardized message for signing
  * 
  * @param verificationHash - Hash of the revision to sign
  * @returns Formatted message string
  */
  createMessage(verificationHash) {
    return `I sign this revision: [${verificationHash}]`;
  }
  /**
  * Creates HTML page for MetaMask interaction
  * 
  * @param message - Message to be signed
  * @returns HTML string with embedded MetaMask integration
  * 
  * This method creates a self-contained HTML page that:
  * - Detects MetaMask presence
  * - Requests account access
  * - Signs message using personal_sign
  * - Posts signature back to local server
  */
  createHtml(message) {
    return `
        <html>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.6.3/ethers.umd.min.js" type="text/javascript"></script>
          <script>
          const message = "${message}";
          const localServerUrl = window.location.href;
          
          const doSignProcess = async () => {
            const wallet_address = window.ethereum.selectedAddress;
            const correctedWalletAddress = ethers.utils.getAddress(wallet_address)
            console.log("correctedWalletAddress  (case sensetive )=="+correctedWalletAddress)
            const signature = await window.ethereum.request({
              method: 'personal_sign',
              params: [message, window.ethereum.selectedAddress],
            });
            document.getElementById("signature").innerHTML = \`Signature of your file: \${signature} (you may close this tab)\`;
            await fetch(localServerUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({signature, wallet_address: correctedWalletAddress})
            });
          }
          
          if (window.ethereum && window.ethereum.isMetaMask) {
            if (window.ethereum.isConnected() && window.ethereum.selectedAddress) {
              doSignProcess();
            } else {
              window.ethereum.request({ method: 'eth_requestAccounts' })
                .then(doSignProcess)
                .catch((error) => {
                  console.error(error);
                  alert(error.message);
                });
            }
          } else {
            alert("Metamask not detected");
          }
          </script>
          <body>
            <div id="signature"></div>
          </body>
        </html>
      `;
  }
  /**
  * Handles signing process in browser environment
  * 
  * @param verificationHash - Hash of the revision to sign
  * @returns Promise resolving to [signature, wallet address, public key]
  * 
  * This method:
  * - Checks for MetaMask presence
  * - Requests account access
  * - Signs message using MetaMask
  * - Recovers public key from signature
  */
  async signInBrowser(verificationHash, network2) {
    if (!window.ethereum || !window.ethereum.isMetaMask) {
      throw new Error("MetaMask not detected");
    }
    const message = this.createMessage(verificationHash);
    try {
      await window.ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: getChainIdFromNetwork(network2) }]
      });
      await window.ethereum.request({ method: "eth_requestAccounts" });
      const _walletAddress = window.ethereum.selectedAddress;
      console.log(`walletAddress ${_walletAddress} if has caps`);
      const rawWalletAddress = window.ethereum.selectedAddress;
      if (!rawWalletAddress) {
        throw new Error("No wallet address selected");
      }
      const { ethers: ethers5 } = await import("ethers");
      const walletAddress = ethers5.getAddress(rawWalletAddress);
      if (!walletAddress) {
        throw new Error("No wallet address selected");
      }
      const signature = await window.ethereum.request({
        method: "personal_sign",
        params: [message, walletAddress]
      });
      const publicKey = await this.recoverPublicKey(message, signature);
      return [signature, walletAddress, publicKey];
    } catch (error) {
      throw error;
    }
  }
  /**
  * Handles signing process in Node.js environment
  * 
  * @param verificationHash - Hash of the revision to sign
  * @returns Promise resolving to [signature, wallet address, public key]
  * 
  * This method:
  * - Creates local HTTP server
  * - Serves HTML page for MetaMask interaction
  * - Polls for signature completion
  * - Cleans up server after signing
  */
  async signInNode(verificationHash) {
    const { createHttpServer: createHttpServer2 } = await Promise.resolve().then(() => (init_platform(), platform_exports));
    const message = this.createMessage(verificationHash);
    const html = this.createHtml(message);
    const server = await createHttpServer2(this.createRequestListener(html));
    if (!server) {
      throw new Error("Failed to create HTTP server. This feature may not be supported in React Native.");
    }
    this.server = server;
    return new Promise((resolve, reject) => {
      try {
        this.server.listen(this.port, this.host, () => {
          console.log(`Server is running on ${this.serverUrl}`);
        });
        this.pollForSignature(message).then(resolve).catch(reject).finally(() => {
          this.server.close();
        });
      } catch (error) {
        this.server.close();
        reject(error);
      }
    });
  }
  /**
  * Creates HTTP request listener for local server
  * 
  * @param html - HTML content to serve
  * @returns Request listener function
  * 
  * This method handles:
  * - GET / - Serves signing page
  * - GET /result - Returns current signature status
  * - POST / - Receives signature from browser
  */
  createRequestListener(html) {
    return (req, res) => {
      if (req.method === "GET" && req.url === "/") {
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end(html);
      } else if (req.method === "GET" && req.url === "/result") {
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(this.lastResult || {}));
      } else if (req.method === "POST") {
        let body = "";
        req.on("data", (chunk) => body += chunk);
        req.on("end", () => {
          this.lastResult = JSON.parse(body);
          res.writeHead(200);
          res.end("OK");
        });
      }
    };
  }
  /**
  * Polls for signature completion
  * 
  * @param message - Original message being signed
  * @returns Promise resolving to [signature, wallet address, public key]
  * 
  * This method:
  * - Checks for signature at regular intervals
  * - Times out after maxAttempts
  * - Recovers public key when signature is received
  */
  async pollForSignature(message) {
    let attempts = 0;
    while (attempts < this.maxAttempts) {
      if (this.lastResult && this.lastResult.signature) {
        const { signature, wallet_address } = this.lastResult;
        const cleanedAddress = import_ethers2.ethers.getAddress(wallet_address);
        const publicKey = await this.recoverPublicKey(message, signature);
        return [signature, cleanedAddress, publicKey];
      }
      console.log("Waiting for the signature...");
      attempts++;
      await this.sleep(this.pollInterval);
    }
    throw new Error("Signature timeout: No response from MetaMask");
  }
  /**
  * Recovers public key from signature
  * 
  * @param message - Original signed message
  * @param signature - Ethereum signature
  * @returns Promise resolving to public key
  * 
  * Uses ethers.js to recover the public key from
  * the signature and message hash.
  */
  async recoverPublicKey(message, signature) {
    const { ethers: ethers5 } = await import("ethers");
    return ethers5.SigningKey.recoverPublicKey(
      ethers5.hashMessage(message),
      signature
    );
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
  * Handles signing process in React Native environment
  * 
  * @param verificationHash - Hash of the revision to sign
  * @param network - Ethereum network to use
  * @returns Promise resolving to [signature, wallet address, public key]
  * 
  * This method:
  * - Creates a deep link to open MetaMask mobile app
  * - Returns a promise that resolves when the signature is received
  * - Recovers public key from signature
  */
  async signInReactNative(verificationHash, network2) {
    const message = this.createMessage(verificationHash);
    const chainId = getChainIdFromNetwork(network2);
    const encodedMessage = encodeURIComponent(message);
    const deepLink = `metamask://ethereum/sign?message=${encodedMessage}&chainId=${chainId}&callbackUrl=${encodeURIComponent(this.reactNativeOptions.callbackUrl)}`;
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error("Signature timeout: No response from MetaMask"));
      }, this.maxAttempts * this.pollInterval);
      global.__aquaMetaMaskResolve = async (signature, address2) => {
        clearTimeout(timeoutId);
        try {
          const cleanedAddress = import_ethers2.ethers.getAddress(address2);
          const publicKey = await this.recoverPublicKey(message, signature);
          resolve([signature, cleanedAddress, publicKey]);
        } catch (error) {
          reject(error);
        }
      };
      global.__aquaMetaMaskReject = (error) => {
        clearTimeout(timeoutId);
        reject(error);
      };
      if (this.reactNativeOptions.onDeepLinkReady) {
        this.reactNativeOptions.onDeepLinkReady(deepLink);
      }
    });
  }
  /**
  * Signs a verification hash using MetaMask
  * 
  * @param verificationHash - Hash of the revision to sign
  * @returns Promise resolving to [signature, wallet address, public key]
  * 
  * This method:
  * - Detects environment (Node.js, browser, or React Native)
  * - Routes to appropriate signing method
  * - Returns complete signature information
  */
  async sign(verificationHash, network2) {
    const isReactNative2 = typeof global !== "undefined" && !!global.HermesInternal;
    const isNode2 = typeof window === "undefined" && !isReactNative2;
    if (isReactNative2) {
      return this.signInReactNative(verificationHash, network2);
    } else if (isNode2) {
      return this.signInNode(verificationHash);
    } else {
      return this.signInBrowser(verificationHash, network2);
    }
  }
};

// src/signature/sign_cli.ts
var CLISigner = class {
  /**
  * Signs a verification hash using the provided wallet
  * 
  * @param wallet - HDNodeWallet instance for signing
  * @param verificationHash - Hash of the revision to sign
  * @returns Promise resolving to the signature string
  * 
  * This method:
  * - Creates a standardized message with the verification hash
  * - Signs the message using the wallet's private key
  * - Returns the resulting signature
  */
  async doSign(wallet, verificationHash) {
    const message = "I sign this revision: [" + verificationHash + "]";
    const signature = await wallet.signMessage(message);
    return signature;
  }
};

// node_modules/did-resolver/lib/resolver.module.js
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function inMemoryCache() {
  const cache2 = /* @__PURE__ */ new Map();
  return function(parsed, resolve) {
    try {
      let _temp22 = function(_result) {
        if (_exit) return _result;
        const cached = cache2.get(parsed.didUrl);
        return cached !== void 0 ? cached : Promise.resolve(resolve()).then(function(result) {
          var _result$didResolution;
          if (((_result$didResolution = result.didResolutionMetadata) == null ? void 0 : _result$didResolution.error) !== "notFound") {
            cache2.set(parsed.didUrl, result);
          }
          return result;
        });
      };
      var _temp2 = _temp22;
      let _exit;
      const _temp = function() {
        if (parsed.params && parsed.params["no-cache"] === "true") {
          return Promise.resolve(resolve()).then(function(_await$resolve) {
            _exit = 1;
            return _await$resolve;
          });
        }
      }();
      return Promise.resolve(_temp && _temp.then ? _temp.then(_temp22) : _temp22(_temp));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function noCache(parsed, resolve) {
  return resolve();
}
var PCT_ENCODED = "(?:%[0-9a-fA-F]{2})";
var ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`;
var METHOD = "([a-z0-9]+)";
var METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`;
var PARAM_CHAR = "[a-zA-Z0-9_.:%-]";
var PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`;
var PARAMS = `((${PARAM})*)`;
var PATH = `(/[^#?]*)?`;
var QUERY = `([?][^#]*)?`;
var FRAGMENT = `(#.*)?`;
var DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
function parse(didUrl) {
  if (didUrl === "" || !didUrl) return null;
  const sections = didUrl.match(DID_MATCHER);
  if (sections) {
    const parts = {
      did: `did:${sections[1]}:${sections[2]}`,
      method: sections[1],
      id: sections[2],
      didUrl
    };
    if (sections[4]) {
      const params = sections[4].slice(1).split(";");
      parts.params = {};
      for (const p of params) {
        const kv = p.split("=");
        parts.params[kv[0]] = kv[1];
      }
    }
    if (sections[6]) parts.path = sections[6];
    if (sections[7]) parts.query = sections[7].slice(1);
    if (sections[8]) parts.fragment = sections[8].slice(1);
    return parts;
  }
  return null;
}
var EMPTY_RESULT = {
  didResolutionMetadata: {},
  didDocument: null,
  didDocumentMetadata: {}
};
function wrapLegacyResolver(resolve) {
  return function(did, parsed, resolver) {
    try {
      return Promise.resolve(_catch(function() {
        return Promise.resolve(resolve(did, parsed, resolver)).then(function(doc) {
          return {
            ...EMPTY_RESULT,
            didResolutionMetadata: {
              contentType: "application/did+ld+json"
            },
            didDocument: doc
          };
        });
      }, function(e) {
        return {
          ...EMPTY_RESULT,
          didResolutionMetadata: {
            error: "notFound",
            message: e.toString()
            // This is not in spec, but may be helpful
          }
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
var Resolver = class {
  constructor(registry = {}, options = {}) {
    this.registry = void 0;
    this.cache = void 0;
    this.registry = registry;
    this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache;
    if (options.legacyResolvers) {
      Object.keys(options.legacyResolvers).map((methodName) => {
        if (!this.registry[methodName]) {
          this.registry[methodName] = wrapLegacyResolver(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            options.legacyResolvers[methodName]
          );
        }
      });
    }
  }
  resolve(didUrl, options = {}) {
    try {
      const _this = this;
      const parsed = parse(didUrl);
      if (parsed === null) {
        return Promise.resolve({
          ...EMPTY_RESULT,
          didResolutionMetadata: {
            error: "invalidDid"
          }
        });
      }
      const resolver = _this.registry[parsed.method];
      if (!resolver) {
        return Promise.resolve({
          ...EMPTY_RESULT,
          didResolutionMetadata: {
            error: "unsupportedDidMethod"
          }
        });
      }
      return Promise.resolve(_this.cache(parsed, () => resolver(parsed.did, parsed, _this, options)));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};

// node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}

// node_modules/did-jwt/node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length3) {
  if (!length3) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output6 = allocUnsafe(length3);
  let offset = 0;
  for (const arr of arrays) {
    output6.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output6);
}

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/did-jwt/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name4) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE2 = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode13(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size2 - length3;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length3;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode17(string4) {
    var buffer2 = decodeUnsafe(string4);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name4} character`);
  }
  return {
    encode: encode13,
    decodeUnsafe,
    decode: decode17
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name4, prefix, baseEncode) {
    this.name = name4;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes6) {
    if (bytes6 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes6)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name4, prefix, baseDecode) {
    this.name = name4;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left2, right2) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right2.decoders || { [right2.prefix]: right2 }
});
var Codec = class {
  constructor(name4, prefix, baseEncode, baseDecode) {
    this.name = name4;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name4, prefix, baseEncode);
    this.decoder = new Decoder(name4, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name4, prefix, encode: encode13, decode: decode17 }) => new Codec(name4, prefix, encode13, decode17);
var baseX = ({ prefix, name: name4, alphabet: alphabet5 }) => {
  const { encode: encode13, decode: decode17 } = base_x_default(alphabet5, name4);
  return from({
    prefix,
    name: name4,
    encode: encode13,
    decode: (text) => coerce(decode17(text))
  });
};
var decode = (string4, alphabet5, bitsPerChar, name4) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet5.length; ++i2) {
    codes[alphabet5[i2]] = i2;
  }
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string4[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name4} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode = (data, alphabet5, bitsPerChar) => {
  const pad4 = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet5[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad4) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name4, prefix, bitsPerChar, alphabet: alphabet5 }) => {
  return from({
    prefix,
    name: name4,
    encode(input) {
      return encode(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet5, bitsPerChar, name4);
    }
  });
};

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/identity.js
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i2) => {
  p[c.codePointAt(0)] = i2;
  return p;
}, []);
function encode2(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode2,
  decode: decode2
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto2 = __toESM(require("crypto"), 1);

// node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js
var varint_exports = {};
__export(varint_exports, {
  decode: () => decode4,
  encodeTo: () => encodeTo,
  encodingLength: () => encodingLength
});

// node_modules/did-jwt/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode3;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
var decode3 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode3,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js
var decode4 = (data, offset = 0) => {
  const code4 = varint_default.decode(data, offset);
  return [
    code4,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code4, digest3) => {
  const size2 = digest3.byteLength;
  const sizeOffset = encodingLength(code4);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes6 = new Uint8Array(digestOffset + size2);
  encodeTo(code4, bytes6, 0);
  encodeTo(size2, bytes6, sizeOffset);
  bytes6.set(digest3, digestOffset);
  return new Digest(code4, size2, digest3, bytes6);
};
var decode5 = (multihash) => {
  const bytes6 = coerce(multihash);
  const [code4, sizeOffset] = decode4(bytes6);
  const [size2, digestOffset] = decode4(bytes6.subarray(sizeOffset));
  const digest3 = bytes6.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code4, size2, digest3, bytes6);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code4, size2, digest3, bytes6) {
    this.code = code4;
    this.size = size2;
    this.digest = digest3;
    this.bytes = bytes6;
  }
};

// node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name4, code: code4, encode: encode13 }) => new Hasher(name4, code4, encode13);
var Hasher = class {
  constructor(name4, code4, encode13) {
    this.name = name4;
    this.code = code4;
    this.encode = encode13;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest3) => create(this.code, digest3));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/sha2.js
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(import_crypto2.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(import_crypto2.default.createHash("sha512").update(input).digest())
});

// node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode4 = coerce;
var digest = (input) => create(code, encode4(input));
var identity2 = {
  code,
  name,
  encode: encode4,
  digest
};

// node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/did-jwt/node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version3, code4, multihash, bytes6) {
    this.code = code4;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes6;
    this.byteOffset = bytes6.byteOffset;
    this.byteLength = bytes6.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code4, multihash } = this;
        if (code4 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code4, digest: digest3 } = this.multihash;
        const multihash = create(code4, digest3);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base4) {
    const { bytes: bytes6, version: version3, _baseCache } = this;
    switch (version3) {
      case 0:
        return toStringV0(bytes6, _baseCache, base4 || base58btc.encoder);
      default:
        return toStringV1(bytes6, _baseCache, base4 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version3, code: code4, multihash, bytes: bytes6 } = value;
      return new _CID(version3, code4, multihash, bytes6 || encodeCID(version3, code4, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version3, multihash, code: code4 } = value;
      const digest3 = decode5(multihash);
      return _CID.create(version3, code4, digest3);
    } else {
      return null;
    }
  }
  static create(version3, code4, digest3) {
    if (typeof code4 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version3) {
      case 0: {
        if (code4 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version3, code4, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes6 = encodeCID(version3, code4, digest3.bytes);
        return new _CID(version3, code4, digest3, bytes6);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest3) {
    return _CID.create(0, DAG_PB_CODE, digest3);
  }
  static createV1(code4, digest3) {
    return _CID.create(1, code4, digest3);
  }
  static decode(bytes6) {
    const [cid, remainder] = _CID.decodeFirst(bytes6);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes6) {
    const specs = _CID.inspectBytes(bytes6);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes6.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest3) : _CID.createV1(specs.codec, digest3);
    return [
      cid,
      bytes6.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode4(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version3 = next();
    let codec = DAG_PB_CODE;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else if (version3 === 1) {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return {
      version: version3,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size2
    };
  }
  static parse(source, base4) {
    const [prefix, bytes6] = parseCIDtoBytes(source, base4);
    const cid = _CID.decode(bytes6);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base4) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base4 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base4 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base4 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base4.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes6, cache2, base4) => {
  const { prefix } = base4;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes6).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes6, cache2, base4) => {
  const { prefix } = base4;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes6);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version3, code4, multihash) => {
  const codeOffset = encodingLength(version3);
  const hashOffset = codeOffset + encodingLength(code4);
  const bytes6 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes6, 0);
  encodeTo(code4, bytes6, codeOffset);
  bytes6.set(multihash, hashOffset);
  return bytes6;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/did-jwt/node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_exports,
  ...identity_exports2
};

// node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name4, prefix, encode13, decode17) {
  return {
    name: name4,
    prefix,
    encoder: {
      name: name4,
      prefix,
      encode: encode13
    },
    decoder: { decode: decode17 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder3 = new TextEncoder();
  return encoder3.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string4 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string4 += String.fromCharCode(buf2[i2]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/did-jwt/node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string4, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string4, "utf-8"));
  }
  return base4.decoder.decode(`${base4.prefix}${string4}`);
}

// node_modules/did-jwt/node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base4.encoder.encode(array).substring(1);
}

// node_modules/@noble/hashes/esm/cryptoNode.js
var nc = __toESM(require("crypto"), 1);
var crypto4 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes6) {
  abytes(bytes6);
  if (hasHexBuiltin)
    return bytes6.toHex();
  let hex2 = "";
  for (let i2 = 0; i2 < bytes6.length; i2++) {
    hex2 += hexes[bytes6[i2]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad4 = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    res.set(a, pad4);
    pad4 += a.length;
  }
  return res;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto4 && typeof crypto4.getRandomValues === "function") {
    return crypto4.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto4 && typeof crypto4.randomBytes === "function") {
    return Uint8Array.from(crypto4.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE7) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE7);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE7 ? 4 : 0;
  const l = isLE7 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE7);
  view.setUint32(byteOffset + l, wl, isLE7);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE7) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE7;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView2 = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE7 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE7);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE7);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length3, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length3;
    to.pos = pos;
    if (length3 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA384_IV = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl2) {
  const l = (Al >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl2 } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var sha2562 = /* @__PURE__ */ createHasher(() => new SHA256());
var sha5122 = /* @__PURE__ */ createHasher(() => new SHA512());
var sha384 = /* @__PURE__ */ createHasher(() => new SHA384());

// node_modules/@noble/curves/esm/utils.js
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n : BigInt("0x" + hex2);
}
function bytesToNumberBE(bytes6) {
  return hexToNumber(bytesToHex(bytes6));
}
function bytesToNumberLE(bytes6) {
  abytes(bytes6);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes6).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n) => (_1n << BigInt(n)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n2(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen3 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen3())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function _validateObject(object2, fields, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _3n = /* @__PURE__ */ BigInt(3);
var _4n = /* @__PURE__ */ BigInt(4);
var _5n = /* @__PURE__ */ BigInt(5);
var _8n = /* @__PURE__ */ BigInt(8);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number7, modulo) {
  if (number7 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number7, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd3 = b;
  if (gcd3 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function sqrt3mod4(Fp3, n) {
  const p1div4 = (Fp3.ORDER + _1n2) / _4n;
  const root = Fp3.pow(n, p1div4);
  if (!Fp3.eql(Fp3.sqr(root), n))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod8(Fp3, n) {
  const p5div8 = (Fp3.ORDER - _5n) / _8n;
  const n2 = Fp3.mul(n, _2n);
  const v = Fp3.pow(n2, p5div8);
  const nv = Fp3.mul(n, v);
  const i2 = Fp3.mul(Fp3.mul(nv, _2n), v);
  const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
  if (!Fp3.eql(Fp3.sqr(root), n))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks(P) {
  if (P < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp3, n) {
    if (Fp3.is0(n))
      return n;
    if (FpLegendre(Fp3, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp3.mul(Fp3.ONE, cc);
    let t = Fp3.pow(n, Q);
    let R = Fp3.pow(n, Q1div2);
    while (!Fp3.eql(t, Fp3.ONE)) {
      if (Fp3.is0(t))
        return Fp3.ZERO;
      let i2 = 1;
      let t_tmp = Fp3.sqr(t);
      while (!Fp3.eql(t_tmp, Fp3.ONE)) {
        i2++;
        t_tmp = Fp3.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i2 - 1);
      const b = Fp3.pow(c, exponent);
      M = i2;
      c = Fp3.sqr(b);
      t = Fp3.mul(t, c);
      R = Fp3.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  return tonelliShanks(P);
}
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp3, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp3.ONE;
  if (power === _1n2)
    return num;
  let p = Fp3.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp3.mul(p, d);
    d = Fp3.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp3.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp3.mul(acc, num);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp3.is0(num))
      return acc;
    inverted[i2] = Fp3.mul(acc, inverted[i2]);
    return Fp3.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp3, n) {
  const p1mod2 = (Fp3.ORDER - _1n2) / _2n;
  const powered = Fp3.pow(n, p1mod2);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero = Fp3.eql(powered, Fp3.ZERO);
  const no = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE7 = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE7)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE7 = _opts.isLE;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE7,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    // is valid and invertible
    isValidNot0: (num) => !f.is0(num) && f.isValid(num),
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num) => isLE7 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes6) => {
      if (bytes6.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes6.length);
      return isLE7 ? bytesToNumberLE(bytes6) : bytesToNumberBE(bytes6);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length3 = getFieldBytesLength(fieldOrder);
  return length3 + Math.ceil(length3 / 2);
}
function mapHashToField(key, fieldOrder, isLE7 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE7 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE7 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, property, points) {
  const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
  const toInv = FpInvertBatch(c.Fp, points.map(getz));
  const affined = points.map((p, i2) => p.toAffine(toInv[i2]));
  return affined.map(c.fromAffine);
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i2) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i2) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}
function wNAF(c, bits) {
  return {
    constTimeNegate: negateCt,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base4 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base4 = p;
        points.push(base4);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base4 = base4.add(p);
          points.push(base4);
        }
        p = base4.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      let p = c.ZERO;
      let f = c.BASE;
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n);
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n);
      return acc;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(P, comp);
        }
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function mulEndoUnsafe(c, point, k1, k2) {
  let acc = point;
  let p1 = c.ZERO;
  let p2 = c.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order);
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp3 = createField(CURVE.p, curveOpts.Fp);
  const Fn = createField(CURVE.n, curveOpts.Fn);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp3.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp3, Fn };
}

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function isEdValidXY(Fp3, CURVE, x, y) {
  const x2 = Fp3.sqr(x);
  const y2 = Fp3.sqr(y);
  const left2 = Fp3.add(Fp3.mul(CURVE.a, x2), y2);
  const right2 = Fp3.add(Fp3.ONE, Fp3.mul(CURVE.d, Fp3.mul(x2, y2)));
  return Fp3.eql(left2, right2);
}
function edwards(CURVE, curveOpts = {}) {
  const { Fp: Fp3, Fn } = _createCurveFields("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn.BYTES * 8) - _1n4;
  const modP2 = (n) => Fp3.create(n);
  const uvRatio2 = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(Fp3.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp3, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n, min, MASK);
    return n;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp3.inv(z);
    const ax = modP2(x * iz);
    const ay = modP2(y * iz);
    const zz = modP2(z * iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X2, ey: Y2, ez: Z, et: T } = p;
    const X22 = modP2(X2 * X2);
    const Y22 = modP2(Y2 * Y2);
    const Z2 = modP2(Z * Z);
    const Z4 = modP2(Z2 * Z2);
    const aX2 = modP2(X22 * a);
    const left2 = modP2(Z2 * modP2(aX2 + Y22));
    const right2 = modP2(Z4 + modP2(d * modP2(X22 * Y22)));
    if (left2 !== right2)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP2(X2 * Y2);
    const ZT = modP2(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    constructor(ex, ey, ez, et) {
      this.ex = acoord("x", ex);
      this.ey = acoord("y", ey);
      this.ez = acoord("z", ez, true);
      this.et = acoord("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point2(x, y, _1n4, modP2(x * y));
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, "ez", points);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP2(X1 * Z2);
      const X2Z1 = modP2(X2 * Z1);
      const Y1Z2 = modP2(Y1 * Z2);
      const Y2Z1 = modP2(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP2(-this.ex), this.ey, this.ez, modP2(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP2(X1 * X1);
      const B = modP2(Y1 * Y1);
      const C = modP2(_2n2 * modP2(Z1 * Z1));
      const D = modP2(a * A);
      const x1y1 = X1 + Y1;
      const E = modP2(modP2(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP2(E * F);
      const Y3 = modP2(G * H);
      const T3 = modP2(E * H);
      const Z3 = modP2(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      const A = modP2(X1 * X2);
      const B = modP2(Y1 * Y2);
      const C = modP2(T1 * d * T2);
      const D = modP2(Z1 * Z2);
      const E = modP2((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP2(B - a * A);
      const X3 = modP2(E * F);
      const Y3 = modP2(G * H);
      const T3 = modP2(E * H);
      const Z3 = modP2(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n4, CURVE_ORDER);
      const { p, f } = wnaf.wNAFCached(this, n, Point2.normalizeZ);
      return Point2.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n4, CURVE_ORDER);
      if (n === _0n4)
        return Point2.ZERO;
      if (this.is0() || n === _1n4)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n, Point2.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes6, zip215 = false) {
      abytes(bytes6);
      return this.fromHex(bytes6, zip215);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp3.BYTES;
      hex2 = ensureBytes("pointHex", hex2, len);
      abool("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange("pointHex.y", y, _0n4, max);
      const y2 = modP2(y * y);
      const u = modP2(y2 - _1n4);
      const v = modP2(d * y2 - a);
      let { isValid: isValid2, value: x } = uvRatio2(u, v);
      if (!isValid2)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP2(-x);
      return Point2.fromAffine({ x, y });
    }
    static fromPrivateScalar(scalar) {
      return Point2.BASE.multiply(scalar);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes6 = numberToBytesLE(y, Fp3.BYTES);
      bytes6[bytes6.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes6;
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n4, modP2(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n4, _1n4, _1n4, _0n4);
  Point2.Fp = Fp3;
  Point2.Fn = Fn;
  const wnaf = wNAF(Point2, Fn.BYTES * 8);
  return Point2;
}
function eddsa(Point2, eddsaOpts) {
  _validateObject(eddsaOpts, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash, hash: cHash } = eddsaOpts;
  const { BASE: G, Fp: Fp3, Fn } = Point2;
  const CURVE_ORDER = Fn.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes6) => bytes6);
  const domain2 = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN2(a) {
    return Fn.create(a);
  }
  function modN_LE(hash3) {
    return modN2(bytesToNumberLE(hash3));
  }
  function getPrivateScalar(key) {
    const len = Fp3.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey2(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain2(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN2(r + k * scalar);
    aInRange("signature.s", s, _0n4, CURVE_ORDER);
    const L = Fp3.BYTES;
    const res = concatBytes(R, numberToBytesLE(s, L));
    return ensureBytes("result", res, L * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey, zip215);
      R = Point2.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G.precompute(8);
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes_(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return { getPublicKey: getPublicKey2, sign: sign2, verify, utils, Point: Point2 };
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp3 = c.Fp;
  const Fn = Field(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp3, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    hash: c.hash,
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point2 = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point2, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP2 = (n) => mod(n, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP2(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP2(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP2(swap * (x_2 - x_3));
    x_2 = modP2(x_2 - dummy);
    x_3 = modP2(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP2(A * A);
      const B = x_2 - z_2;
      const BB = modP2(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP2(D * A);
      const CB = modP2(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP2(dacb * dacb);
      z_3 = modP2(x_1 * modP2(da_cb * da_cb));
      x_2 = modP2(AA * BB);
      z_2 = modP2(E * (AA + modP2(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP2(x_2 * z2);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
    GuBytes: GuBytes.slice()
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
var ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n3,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE.p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n4, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes6) {
  bytes6[0] &= 248;
  bytes6[31] &= 127;
  bytes6[31] |= 64;
  return bytes6;
}
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P = ed25519_CURVE.p;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow3, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, void 0, true))();
var ed25519Defaults = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE,
  Fp,
  hash: sha5122,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var x25519 = /* @__PURE__ */ (() => {
  const P = ed25519_CURVE.p;
  return montgomery({
    P,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
    },
    adjustScalarBytes
  });
})();
function edwardsToMontgomeryPub(edwardsPub) {
  const bpub = ensureBytes("pub", edwardsPub);
  const { y } = ed25519.Point.fromHex(bpub);
  const _1n16 = BigInt(1);
  return Fp.toBytes(Fp.create((_1n16 + y) * Fp.inv(_1n16 - y)));
}
function edwardsToMontgomeryPriv(edwardsPriv) {
  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
}

// node_modules/did-jwt/lib/index.module.js
var import_multibase = __toESM(require_src2(), 1);

// node_modules/@noble/hashes/esm/sha256.js
var sha2563 = sha2562;

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA1_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 80; i2++)
      SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      let F, K;
      if (i2 < 20) {
        F = Chi(B, C, D);
        K = 1518500249;
      } else if (i2 < 40) {
        F = B ^ C ^ D;
        K = 1859775393;
      } else if (i2 < 60) {
        F = Maj(B, C, D);
        K = 2400959708;
      } else {
        F = B ^ C ^ D;
        K = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K + SHA1_W[i2] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = /* @__PURE__ */ createHasher(() => new SHA1());
var Rho160 = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i2) => i2)))();
var Pi160 = /* @__PURE__ */ (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
var idxLR = /* @__PURE__ */ (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j of res)
      j.push(j[i2].map((k) => Rho160[k]));
  return res;
})();
var idxL = /* @__PURE__ */ (() => idxLR[0])();
var idxR = /* @__PURE__ */ (() => idxLR[1])();
var shifts160 = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => Uint8Array.from(i2));
var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var Kl160 = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF_160[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i2]] + hbr, sr[i2]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());

// node_modules/@noble/hashes/esm/ripemd160.js
var ripemd1602 = ripemd160;

// node_modules/@noble/hashes/esm/sha3.js
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R = _1n7, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n7;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n7 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n5)
      t ^= _1n7 << (_1n7 << /* @__PURE__ */ BigInt(j)) - _1n7;
  }
  _SHA3_IOTA.push(t);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes6) {
    anumber(bytes6);
    return this.xofInto(new Uint8Array(bytes6));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
var keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad4 = new Uint8Array(blockLen);
    pad4.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad4.length; i2++)
      pad4[i2] ^= 54;
    this.iHash.update(pad4);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad4.length; i2++)
      pad4[i2] ^= 54 ^ 92;
    this.oHash.update(pad4);
    clean(pad4);
  }
  update(buf2) {
    aexists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length3 = 0;
      if (!isLong)
        length3 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length3 = length3 << 8 | b;
        pos += lenLen;
        if (length3 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length3);
      if (v.length !== length3)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length3) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E } = DER;
      if (num < _0n8)
        throw new E("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex2) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq2 = rs + ss;
    return tlv.encode(48, seq2);
  }
};
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n6 = BigInt(2);
var _3n3 = BigInt(3);
var _4n2 = BigInt(4);
function _legacyHelperEquat(Fp3, a, b) {
  function weierstrassEquation(x) {
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
  }
  return weierstrassEquation;
}
function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
  const { BYTES: expected } = Fn;
  function normPrivateKeyToScalar(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes6 = ensureBytes("private key", key);
      if (allowedPrivateKeyLengths) {
        if (!allowedPrivateKeyLengths.includes(bytes6.length * 2))
          throw new Error("invalid private key");
        const padded = new Uint8Array(expected);
        padded.set(bytes6, padded.length - bytes6.length);
        bytes6 = padded;
      }
      try {
        num = Fn.fromBytes(bytes6);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (wrapPrivateKey)
      num = Fn.create(num);
    if (!Fn.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  return normPrivateKeyToScalar;
}
function weierstrassN(CURVE, curveOpts = {}) {
  const { Fp: Fp3, Fn } = _createCurveFields("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp3.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp3.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp3.toBytes(x);
    abool("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp3.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp3.toBytes(y));
    }
  }
  function pointFromBytes(bytes6) {
    abytes(bytes6);
    const L = Fp3.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    const length3 = bytes6.length;
    const head = bytes6[0];
    const tail = bytes6.subarray(1);
    if (length3 === LC && (head === 2 || head === 3)) {
      const x = Fp3.fromBytes(tail);
      if (!Fp3.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp3.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp3.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp3.neg(y);
      return { x, y };
    } else if (length3 === LU && head === 4) {
      const x = Fp3.fromBytes(tail.subarray(L * 0, L * 1));
      const y = Fp3.fromBytes(tail.subarray(L * 1, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length3}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes8 = curveOpts.toBytes || pointToBytes2;
  const fromBytes = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat(Fp3, CURVE.a, CURVE.b);
  function isValidXY(x, y) {
    const left2 = Fp3.sqr(y);
    const right2 = weierstrassEquation(x);
    return Fp3.eql(left2, right2);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp3.mul(Fp3.pow(CURVE.a, _3n3), _4n2);
  const _27b2 = Fp3.mul(Fp3.sqr(CURVE.b), BigInt(27));
  if (Fp3.is0(Fp3.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp3.isValid(n) || banZero && Fp3.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp3.eql(z, Fp3.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z);
    const ax = Fp3.mul(x, iz);
    const ay = Fp3.mul(y, iz);
    const zz = Fp3.mul(z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp3.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp3.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point2 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(px, py, pz) {
      this.px = acoord("x", px);
      this.py = acoord("y", py, true);
      this.pz = acoord("z", pz);
      Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp3.is0(x) && Fp3.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, "pz", points);
    }
    static fromBytes(bytes6) {
      abytes(bytes6);
      return Point2.fromHex(bytes6);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(privateKey) {
      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    /** Multiscalar Multiplication */
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_3n3);
      return this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp3.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp3.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp3.mul(b, _3n3);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n3);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul3 = (n) => wnaf.wNAFCached(this, n, Point2.normalizeZ);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        const { p: k1p, f: k1f } = mul3(k1);
        const { p: k2p, f: k2f } = mul3(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul3(scalar);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = curveOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n8 || p.is0())
        return Point2.ZERO;
      if (sc === _1n8)
        return p;
      if (wnaf.hasPrecomputes(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
        const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.wNAFCachedUnsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n8)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n8)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    toBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes8(Point2, this, isCompressed);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  Point2.Fp = Fp3;
  Point2.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = wNAF(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function ecdsa(Point2, ecdsaOpts, curveOpts = {}) {
  _validateObject(ecdsaOpts, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac(ecdsaOpts.hash, key, concatBytes(...msgs)));
  const { Fp: Fp3, Fn } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  function isBiggerThanHalfOrder(number7) {
    const HALF = CURVE_ORDER >> _1n8;
    return number7 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
  }
  function aValidRS(title, num) {
    if (!Fn.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }
  class Signature2 {
    constructor(r, s, recovery) {
      aValidRS("r", r);
      aValidRS("s", s);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const L = Fn.BYTES;
      const b = ensureBytes("compactSignature", hex2, L * 2);
      return new Signature2(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature2(r, s);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    // ProjPointType<bigint>
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp3.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n6 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp3.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp3.toBytes(radj);
      const R = Point2.fromHex(concatBytes(pprefix((rec & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toBytes(format2) {
      if (format2 === "compact")
        return concatBytes(Fn.toBytes(this.r), Fn.toBytes(this.s));
      if (format2 === "der")
        return hexToBytes(DER.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const n = CURVE_ORDER;
      return mapHashToField(randomBytes_(getMinHashLength(n)), n);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey2(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const arr = ensureBytes("key", item);
    const length3 = arr.length;
    const L = Fp3.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
      return void 0;
    } else {
      return length3 === LC || length3 === LU;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes6) {
    if (bytes6.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes6);
    const delta = bytes6.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes6) {
    return Fn.create(bits2int(bytes6));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num) {
    aInRange("num < 2^" + fnBits, num, _0n8, ORDER_MASK);
    return Fn.toBytes(num);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3 } = ecdsaOpts;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes_(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n8)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n8)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n8);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
    return drbg(seed, k2sig);
  }
  Point2.BASE.precompute(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    validateSigVerOpts(opts);
    const { lowS, prehash, format: format2 } = opts;
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format2 !== void 0 && !["compact", "der", "js"].includes(format2))
      throw new Error('format must be "compact", "der" or "js"');
    const isHex2 = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex2 && !format2 && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj) {
        if (format2 === void 0 || format2 === "js") {
          _sig = new Signature2(sg.r, sg.s);
        } else {
          throw new Error("invalid format");
        }
      }
      if (isHex2) {
        try {
          if (format2 !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format2 !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = ecdsaOpts.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is2 = Fn.inv(s);
    const u1 = Fn.create(h * is2);
    const u2 = Fn.create(r * is2);
    const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
    if (R.is0())
      return false;
    const v = Fn.create(R.x);
    return v === r;
  }
  return Object.freeze({
    getPublicKey: getPublicKey2,
    getSharedSecret,
    sign: sign2,
    verify,
    utils,
    Point: Point2,
    Signature: Signature2
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp3 = c.Fp;
  const Fn = Field(CURVE.n, c.nBitLength);
  const curveOpts = {
    Fp: Fp3,
    Fn,
    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    wrapPrivateKey: c.wrapPrivateKey,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hash: c.hash,
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, ecdsa2) {
  return Object.assign({}, ecdsa2, {
    ProjectivePoint: ecdsa2.Point,
    CURVE: c
  });
}
function weierstrass(c) {
  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point2 = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point2, ecdsaOpts, curveOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create3 = (hash3) => weierstrass({ ...curveDef, hash: hash3 });
  return { ...create3(defHash), create: create3 };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n7 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n7) / b;
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n6, P) * b3 % P;
  const b9 = pow2(b6, _3n6, P) * b3 % P;
  const b11 = pow2(b9, _2n7, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n6, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n7, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  ...secp256k1_CURVE,
  Fp: Fpk1,
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1_CURVE.n;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n9 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2562);

// node_modules/@noble/curves/esm/nist.js
var p256_CURVE = {
  p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  h: BigInt(1),
  a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
  b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
};
var p384_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  h: BigInt(1),
  a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
  b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
};
var p521_CURVE = {
  p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  h: BigInt(1),
  a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
  b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};
var Fp256 = Field(p256_CURVE.p);
var Fp384 = Field(p384_CURVE.p);
var Fp521 = Field(p521_CURVE.p);
var p256 = createCurve({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha2562);
var p384 = createCurve({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha384);
var p521 = createCurve({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha5122);

// node_modules/@noble/curves/esm/p256.js
var p2562 = p256;

// node_modules/did-jwt/lib/index.module.js
var import_canonicalize = __toESM(require_canonicalize(), 1);

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode13 = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode17 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode: encode13, decode: decode17 };
}
// @__NO_SIDE_EFFECTS__
function alphabet2(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i2) => [l, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from5) => {
      astrArr("join.decode", from5);
      return from5.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from5, to) => from5 + (to - gcd(from5, to));
var powers = /* @__PURE__ */ (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix2(data, from5, to, padding2) {
  aArr(data);
  if (from5 <= 0 || from5 > 32)
    throw new Error(`convertRadix2: wrong from=${from5}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (/* @__PURE__ */ radix2carry(from5, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from5} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from5, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from5];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber2(n);
    if (n >= max)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from5}`);
    carry = carry << from5 | n;
    if (pos + from5 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from5}`);
    pos += from5;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from5)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
// @__NO_SIDE_EFFECTS__
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes6) => {
      if (!isBytes2(bytes6))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes6), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
// @__NO_SIDE_EFFECTS__
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = /* @__PURE__ */ radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode13(prefix, words, limit2 = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes2(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode17(str, limit2 = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit2 !== false && slen > limit2)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode17);
  function decodeToBytes(str) {
    const { prefix, words } = decode17(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes6) {
    return encode13(prefix, toWords(bytes6));
  }
  return {
    encode: encode13,
    decode: decode17,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = /* @__PURE__ */ genBech32("bech32");

// node_modules/@noble/ciphers/esm/utils.js
var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  else if (isBytes3(data))
    data = data.slice();
  else
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function ensureBytes2(b, len) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a.length; i2++)
    diff |= a[i2] ^ b[i2];
  return diff === 0;
}
var wrapCipher = (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint642(view, byteOffset, value, isLE7) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE7);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE7 ? 4 : 0;
  const l = isLE7 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE7);
  view.setUint32(byteOffset + l, wl, isLE7);
}

// node_modules/@noble/ciphers/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes4(a) {
  return a != null && typeof a === "object" && (a instanceof Uint8Array || a.constructor.name === "Uint8Array");
}
function bytes(b, ...lengths) {
  if (!isBytes4(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i2) => a[i2++] & 255 | (a[i2++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    ensureBytes2(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i2 = 0; i2 < 8; i2++)
      this.pad[i2] = u8to16(key, 16 + 2 * i2);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad4 } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i2 = 2; i2 < 10; i2++) {
      h[i2] += c;
      c = h[i2] >>> 13;
      h[i2] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i2 = 1; i2 < 10; i2++) {
      g[i2] = h[i2] + c;
      c = g[i2] >>> 13;
      g[i2] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i2 = 0; i2 < 10; i2++)
      g[i2] &= mask;
    mask = ~mask;
    for (let i2 = 0; i2 < 10; i2++)
      h[i2] = h[i2] & mask | g[i2];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad4[0];
    h[0] = f & 65535;
    for (let i2 = 1; i2 < 8; i2++) {
      f = (h[i2] + pad4[i2] | 0) + (f >>> 16) | 0;
      h[i2] = f & 65535;
    }
  }
  update(data) {
    exists(this);
    const { buffer: buffer2, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer2, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, h } = this;
    let { pos } = this;
    if (pos) {
      buffer2[pos++] = 1;
      for (; pos < 16; pos++)
        buffer2[pos] = 0;
      this.process(buffer2, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      out[opos++] = h[i2] >>> 0;
      out[opos++] = h[i2] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes2(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/_arx.js
var sigma16 = utf8ToBytes2("expand 16-byte k");
var sigma32 = utf8ToBytes2("expand 32-byte k");
var sigma16_32 = u322(sigma16);
var sigma32_32 = u322(sigma32);
function rotl2(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma2, key, nonce2, data, output6, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u322(block);
  const isAligned = isAligned32(data) && isAligned32(output6);
  const d32 = isAligned ? u322(data) : U32_EMPTY;
  const o32 = isAligned ? u322(output6) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma2, key, nonce2, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output6[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number(counterLength);
  number(rounds);
  bool(counterRight);
  bool(allowShortKeys);
  return (key, nonce2, data, output6, counter = 0) => {
    bytes(key);
    bytes(nonce2);
    bytes(data);
    const len = data.length;
    if (!output6)
      output6 = new Uint8Array(len);
    bytes(output6);
    number(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output6.length < len)
      throw new Error(`arx: output (${output6.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma2;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma2 = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma2 = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce2)) {
      nonce2 = nonce2.slice();
      toClean.push(nonce2);
    }
    const k32 = u322(k);
    if (extendNonceFn) {
      if (nonce2.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma2, k32, u322(nonce2.subarray(0, 16)), k32);
      nonce2 = nonce2.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce2.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc4 = new Uint8Array(12);
      nc4.set(nonce2, counterRight ? 0 : 12 - nonce2.length);
      nonce2 = nc4;
      toClean.push(nonce2);
    }
    const n32 = u322(nonce2);
    runCipher(core, sigma2, k32, n32, data, output6, counter, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output6;
  };
}

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i2, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left2 = msg.length % 16;
  if (left2)
    h.update(ZEROS16.subarray(left2));
};
var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn, key, nonce2, data, AAD) {
  const authKey = fn(key, nonce2, ZEROS32);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num = new Uint8Array(16);
  const view = createView2(num);
  setBigUint642(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint642(view, 8, BigInt(data.length), true);
  h.update(num);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce2, AAD) => {
  const tagLength = 16;
  ensureBytes2(key, 32);
  ensureBytes2(nonce2);
  return {
    encrypt: (plaintext, output6) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output6) {
        ensureBytes2(output6, clength);
      } else {
        output6 = new Uint8Array(clength);
      }
      xorStream(key, nonce2, plaintext, output6, 1);
      const tag = computeTag(xorStream, key, nonce2, output6.subarray(0, -tagLength), AAD);
      output6.set(tag, plength);
      return output6;
    },
    decrypt: (ciphertext, output6) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output6) {
        ensureBytes2(output6, plength);
      } else {
        output6 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce2, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce2, data, output6, 1);
      return output6;
    }
  };
};
var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/did-jwt/lib/index.module.js
var u8a = {
  toString: toString2,
  fromString: fromString2,
  concat
};
function bytesToBase64url(b) {
  return u8a.toString(b, "base64url");
}
function base64ToBytes(s) {
  const inputBase64Url = s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return u8a.fromString(inputBase64Url, "base64url");
}
function base58ToBytes(s) {
  return u8a.fromString(s, "base58btc");
}
function bytesToBase58(b) {
  return u8a.toString(b, "base58btc");
}
function multibaseToBytes(s) {
  const bytes6 = (0, import_multibase.decode)(s);
  if ([32, 33, 48, 64, 65, 96].includes(bytes6.length)) {
    return bytes6;
  }
  try {
    const [codec, length3] = varint_exports.decode(bytes6);
    return bytes6.slice(length3);
  } catch (e) {
    return bytes6;
  }
}
function hexToBytes2(s, minLength) {
  let input = s.startsWith("0x") ? s.substring(2) : s;
  if (input.length % 2 !== 0) {
    input = `0${input}`;
  }
  if (minLength) {
    const paddedLength = Math.max(input.length, minLength * 2);
    input = input.padStart(paddedLength, "00");
  }
  return u8a.fromString(input.toLowerCase(), "base16");
}
function encodeBase64url(s) {
  return bytesToBase64url(u8a.fromString(s));
}
function decodeBase64url(s) {
  return u8a.toString(base64ToBytes(s));
}
function bytesToHex2(b) {
  return u8a.toString(b, "base16");
}
function bytesToBigInt(b) {
  return BigInt(`0x` + u8a.toString(b, "base16"));
}
function stringToBytes(s) {
  return u8a.fromString(s, "utf-8");
}
function toJose({
  r,
  s,
  recoveryParam
}, recoverable) {
  const jose = new Uint8Array(recoverable ? 65 : 64);
  jose.set(u8a.fromString(r, "base16"), 0);
  jose.set(u8a.fromString(s, "base16"), 32);
  if (recoverable) {
    if (typeof recoveryParam === "undefined") {
      throw new Error("Signer did not return a recoveryParam");
    }
    jose[64] = recoveryParam;
  }
  return bytesToBase64url(jose);
}
function fromJose(signature) {
  const signatureBytes = base64ToBytes(signature);
  if (signatureBytes.length < 64 || signatureBytes.length > 65) {
    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`);
  }
  const r = bytesToHex2(signatureBytes.slice(0, 32));
  const s = bytesToHex2(signatureBytes.slice(32, 64));
  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : void 0;
  return {
    r,
    s,
    recoveryParam
  };
}
function toSealed(ciphertext, tag) {
  return u8a.concat([base64ToBytes(ciphertext), tag ? base64ToBytes(tag) : new Uint8Array(0)]);
}
function generateKeyPair() {
  const secretKey = x25519.utils.randomPrivateKey();
  const publicKey = x25519.getPublicKey(secretKey);
  return {
    secretKey,
    publicKey
  };
}
function generateKeyPairFromSeed(seed) {
  if (seed.length !== 32) {
    throw new Error(`x25519: seed must be ${32} bytes`);
  }
  return {
    publicKey: x25519.getPublicKey(seed),
    secretKey: seed
  };
}
function genX25519EphemeralKeyPair() {
  const epk = generateKeyPair();
  return {
    publicKeyJWK: {
      kty: "OKP",
      crv: "X25519",
      x: bytesToBase64url(epk.publicKey)
    },
    secretKey: epk.secretKey
  };
}
function sha2564(payload) {
  const data = typeof payload === "string" ? fromString2(payload) : payload;
  return sha2563(data);
}
var keccak = keccak_256;
function toEthereumAddress(hexPublicKey) {
  const hashInput = fromString2(hexPublicKey.slice(2), "base16");
  return `0x${toString2(keccak(hashInput).slice(-20), "base16")}`;
}
function writeUint32BE(value, array = new Uint8Array(4)) {
  const encoded = fromString2(value.toString(), "base10");
  array.set(encoded, 4 - encoded.length);
  return array;
}
var lengthAndInput = (input) => concat([writeUint32BE(input.length), input]);
function concatKDF(secret, keyLen, alg, producerInfo, consumerInfo) {
  if (keyLen !== 256) throw new Error(`Unsupported key length: ${keyLen}`);
  const value = concat([lengthAndInput(fromString2(alg)), lengthAndInput(typeof producerInfo === "undefined" ? new Uint8Array(0) : producerInfo), lengthAndInput(typeof consumerInfo === "undefined" ? new Uint8Array(0) : consumerInfo), writeUint32BE(keyLen)]);
  const roundNumber = 1;
  return sha2564(concat([writeUint32BE(roundNumber), secret, value]));
}
function EdDSASigner(secretKey) {
  const privateKeyBytes = secretKey;
  if (![32, 64].includes(privateKeyBytes.length)) {
    throw new Error(`bad_key: Invalid private key format. Expecting 32 or 64 bytes, but got ${privateKeyBytes.length}`);
  }
  return function(data) {
    try {
      const dataBytes = typeof data === "string" ? stringToBytes(data) : data;
      const signature = ed25519.sign(dataBytes, privateKeyBytes.slice(0, 32));
      return Promise.resolve(bytesToBase64url(signature));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function instanceOfEcdsaSignature(object2) {
  return typeof object2 === "object" && "r" in object2 && "s" in object2;
}
function ES256SignerAlg() {
  return function sign2(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature) {
        if (instanceOfEcdsaSignature(signature)) {
          return toJose(signature);
        } else {
          return signature;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function ES256KSignerAlg(recoverable) {
  return function sign2(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature) {
        if (instanceOfEcdsaSignature(signature)) {
          return toJose(signature, recoverable);
        } else {
          if (recoverable && typeof fromJose(signature).recoveryParam === "undefined") {
            throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`);
          }
          return signature;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function Ed25519SignerAlg() {
  return function sign2(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature) {
        if (!instanceOfEcdsaSignature(signature)) {
          return signature;
        } else {
          throw new Error("invalid_config: expected a signer function that returns a string instead of signature object");
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
var algorithms$1 = {
  ES256: ES256SignerAlg(),
  ES256K: ES256KSignerAlg(),
  // This is a non-standard algorithm but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/146
  "ES256K-R": ES256KSignerAlg(true),
  // This is actually incorrect but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/130
  Ed25519: Ed25519SignerAlg(),
  EdDSA: Ed25519SignerAlg()
};
function SignerAlg(alg) {
  const impl = algorithms$1[alg];
  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
function publicKeyToAddress$1(publicKey, otherAddress) {
  const version3 = bytesToHex2(base58ToBytes(otherAddress).slice(0, 1));
  const publicKeyBuffer = hexToBytes2(publicKey);
  const publicKeyHash = ripemd1602(sha2564(publicKeyBuffer));
  const step1 = version3 + bytesToHex2(publicKeyHash);
  const step2 = sha2564(hexToBytes2(step1));
  const step3 = sha2564(step2);
  const checksum = bytesToHex2(step3).substring(0, 8);
  const step4 = step1 + checksum;
  return bytesToBase58(hexToBytes2(step4));
}
function publicKeyToAddress(publicKey, prefix) {
  const publicKeyBuffer = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes();
  const hash3 = ripemd1602(sha2564(publicKeyBuffer));
  const words = bech32.toWords(hash3);
  return bech32.encode(prefix, words).replace(prefix, "");
}
function verifyBlockchainAccountId(publicKey, blockchainAccountId) {
  if (blockchainAccountId) {
    const chain3 = blockchainAccountId.split(":");
    switch (chain3[0]) {
      case "bip122":
        chain3[chain3.length - 1] = publicKeyToAddress$1(publicKey, chain3[chain3.length - 1]);
        break;
      case "cosmos":
        chain3[chain3.length - 1] = publicKeyToAddress(publicKey, chain3[1]);
        break;
      case "eip155":
        chain3[chain3.length - 1] = toEthereumAddress(publicKey);
        break;
      default:
        return false;
    }
    return chain3.join(":").toLowerCase() === blockchainAccountId.toLowerCase();
  }
  return false;
}
function toSignatureObject(signature, recoverable = false) {
  const rawSig = base64ToBytes(signature);
  if (rawSig.length !== (recoverable ? 65 : 64)) {
    throw new Error("wrong signature length");
  }
  const r = bytesToHex2(rawSig.slice(0, 32));
  const s = bytesToHex2(rawSig.slice(32, 64));
  const sigObj = {
    r,
    s
  };
  if (recoverable) {
    sigObj.recoveryParam = rawSig[64];
  }
  return sigObj;
}
function toSignatureObject2(signature, recoverable = false) {
  const bytes6 = base64ToBytes(signature);
  if (bytes6.length !== (recoverable ? 65 : 64)) {
    throw new Error("wrong signature length");
  }
  return {
    compact: bytes6.slice(0, 64),
    recovery: bytes6[64]
  };
}
function extractPublicKeyBytes(pk) {
  if (pk.publicKeyBase58) {
    return base58ToBytes(pk.publicKeyBase58);
  } else if (pk.publicKeyBase64) {
    return base64ToBytes(pk.publicKeyBase64);
  } else if (pk.publicKeyHex) {
    return hexToBytes2(pk.publicKeyHex);
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "secp256k1" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
    return secp256k1.ProjectivePoint.fromAffine({
      x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),
      y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))
    }).toRawBytes(false);
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "P-256" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
    return p2562.ProjectivePoint.fromAffine({
      x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),
      y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))
    }).toRawBytes(false);
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.kty === "OKP" && ["Ed25519", "X25519"].includes(pk.publicKeyJwk.crv ?? "") && pk.publicKeyJwk.x) {
    return base64ToBytes(pk.publicKeyJwk.x);
  } else if (pk.publicKeyMultibase) {
    return multibaseToBytes(pk.publicKeyMultibase);
  }
  return new Uint8Array();
}
function verifyES256(data, signature, authenticators) {
  const hash3 = sha2564(data);
  const sig = p2562.Signature.fromCompact(toSignatureObject2(signature).compact);
  const fullPublicKeys = authenticators.filter((a) => !a.ethereumAddress && !a.blockchainAccountId);
  const signer = fullPublicKeys.find((pk) => {
    try {
      const pubBytes = extractPublicKeyBytes(pk);
      return p2562.verify(sig, hash3, pubBytes);
    } catch (err) {
      return false;
    }
  });
  if (!signer) throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
function verifyES256K(data, signature, authenticators) {
  const hash3 = sha2564(data);
  const signatureNormalized = secp256k1.Signature.fromCompact(base64ToBytes(signature)).normalizeS();
  const fullPublicKeys = authenticators.filter((a) => {
    return !a.ethereumAddress && !a.blockchainAccountId;
  });
  const blockchainAddressKeys = authenticators.filter((a) => {
    return a.ethereumAddress || a.blockchainAccountId;
  });
  let signer = fullPublicKeys.find((pk) => {
    try {
      const pubBytes = extractPublicKeyBytes(pk);
      return secp256k1.verify(signatureNormalized, hash3, pubBytes);
    } catch (err) {
      return false;
    }
  });
  if (!signer && blockchainAddressKeys.length > 0) {
    signer = verifyRecoverableES256K(data, signature, blockchainAddressKeys);
  }
  if (!signer) throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
function verifyRecoverableES256K(data, signature, authenticators) {
  const signatures = [];
  if (signature.length > 86) {
    signatures.push(toSignatureObject2(signature, true));
  } else {
    const so = toSignatureObject2(signature, false);
    signatures.push({
      ...so,
      recovery: 0
    });
    signatures.push({
      ...so,
      recovery: 1
    });
  }
  const hash3 = sha2564(data);
  const checkSignatureAgainstSigner = (sigObj) => {
    const signature2 = secp256k1.Signature.fromCompact(sigObj.compact).addRecoveryBit(sigObj.recovery || 0);
    const recoveredPublicKey = signature2.recoverPublicKey(hash3);
    const recoveredAddress = toEthereumAddress(recoveredPublicKey.toHex(false)).toLowerCase();
    const recoveredPublicKeyHex = recoveredPublicKey.toHex(false);
    const recoveredCompressedPublicKeyHex = recoveredPublicKey.toHex(true);
    return authenticators.find((a) => {
      const keyHex = bytesToHex2(extractPublicKeyBytes(a));
      return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || a.ethereumAddress?.toLowerCase() === recoveredAddress || a.blockchainAccountId?.split("@eip155")?.[0].toLowerCase() === recoveredAddress || // CAIP-2
      verifyBlockchainAccountId(recoveredPublicKeyHex, a.blockchainAccountId);
    });
  };
  for (const signature2 of signatures) {
    const verificationMethod = checkSignatureAgainstSigner(signature2);
    if (verificationMethod) return verificationMethod;
  }
  throw new Error("invalid_signature: Signature invalid for JWT");
}
function verifyEd25519(data, signature, authenticators) {
  const clear = stringToBytes(data);
  const signatureBytes = base64ToBytes(signature);
  const signer = authenticators.find((a) => {
    return ed25519.verify(signatureBytes, clear, extractPublicKeyBytes(a));
  });
  if (!signer) throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
var algorithms = {
  ES256: verifyES256,
  ES256K: verifyES256K,
  // This is a non-standard algorithm but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/146
  "ES256K-R": verifyRecoverableES256K,
  // This is actually incorrect but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/130
  Ed25519: verifyEd25519,
  EdDSA: verifyEd25519
};
function VerifierAlgorithm(alg) {
  const impl = algorithms[alg];
  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
VerifierAlgorithm.toSignatureObject = toSignatureObject;
var _iteratorSymbol$1 = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var createJWS = function(payload, signer, header2 = {}, options = {}) {
  try {
    if (!header2.alg) header2.alg = defaultAlg;
    const encodedPayload = typeof payload === "string" ? payload : encodeSection(payload, options.canonicalize);
    const signingInput = [encodeSection(header2, options.canonicalize), encodedPayload].join(".");
    const jwtSigner = SignerAlg(header2.alg);
    return Promise.resolve(jwtSigner(signingInput, signer)).then(function(signature) {
      return [signingInput, signature].join(".");
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var defaultAlg = "ES256K";
function encodeSection(data, shouldCanonicalize = false) {
  if (shouldCanonicalize) {
    return encodeBase64url((0, import_canonicalize.default)(data));
  } else {
    return encodeBase64url(JSON.stringify(data));
  }
}
function decodeJWS(jws) {
  const parts = jws.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
  if (parts) {
    return {
      header: JSON.parse(decodeBase64url(parts[1])),
      payload: parts[2],
      signature: parts[3],
      data: `${parts[1]}.${parts[2]}`
    };
  }
  throw new Error("invalid_argument: Incorrect format JWS");
}
function verifyJWSDecoded({
  header: header2,
  data,
  signature
}, pubKeys) {
  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys];
  const signer = VerifierAlgorithm(header2.alg)(data, signature, pubKeys);
  return signer;
}
function verifyJWS(jws, pubKeys) {
  const jwsDecoded = decodeJWS(jws);
  return verifyJWSDecoded(jwsDecoded, pubKeys);
}
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    const observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
var _Pact = /* @__PURE__ */ function() {
  function _Pact2() {
  }
  _Pact2.prototype.then = function(onFulfilled, onRejected) {
    const result = new _Pact2();
    const state = this.s;
    if (state) {
      const callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function(_this) {
      try {
        const value = _this.v;
        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact2;
}();
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}
function _forTo(array, body, check) {
  var i2 = -1, pact, reject;
  function _cycle(result) {
    try {
      while (++i2 < array.length && (!check || !check())) {
        result = body(i2);
        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }
      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }
  _cycle();
  return pact;
}
function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    let _cycle2 = function(result) {
      try {
        while (!(step = iterator.next()).done && (!check || !check())) {
          result = body(step.value);
          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle2, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }
        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    };
    var _cycle = _cycle2;
    var iterator = target[_iteratorSymbol](), step, pact, reject;
    _cycle2();
    if (iterator.return) {
      var _fixup = function(value) {
        try {
          if (!step.done) {
            iterator.return();
          }
        } catch (e) {
        }
        return value;
      };
      if (pact && pact.then) {
        return pact.then(_fixup, function(e) {
          throw _fixup(e);
        });
      }
      _fixup();
    }
    return pact;
  }
  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  }
  var values = [];
  for (var i2 = 0; i2 < target.length; i2++) {
    values.push(target[i2]);
  }
  return _forTo(values, function(i3) {
    return body(values[i3]);
  }, check);
}
function _for(test2, update, body) {
  var stage;
  for (; ; ) {
    var shouldContinue = test2();
    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }
    if (!shouldContinue) {
      return result;
    }
    if (shouldContinue.then) {
      stage = 0;
      break;
    }
    var result = body();
    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }
    if (update) {
      var updateValue = update();
      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }
  var pact = new _Pact();
  var reject = _settle.bind(null, pact, 2);
  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;
  function _resumeAfterBody(value) {
    result = value;
    do {
      if (update) {
        updateValue = update();
        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }
      shouldContinue = test2();
      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);
        return;
      }
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }
      result = body();
      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);
    result.then(_resumeAfterBody).then(void 0, reject);
  }
  function _resumeAfterTest(shouldContinue2) {
    if (shouldContinue2) {
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
  function _resumeAfterUpdate() {
    if (shouldContinue = test2()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}
function validateJWE(jwe) {
  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {
    throw new Error("bad_jwe: missing properties");
  }
  if (jwe.recipients) {
    jwe.recipients.map((rec) => {
      if (!(rec.header && rec.encrypted_key)) {
        throw new Error("bad_jwe: malformed recipients");
      }
    });
  }
}
function encodeJWE({
  ciphertext,
  tag,
  iv,
  protectedHeader,
  recipient
}, aad) {
  const jwe = {
    protected: protectedHeader,
    iv: bytesToBase64url(iv ?? new Uint8Array(0)),
    ciphertext: bytesToBase64url(ciphertext),
    tag: bytesToBase64url(tag ?? new Uint8Array(0))
  };
  if (aad) jwe.aad = bytesToBase64url(aad);
  if (recipient) jwe.recipients = [recipient];
  return jwe;
}
var decryptJWE = function(jwe, decrypter) {
  try {
    let _temp52 = function(_result) {
      if (_exit) ;
      if (cleartext === null) throw new Error("failure: Failed to decrypt");
      return cleartext;
    };
    var _temp5 = _temp52;
    let _exit;
    validateJWE(jwe);
    const protHeader = JSON.parse(decodeBase64url(jwe.protected));
    if (protHeader.enc !== decrypter.enc) throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`);
    const sealed = toSealed(jwe.ciphertext, jwe.tag);
    const aad = stringToBytes(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected);
    let cleartext = null;
    const _temp4 = function() {
      if (protHeader.alg === "dir" && decrypter.alg === "dir") {
        return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)).then(function(_decrypter$decrypt) {
          cleartext = _decrypter$decrypt;
        });
      } else return function() {
        if (!jwe.recipients || jwe.recipients.length === 0) {
          throw new Error("bad_jwe: missing recipients");
        } else {
          let i2 = 0;
          return _for(function() {
            return !cleartext && i2 < jwe.recipients.length;
          }, function() {
            return i2++;
          }, function() {
            const recipient = jwe.recipients[i2];
            Object.assign(recipient.header, protHeader);
            const _temp3 = function() {
              if (recipient.header.alg === decrypter.alg) {
                return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)).then(function(_decrypter$decrypt2) {
                  cleartext = _decrypter$decrypt2;
                });
              }
            }();
            if (_temp3 && _temp3.then) return _temp3.then(function() {
            });
          });
        }
      }();
    }();
    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp52) : _temp52(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
};
var createJWE = function(cleartext, encrypters, protectedHeader = {}, aad, useSingleEphemeralKey = false) {
  try {
    if (encrypters[0].alg === "dir") {
      if (encrypters.length > 1) throw new Error('not_supported: Can only do "dir" encryption to one key.');
      return Promise.resolve(encrypters[0].encrypt(cleartext, protectedHeader, aad)).then(function(encryptionResult) {
        return encodeJWE(encryptionResult, aad);
      });
    } else {
      const tmpEnc = encrypters[0].enc;
      if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {
        throw new Error("invalid_argument: Incompatible encrypters passed");
      }
      let cek;
      let jwe;
      let epk;
      if (useSingleEphemeralKey) {
        epk = encrypters[0].genEpk?.();
        const alg = encrypters[0].alg;
        protectedHeader = {
          ...protectedHeader,
          alg,
          epk: epk?.publicKeyJWK
        };
      }
      const _temp2 = _forOf(encrypters, function(encrypter) {
        const _temp = function() {
          if (!cek) {
            return Promise.resolve(encrypter.encrypt(cleartext, protectedHeader, aad, epk)).then(function(encryptionResult) {
              cek = encryptionResult.cek;
              jwe = encodeJWE(encryptionResult, aad);
            });
          } else {
            return Promise.resolve(encrypter.encryptCek?.(cek, epk)).then(function(recipient) {
              if (recipient) {
                jwe?.recipients?.push(recipient);
              }
            });
          }
        }();
        if (_temp && _temp.then) return _temp.then(function() {
        });
      });
      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function() {
        return jwe;
      }) : jwe);
    }
  } catch (e) {
    return Promise.reject(e);
  }
};
function xc20pEncrypter(key) {
  return (cleartext, aad) => {
    const iv = randomBytes(24);
    const cipher = xchacha20poly1305(key, iv, aad);
    const sealed = cipher.encrypt(cleartext);
    return {
      ciphertext: sealed.subarray(0, sealed.length - 16),
      tag: sealed.subarray(sealed.length - 16),
      iv
    };
  };
}
function xc20pDirEncrypter(key) {
  const encrypt3 = function(cleartext, protectedHeader = {}, aad) {
    try {
      const protHeader = encodeBase64url(JSON.stringify(Object.assign({
        alg
      }, protectedHeader, {
        enc
      })));
      const encodedAad = stringToBytes(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader);
      return Promise.resolve({
        ...xc20pEncrypt(cleartext, encodedAad),
        protectedHeader: protHeader
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  const xc20pEncrypt = xc20pEncrypter(key);
  const enc = "XC20P";
  const alg = "dir";
  return {
    alg,
    enc,
    encrypt: encrypt3
  };
}
function xc20pDirDecrypter(key) {
  const decrypt3 = function(sealed, iv, aad) {
    try {
      try {
        return Promise.resolve(xchacha20poly1305(key, iv, aad).decrypt(sealed));
      } catch (error) {
        return Promise.resolve(null);
      }
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return {
    alg: "dir",
    enc: "XC20P",
    decrypt: decrypt3
  };
}
var createX25519EcdhEsKek = function(recipientPublicKey, senderSecret, alg, apu, apv, ephemeralKeyPair) {
  try {
    const crv = "X25519";
    const keyLen = 256;
    const ephemeral = ephemeralKeyPair ? generateKeyPairFromSeed(ephemeralKeyPair.secretKey) : generateKeyPair();
    const epk = {
      kty: "OKP",
      crv,
      x: bytesToBase64url(ephemeral.publicKey)
    };
    const sharedSecret = x25519.getSharedSecret(ephemeral.secretKey, recipientPublicKey);
    const consumerInfo = base64ToBytes(apv ?? "");
    const kek = concatKDF(sharedSecret, keyLen, alg, void 0, consumerInfo);
    return Promise.resolve({
      epk,
      kek
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var computeX25519EcdhEsKek = function(recipient, receiverSecret, alg) {
  try {
    let _temp22 = function() {
      let producerInfo = void 0;
      let consumerInfo = void 0;
      if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu);
      if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv);
      return concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo);
    };
    var _temp2 = _temp22;
    const crv = "X25519";
    const keyLen = 256;
    const header2 = recipient.header;
    if (header2.epk?.crv !== crv || typeof header2.epk.x == "undefined") return Promise.resolve(null);
    const publicKey = base64ToBytes(header2.epk.x);
    let sharedSecret;
    const _temp = function() {
      if (receiverSecret instanceof Uint8Array) {
        sharedSecret = x25519.getSharedSecret(receiverSecret, publicKey);
      } else {
        return Promise.resolve(receiverSecret(publicKey)).then(function(_receiverSecret) {
          sharedSecret = _receiverSecret;
        });
      }
    }();
    return Promise.resolve(_temp && _temp.then ? _temp.then(_temp22) : _temp22(_temp));
  } catch (e) {
    return Promise.reject(e);
  }
};
function createFullEncrypter(recipientPublicKey, senderSecret, options = {}, kekCreator, keyWrapper, contentEncrypter) {
  const encrypt3 = function(cleartext, protectedHeader = {}, aad, ephemeralKeyPair) {
    try {
      Object.assign(protectedHeader, {
        alg: void 0
      });
      const cek = randomBytes(32);
      return Promise.resolve(encryptCek(cek, ephemeralKeyPair)).then(function(recipient) {
        if (ephemeralKeyPair) {
          protectedHeader.alg = `${kekCreator.alg}+${keyWrapper.alg}`;
          protectedHeader.epk = ephemeralKeyPair.publicKeyJWK;
        }
        return Promise.resolve(contentEncrypter.from(cek).encrypt(cleartext, protectedHeader, aad)).then(function(_contentEncrypter$fro) {
          return {
            ..._contentEncrypter$fro,
            recipient,
            cek
          };
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  const encryptCek = function(cek, ephemeralKeyPair) {
    try {
      return Promise.resolve(kekCreator.createKek(recipientPublicKey, senderSecret, `${kekCreator.alg}+${keyWrapper.alg}`, options.apu, options.apv, ephemeralKeyPair)).then(function({
        epk,
        kek
      }) {
        return Promise.resolve(keyWrapper.from(kek).wrap(cek)).then(function(res) {
          const recipient = {
            encrypted_key: bytesToBase64url(res.ciphertext),
            header: {}
          };
          if (res.iv) recipient.header.iv = bytesToBase64url(res.iv);
          if (res.tag) recipient.header.tag = bytesToBase64url(res.tag);
          if (options.kid) recipient.header.kid = options.kid;
          if (options.apu) recipient.header.apu = options.apu;
          if (options.apv) recipient.header.apv = options.apv;
          if (!ephemeralKeyPair) {
            recipient.header.alg = `${kekCreator.alg}+${keyWrapper.alg}`;
            recipient.header.epk = epk;
          }
          return recipient;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return {
    alg: keyWrapper.alg,
    enc: contentEncrypter.enc,
    encrypt: encrypt3,
    encryptCek,
    genEpk: genX25519EphemeralKeyPair
  };
}
var resolveX25519Encrypters = function(dids, resolver) {
  try {
    const encryptersForDID = function(did, resolved = []) {
      try {
        return Promise.resolve(resolver.resolve(did)).then(function({
          didResolutionMetadata,
          didDocument
        }) {
          function _temp2() {
            const agreementKeys = didDocument.keyAgreement?.map((key) => {
              if (typeof key === "string") {
                return [...didDocument.publicKey || [], ...didDocument.verificationMethod || []].find((pk) => pk.id === key);
              }
              return key;
            })?.filter((key) => typeof key !== "undefined");
            const pks = agreementKeys?.filter((key) => {
              return key.type === "X25519KeyAgreementKey2019" || key.type === "X25519KeyAgreementKey2020";
            }) || [];
            if (!pks.length && !controllerEncrypters.length) throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);
            return pks.map((pk) => x25519Encrypter(extractPublicKeyBytes(pk), pk.id)).concat(...controllerEncrypters);
          }
          resolved.push(did);
          if (didResolutionMetadata?.error || didDocument == null) {
            throw new Error(`resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`);
          }
          let controllerEncrypters = [];
          if (!didDocument.controller && !didDocument.keyAgreement) {
            throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);
          }
          const _temp = function() {
            if (didDocument.controller) {
              let controllers = Array.isArray(didDocument.controller) ? didDocument.controller : [didDocument.controller];
              controllers = controllers.filter((c) => !resolved.includes(c));
              const encrypterPromises2 = controllers.map((did2) => encryptersForDID(did2, resolved).catch(() => {
                return [];
              }));
              return Promise.resolve(Promise.all(encrypterPromises2)).then(function(encrypterArrays) {
                controllerEncrypters = [].concat(...encrypterArrays);
              });
            }
          }();
          return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };
    const encrypterPromises = dids.map((did) => encryptersForDID(did));
    return Promise.resolve(Promise.all(encrypterPromises)).then(function(encrypterArrays) {
      return [].concat(...encrypterArrays);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
function validateHeader(header2) {
  if (!(header2 && header2.epk && header2.iv && header2.tag)) {
    throw new Error("bad_jwe: malformed header");
  }
  return header2;
}
var xc20pKeyWrapper = {
  from: (wrappingKey) => {
    const wrap = function(cek) {
      try {
        return Promise.resolve(xc20pEncrypter(wrappingKey)(cek));
      } catch (e) {
        return Promise.reject(e);
      }
    };
    return {
      wrap
    };
  },
  alg: "XC20PKW"
};
function x25519Encrypter(publicKey, kid, apv) {
  return xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(publicKey, {
    kid,
    apv
  });
}
function xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(recipientPublicKey, options = {}) {
  return createFullEncrypter(recipientPublicKey, void 0, options, {
    createKek: createX25519EcdhEsKek,
    alg: "ECDH-ES"
  }, xc20pKeyWrapper, {
    from: (cek) => xc20pDirEncrypter(cek),
    enc: "XC20P"
  });
}
function x25519Decrypter(receiverSecret) {
  return xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(receiverSecret);
}
function xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(recipientSecret) {
  const decrypt3 = function(sealed, iv, aad, recipient) {
    try {
      recipient = recipient;
      const header2 = validateHeader(recipient.header);
      return Promise.resolve(computeX25519EcdhEsKek(recipient, recipientSecret, alg)).then(function(kek) {
        if (!kek) return null;
        const sealedCek = toSealed(recipient.encrypted_key, header2.tag);
        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(header2.iv))).then(function(cek) {
          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  const alg = "ECDH-ES+XC20PKW";
  const enc = "XC20P";
  return {
    alg,
    enc,
    decrypt: decrypt3
  };
}

// node_modules/multiformats/dist/src/bytes.js
var empty2 = new Uint8Array(0);
function equals4(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce2(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString3(str) {
  return new TextEncoder().encode(str);
}
function toString3(b) {
  return new TextDecoder().decode(b);
}

// node_modules/multiformats/dist/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});

// node_modules/multiformats/dist/src/vendor/base-x.js
function base3(ALPHABET, name4) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE2 = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode13(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size2 - length3;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length3;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode17(string4) {
    var buffer2 = decodeUnsafe(string4);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name4} character`);
  }
  return {
    encode: encode13,
    decodeUnsafe,
    decode: decode17
  };
}
var src2 = base3;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/multiformats/dist/src/bases/base.js
var Encoder2 = class {
  constructor(name4, prefix, baseEncode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    this.name = name4;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes6) {
    if (bytes6 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes6)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name4, prefix, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseDecode");
    __publicField(this, "prefixCodePoint");
    this.name = name4;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  constructor(decoders) {
    __publicField(this, "decoders");
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or2(left2, right2) {
  return new ComposedDecoder2({
    ...left2.decoders ?? { [left2.prefix]: left2 },
    ...right2.decoders ?? { [right2.prefix]: right2 }
  });
}
var Codec2 = class {
  constructor(name4, prefix, baseEncode, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    __publicField(this, "baseDecode");
    __publicField(this, "encoder");
    __publicField(this, "decoder");
    this.name = name4;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name4, prefix, baseEncode);
    this.decoder = new Decoder2(name4, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from3({ name: name4, prefix, encode: encode13, decode: decode17 }) {
  return new Codec2(name4, prefix, encode13, decode17);
}
function baseX2({ name: name4, prefix, alphabet: alphabet5 }) {
  const { encode: encode13, decode: decode17 } = base_x_default2(alphabet5, name4);
  return from3({
    prefix,
    name: name4,
    encode: encode13,
    decode: (text) => coerce2(decode17(text))
  });
}
function decode7(string4, alphabetIdx, bitsPerChar, name4) {
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = alphabetIdx[string4[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name4} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode6(data, alphabet5, bitsPerChar) {
  const pad4 = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet5[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad4) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet5) {
  const alphabetIdx = {};
  for (let i2 = 0; i2 < alphabet5.length; ++i2) {
    alphabetIdx[alphabet5[i2]] = i2;
  }
  return alphabetIdx;
}
function rfc46482({ name: name4, prefix, bitsPerChar, alphabet: alphabet5 }) {
  const alphabetIdx = createAlphabetIdx(alphabet5);
  return from3({
    prefix,
    name: name4,
    encode(input) {
      return encode6(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode7(input, alphabetIdx, bitsPerChar, name4);
    }
  });
}

// node_modules/multiformats/dist/src/bases/base32.js
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/dist/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/dist/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/dist/src/vendor/varint.js
var encode_12 = encode7;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode7(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode7.bytes = offset - oldOffset + 1;
  return out;
}
var decode8 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode8,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/multiformats/dist/src/varint.js
function decode9(data, offset = 0) {
  const code4 = varint_default2.decode(data, offset);
  return [code4, varint_default2.decode.bytes];
}
function encodeTo2(int, target, offset = 0) {
  varint_default2.encode(int, target, offset);
  return target;
}
function encodingLength2(int) {
  return varint_default2.encodingLength(int);
}

// node_modules/multiformats/dist/src/hashes/digest.js
function create2(code4, digest3) {
  const size2 = digest3.byteLength;
  const sizeOffset = encodingLength2(code4);
  const digestOffset = sizeOffset + encodingLength2(size2);
  const bytes6 = new Uint8Array(digestOffset + size2);
  encodeTo2(code4, bytes6, 0);
  encodeTo2(size2, bytes6, sizeOffset);
  bytes6.set(digest3, digestOffset);
  return new Digest2(code4, size2, digest3, bytes6);
}
function decode10(multihash) {
  const bytes6 = coerce2(multihash);
  const [code4, sizeOffset] = decode9(bytes6);
  const [size2, digestOffset] = decode9(bytes6.subarray(sizeOffset));
  const digest3 = bytes6.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code4, size2, digest3, bytes6);
}
function equals5(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals4(a.bytes, data.bytes);
  }
}
var Digest2 = class {
  /**
   * Creates a multihash digest.
   */
  constructor(code4, size2, digest3, bytes6) {
    __publicField(this, "code");
    __publicField(this, "size");
    __publicField(this, "digest");
    __publicField(this, "bytes");
    this.code = code4;
    this.size = size2;
    this.digest = digest3;
    this.bytes = bytes6;
  }
};

// node_modules/multiformats/dist/src/cid.js
function format(link, base4) {
  const { bytes: bytes6, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV02(bytes6, baseCache(link), base4 ?? base58btc2.encoder);
    default:
      return toStringV12(bytes6, baseCache(link), base4 ?? base322.encoder);
  }
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
var _a;
var CID2 = class _CID {
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code4, multihash, bytes6) {
    __publicField(this, "code");
    __publicField(this, "version");
    __publicField(this, "multihash");
    __publicField(this, "bytes");
    __publicField(this, "/");
    __publicField(this, _a, "CID");
    this.code = code4;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes6;
    this["/"] = bytes6;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code4, multihash } = this;
        if (code4 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code4, digest: digest3 } = this.multihash;
        const multihash = create2(code4, digest3);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown2 = other;
    return unknown2 != null && self2.code === unknown2.code && self2.version === unknown2.version && equals5(self2.multihash, unknown2.multihash);
  }
  toString(base4) {
    return format(this, base4);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  // Legacy
  [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code4, multihash, bytes: bytes6 } = value;
      return new _CID(version3, code4, multihash, bytes6 ?? encodeCID2(version3, code4, multihash.bytes));
    } else if (value[cidSymbol2] === true) {
      const { version: version3, multihash, code: code4 } = value;
      const digest3 = decode10(multihash);
      return _CID.create(version3, code4, digest3);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code4, digest3) {
    if (typeof code4 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest3.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code4 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version3, code4, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes6 = encodeCID2(version3, code4, digest3.bytes);
        return new _CID(version3, code4, digest3, bytes6);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest3) {
    return _CID.create(0, DAG_PB_CODE2, digest3);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code4, digest3) {
    return _CID.create(1, code4, digest3);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes6) {
    const [cid, remainder] = _CID.decodeFirst(bytes6);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes6) {
    const specs = _CID.inspectBytes(bytes6);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes6.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest3) : _CID.createV1(specs.codec, digest3);
    return [cid, bytes6.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode9(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version3 = next();
    let codec = DAG_PB_CODE2;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size: size2 };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base4) {
    const [prefix, bytes6] = parseCIDtoBytes2(source, base4);
    const cid = _CID.decode(bytes6);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes2(source, base4) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base4 ?? base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base4 ?? base58btc2;
      return [base58btc2.prefix, decoder.decode(source)];
    }
    case base322.prefix: {
      const decoder = base4 ?? base322;
      return [base322.prefix, decoder.decode(source)];
    }
    case base362.prefix: {
      const decoder = base4 ?? base362;
      return [base362.prefix, decoder.decode(source)];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base4.decode(source)];
    }
  }
}
function toStringV02(bytes6, cache2, base4) {
  const { prefix } = base4;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes6).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV12(bytes6, cache2, base4) {
  const { prefix } = base4;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes6);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
function encodeCID2(version3, code4, multihash) {
  const codeOffset = encodingLength2(version3);
  const hashOffset = codeOffset + encodingLength2(code4);
  const bytes6 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version3, bytes6, 0);
  encodeTo2(code4, bytes6, codeOffset);
  bytes6.set(multihash, hashOffset);
  return bytes6;
}
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/multiformats/dist/src/hashes/hasher.js
function from4({ name: name4, code: code4, encode: encode13 }) {
  return new Hasher2(name4, code4, encode13);
}
var Hasher2 = class {
  constructor(name4, code4, encode13) {
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "encode");
    this.name = name4;
    this.code = code4;
    this.encode = encode13;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest3) => create2(this.code, digest3));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/multiformats/dist/src/block.js
function readonly2({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path3, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index, element] of value.entries()) {
        const elementPath = [...path3, index];
        const cid = CID2.asCID(element);
        if (cid != null) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID2.asCID(value);
      if (cid != null) {
        yield [path3.join("/"), cid];
      } else {
        yield* links(value, path3);
      }
    }
  }
}
function* links(source, base4) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID2.asCID(source);
  if (cid != null) {
    yield [base4.join("/"), cid];
  }
  for (const [key, value] of Object.entries(source)) {
    const path3 = [...base4, key];
    yield* linksWithin(path3, value);
  }
}
function* treeWithin(path3, value) {
  if (Array.isArray(value)) {
    for (const [index, element] of value.entries()) {
      const elementPath = [...path3, index];
      yield elementPath.join("/");
      if (typeof element === "object" && CID2.asCID(element) == null) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path3);
  }
}
function* tree(source, base4) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path3 = [...base4, key];
    yield path3.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && CID2.asCID(value) == null) {
      yield* treeWithin(path3, value);
    }
  }
}
function get(source, path3) {
  let node = source;
  for (const [index, key] of path3.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path3.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID2.asCID(node);
    if (cid != null) {
      return { value: cid, remaining: path3.slice(index + 1).join("/") };
    }
  }
  return { value: node };
}
var Block = class {
  constructor({ cid, bytes: bytes6, value }) {
    __publicField(this, "cid");
    __publicField(this, "bytes");
    __publicField(this, "value");
    __publicField(this, "asBlock");
    if (cid == null || bytes6 == null || typeof value === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes6;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path3 = "/") {
    return get(this.value, path3.split("/").filter(Boolean));
  }
};
async function encode8({ value, codec, hasher }) {
  if (typeof value === "undefined") {
    throw new Error('Missing required argument "value"');
  }
  if (codec == null || hasher == null) {
    throw new Error("Missing required argument: codec or hasher");
  }
  const bytes6 = codec.encode(value);
  const hash3 = await hasher.digest(bytes6);
  const cid = CID2.create(1, codec.code, hash3);
  return new Block({ value, bytes: bytes6, cid });
}
async function decode11({ bytes: bytes6, codec, hasher }) {
  if (bytes6 == null) {
    throw new Error('Missing required argument "bytes"');
  }
  if (codec == null || hasher == null) {
    throw new Error("Missing required argument: codec or hasher");
  }
  const value = codec.decode(bytes6);
  const hash3 = await hasher.digest(bytes6);
  const cid = CID2.create(1, codec.code, hash3);
  return new Block({ value, bytes: bytes6, cid });
}

// node_modules/multiformats/dist/src/hashes/sha2.js
var sha2_exports2 = {};
__export(sha2_exports2, {
  sha256: () => sha2565,
  sha512: () => sha5123
});
var import_crypto4 = __toESM(require("crypto"), 1);
var sha2565 = from4({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce2(import_crypto4.default.createHash("sha256").update(input).digest())
});
var sha5123 = from4({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce2(import_crypto4.default.createHash("sha512").update(input).digest())
});

// node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var code2 = 0;
var name2 = "identity";
var encode9 = coerce2;
function digest2(input) {
  return create2(code2, encode9(input));
}
var identity3 = { code: code2, name: name2, encode: encode9, digest: digest2 };

// node_modules/multiformats/dist/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
var base642 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@ipld/dag-cbor/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code3,
  decode: () => decode13,
  decodeOptions: () => decodeOptions,
  encode: () => encode11,
  encodeOptions: () => encodeOptions,
  name: () => name3,
  toByteView: () => toByteView
});

// node_modules/cborg/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/cborg/lib/token.js
var Type = class {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name4, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name4;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/cborg/lib/byte-utils.js
var useBuffer = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder2 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString4 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes6, start, end) => {
    return end - start > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes6.subarray(start, end)).toString("utf8")
    ) : utf8Slice(bytes6, start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes6, start, end) => {
    return end - start > 64 ? textDecoder2.decode(bytes6.subarray(start, end)) : utf8Slice(bytes6, start, end);
  }
);
var fromString4 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string4) => {
    return string4.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string4)
    ) : utf8ToBytes3(string4);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string4) => {
    return string4.length > 64 ? textEncoder2.encode(string4) : utf8ToBytes3(string4);
  }
);
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes6, start, end) => {
    if (isBuffer2(bytes6)) {
      return new Uint8Array(bytes6.subarray(start, end));
    }
    return bytes6.slice(start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes6, start, end) => {
    return bytes6.slice(start, end);
  }
);
var concat2 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length3) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A(globalThis.Buffer.concat(chunks, length3));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length3) => {
    const out = new Uint8Array(length3);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size2) => {
    return globalThis.Buffer.allocUnsafe(size2);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size2) => {
    return new Uint8Array(size2);
  }
);
function compare2(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes3(str) {
  const out = [];
  let p = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    let c = str.charCodeAt(i2);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}

// node_modules/cborg/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes6) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes6.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes6, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes6.length < 64 && bytes6.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes6, 0);
      } else {
        this.chunks.push(bytes6);
        this.maxCursor += bytes6.length;
      }
    }
    this.cursor += bytes6.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/cborg/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// node_modules/cborg/lib/0uint.js
var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/cborg/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/cborg/lib/2bytes.js
function toToken(data, pos, prefix, length3) {
  assertEnoughData(data, pos, prefix + length3);
  const buf2 = slice(data, pos + prefix, pos + prefix + length3);
  return new Token(Type.bytes, buf2, prefix + length3);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString4(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes6 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes6.length);
  buf2.push(bytes6);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes6 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes6.length) + bytes6.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}

// node_modules/cborg/lib/3string.js
function toToken2(data, pos, prefix, length3, options) {
  const totLength = prefix + length3;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString4(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// node_modules/cborg/lib/4array.js
function toToken3(_data, _pos, prefix, length3) {
  return new Token(Type.array, length3, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/lib/5map.js
function toToken4(_data, _pos, prefix, length3) {
  return new Token(Type.map, length3, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes6, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes6);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/cborg/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// node_modules/cborg/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [simpleTokens.emptyArray, new Token(Type.break)];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e of obj) {
      entries[i2++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
    }
    return [new Token(Type.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length3 = isMap ? obj.size : keys.length;
    if (!length3) {
      if (options.addBreakTokens === true) {
        return [simpleTokens.emptyMap, new Token(Type.break)];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [new Token(Type.map, length3), entries, new Token(Type.break)];
    }
    return [new Token(Type.map, length3), entries];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder3 = encoders[tokens.type.major];
    if (encoder3.encodedSize) {
      const size2 = encoder3.encodedSize(tokens, options);
      const buf2 = new Bl(size2);
      encoder3(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode10(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// node_modules/cborg/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode12(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/@ipld/dag-cbor/src/index.js
var CID_CBOR_TAG = 42;
function toByteView(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID2.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes6 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes6.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes6)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var _encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
var encodeOptions = {
  ..._encodeOptions,
  typeEncoders: {
    ..._encodeOptions.typeEncoders
  }
};
function cidDecoder(bytes6) {
  if (bytes6[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID2.decode(bytes6.subarray(1));
}
var _decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var decodeOptions = {
  ..._decodeOptions,
  tags: _decodeOptions.tags.slice()
};
var name3 = "dag-cbor";
var code3 = 113;
var encode11 = (node) => encode10(node, _encodeOptions);
var decode13 = (data) => decode12(toByteView(data), _decodeOptions);

// node_modules/dag-jose-utils/dist/index.js
var ENC_BLOCK_SIZE = 24;
async function encodePayload(payload) {
  const block = await encode8({
    value: payload,
    codec: src_exports,
    hasher: sha2565
  });
  return {
    cid: block.cid,
    linkedBlock: block.bytes
  };
}
function pad(b, blockSize = ENC_BLOCK_SIZE) {
  const padLen = (blockSize - b.length % blockSize) % blockSize;
  const bytes6 = new Uint8Array(b.length + padLen);
  bytes6.set(b, 0);
  return bytes6;
}
async function encodeIdentityCID(obj) {
  const block = await encode8({
    value: obj,
    codec: src_exports,
    hasher: identity3
  });
  return block.cid;
}
function decodeIdentityCID(cid) {
  const validcid = CID2.asCID(cid);
  if (!validcid) throw new Error("CID could not be parsed");
  if (validcid.code !== code3) throw new Error("CID codec must be dag-cbor");
  if (validcid.multihash.code !== identity3.code) throw new Error("CID must use identity multihash");
  return decode13(validcid.multihash.digest);
}
async function prepareCleartext(cleartext, blockSize) {
  return pad((await encodeIdentityCID(cleartext)).bytes, blockSize);
}
function decodeCleartext(b) {
  return decodeIdentityCID(CID2.decodeFirst(b)[0]);
}

// node_modules/rpc-utils/dist/abortable.js
var abortableHandlerSymbol = Symbol("abortable");
var abortedReasonSymbol = Symbol("aborted");
function abortable(source, signal) {
  if (signal.aborted) {
    return Promise.reject(abortedReasonSymbol);
  }
  let rejectAborted;
  const abortion = new Promise((_resolve, reject) => {
    rejectAborted = reject;
  });
  signal.addEventListener("abort", () => {
    rejectAborted(abortedReasonSymbol);
  });
  return Promise.race([
    source,
    abortion
  ]);
}

// node_modules/nanoid/index.js
var import_crypto5 = __toESM(require("crypto"), 1);

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
var fillPool = (bytes6) => {
  if (!pool || pool.length < bytes6) {
    pool = Buffer.allocUnsafe(bytes6 * POOL_SIZE_MULTIPLIER);
    import_crypto5.default.randomFillSync(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes6 > pool.length) {
    import_crypto5.default.randomFillSync(pool);
    poolOffset = 0;
  }
  poolOffset += bytes6;
};
var nanoid = (size2 = 21) => {
  fillPool(size2 |= 0);
  let id = "";
  for (let i2 = poolOffset - size2; i2 < poolOffset; i2++) {
    id += urlAlphabet[pool[i2] & 63];
  }
  return id;
};

// node_modules/rpc-utils/dist/constants.js
var ABORT_REQUEST_METHOD = "utils_abort_request";

// node_modules/rpc-utils/dist/error.js
var ERROR_CODE;
(function(ERROR_CODE2) {
  ERROR_CODE2[ERROR_CODE2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  ERROR_CODE2[ERROR_CODE2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  ERROR_CODE2[ERROR_CODE2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  ERROR_CODE2[ERROR_CODE2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  ERROR_CODE2[ERROR_CODE2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
})(ERROR_CODE || (ERROR_CODE = {}));
var ERROR_MESSAGE = {
  [ERROR_CODE.PARSE_ERROR]: "Parse error",
  [ERROR_CODE.INVALID_REQUEST]: "Invalid request",
  [ERROR_CODE.METHOD_NOT_FOUND]: "Method not found",
  [ERROR_CODE.INVALID_PARAMS]: "Invalid params",
  [ERROR_CODE.INTERNAL_ERROR]: "Internal error"
};
function isServerError(code4) {
  return -32e3 >= code4 && code4 >= -32099;
}
function getErrorMessage(code4) {
  return ERROR_MESSAGE[code4.toString()] ?? (isServerError(code4) ? "Server error" : "Application error");
}
var RPCError = class _RPCError extends Error {
  static fromObject(err) {
    return new _RPCError(err.code, err.message, err.data);
  }
  toObject() {
    return {
      code: this.code,
      data: this.data,
      message: this.message
    };
  }
  constructor(code4, message, data) {
    super();
    Object.setPrototypeOf(this, _RPCError.prototype);
    this.code = code4;
    this.data = data;
    this.message = message ?? getErrorMessage(code4);
  }
};
function createErrorFactory(code4) {
  const message = ERROR_MESSAGE[code4];
  return function createError(data) {
    return new RPCError(code4, message, data);
  };
}
var createParseError = createErrorFactory(ERROR_CODE.PARSE_ERROR);
var createInvalidRequest = createErrorFactory(ERROR_CODE.INVALID_REQUEST);
var createMethodNotFound = createErrorFactory(ERROR_CODE.METHOD_NOT_FOUND);
var createInvalidParams = createErrorFactory(ERROR_CODE.INVALID_PARAMS);
var createInternalError = createErrorFactory(ERROR_CODE.INTERNAL_ERROR);

// node_modules/rpc-utils/dist/client.js
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
var _connection = /* @__PURE__ */ new WeakMap();
var RPCClient = class {
  get connection() {
    return _classPrivateFieldGet(this, _connection);
  }
  createID() {
    return nanoid();
  }
  request(method, params = void 0, options = {}) {
    const { signal } = options;
    if (signal?.aborted) {
      return Promise.reject(abortedReasonSymbol);
    }
    const id = this.createID();
    const responsePromise = _classPrivateFieldGet(this, _connection).send({
      jsonrpc: "2.0",
      id,
      method,
      params
    }).then((res) => {
      if (res == null) {
        throw new Error("Missing response");
      }
      if (res.error != null) {
        throw RPCError.fromObject(res.error);
      }
      return res.result;
    });
    if (signal == null) {
      return responsePromise;
    }
    signal.addEventListener("abort", () => {
      void this.notify(ABORT_REQUEST_METHOD, {
        id
      });
    });
    return abortable(responsePromise, signal);
  }
  async notify(method, params = void 0) {
    await _classPrivateFieldGet(this, _connection).send({
      jsonrpc: "2.0",
      method,
      params
    });
  }
  constructor(connection) {
    _classPrivateFieldInit(this, _connection, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _connection, connection);
  }
};

// node_modules/rpc-utils/dist/server.js
function createErrorResponse(id, code4) {
  return {
    jsonrpc: "2.0",
    id,
    error: {
      code: code4,
      message: getErrorMessage(code4)
    }
  };
}
function fallbackOnHandlerError(_ctx, msg, error) {
  console.warn("Unhandled handler error", msg, error);
}
function fallbackOnInvalidMessage(_ctx, msg) {
  console.warn("Unhandled invalid message", msg);
}
function fallbackOnNotification(_ctx, msg) {
  console.warn("Unhandled notification", msg);
}
function createHandler(methods, options = {}) {
  const onHandlerError = options.onHandlerError ?? fallbackOnHandlerError;
  const onInvalidMessage = options.onInvalidMessage ?? fallbackOnInvalidMessage;
  const onNotification = options.onNotification ?? fallbackOnNotification;
  const inflight = {};
  function handleNotification(ctx, msg) {
    if (msg.method === ABORT_REQUEST_METHOD) {
      const requestID = msg.params?.id;
      if (requestID != null) {
        inflight[requestID]?.abort();
      }
    } else {
      onNotification(ctx, msg);
    }
  }
  return async function handleRequest(ctx, msg) {
    const id = msg.id;
    if (msg.jsonrpc !== "2.0" || msg.method == null) {
      if (id == null) {
        onInvalidMessage(ctx, msg);
        return null;
      }
      return createErrorResponse(id, ERROR_CODE.INVALID_REQUEST);
    }
    const handler = methods[msg.method];
    if (handler == null) {
      if (id == null) {
        handleNotification(ctx, msg);
        return null;
      }
      return createErrorResponse(id, ERROR_CODE.METHOD_NOT_FOUND);
    }
    try {
      let handled;
      if (id != null && handler[abortableHandlerSymbol]) {
        const controller = new AbortController();
        inflight[id] = controller;
        handled = handler(ctx, msg.params, {
          signal: controller.signal
        });
      } else {
        handled = handler(ctx, msg.params, {});
      }
      const result = handled == null ? handled : typeof handled.then === "function" ? await handled : handled;
      return id == null || inflight[id]?.signal.aborted ? null : {
        jsonrpc: "2.0",
        id,
        result
      };
    } catch (err) {
      if (id == null || inflight[id]?.signal.aborted) {
        onHandlerError(ctx, msg, err);
        return null;
      }
      let error;
      if (err instanceof RPCError) {
        error = err.toObject();
      } else {
        onHandlerError(ctx, msg, err);
        const code4 = err.code ?? -32e3;
        error = {
          code: code4,
          message: err.message || getErrorMessage(code4)
        };
      }
      return {
        jsonrpc: "2.0",
        id,
        error
      };
    } finally {
      if (id != null) {
        delete inflight[id];
      }
    }
  };
}

// node_modules/caip/dist/index.mjs
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var CAIP2 = {
  name: "chainId",
  regex: "[-:a-zA-Z0-9]{5,41}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,32}"
      }
    }
  }
};
var CAIP10 = {
  name: "accountId",
  regex: "[-:a-zA-Z0-9]{7,106}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,32}"
      },
      2: {
        name: "address",
        regex: "[a-zA-Z0-9]{1,64}"
      }
    }
  }
};
var AssetName$1 = {
  name: "assetName",
  regex: "[-:a-zA-Z0-9]{5,73}",
  parameters: {
    delimiter: ":",
    values: {
      0: {
        name: "namespace",
        regex: "[-a-z0-9]{3,8}"
      },
      1: {
        name: "reference",
        regex: "[-a-zA-Z0-9]{1,64}"
      }
    }
  }
};
var CAIP19AssetType = {
  name: "assetType",
  regex: "[-:a-zA-Z0-9]{11,115}",
  parameters: {
    delimiter: "/",
    values: {
      0: CAIP2,
      1: AssetName$1
    }
  }
};
var CAIP19AssetId = {
  name: "assetId",
  regex: "[-:a-zA-Z0-9]{13,148}",
  parameters: {
    delimiter: "/",
    values: {
      0: CAIP2,
      1: AssetName$1,
      2: {
        name: "tokenId",
        regex: "[-a-zA-Z0-9]{1,32}"
      }
    }
  }
};
var CAIP = {
  "2": CAIP2,
  "10": CAIP10,
  "19": {
    assetName: AssetName$1,
    assetType: CAIP19AssetType,
    assetId: CAIP19AssetId
  }
};
function splitParams(id, spec) {
  return id.split(spec.parameters.delimiter);
}
function getParams(id, spec) {
  var arr = splitParams(id, spec);
  var params = {};
  arr.forEach(function(value, index) {
    params[spec.parameters.values[index].name] = value;
  });
  return params;
}
function joinParams(params, spec) {
  return Object.values(spec.parameters.values).map(function(parameter) {
    var param = params[parameter.name];
    return typeof param === "string" ? param : joinParams(param, parameter);
  }).join(spec.parameters.delimiter);
}
function isValidId(id, spec) {
  if (!new RegExp(spec.regex).test(id)) return false;
  var params = splitParams(id, spec);
  if (params.length !== Object.keys(spec.parameters.values).length) return false;
  var matches = params.map(function(param, index) {
    return new RegExp(spec.parameters.values[index].regex).test(param);
  }).filter(function(x) {
    return !!x;
  });
  if (matches.length !== params.length) return false;
  return true;
}
var ChainId = /* @__PURE__ */ function() {
  function ChainId2(params) {
    if (typeof params === "string") {
      params = ChainId2.parse(params);
    }
    this.namespace = params.namespace;
    this.reference = params.reference;
  }
  ChainId2.parse = function parse4(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    return new ChainId2(getParams(id, this.spec)).toJSON();
  };
  ChainId2.format = function format2(params) {
    return joinParams(params, this.spec);
  };
  var _proto = ChainId2.prototype;
  _proto.toString = function toString7() {
    return ChainId2.format(this.toJSON());
  };
  _proto.toJSON = function toJSON() {
    return {
      namespace: this.namespace,
      reference: this.reference
    };
  };
  return ChainId2;
}();
ChainId.spec = CAIP["2"];
var AccountId = /* @__PURE__ */ function() {
  function AccountId2(params) {
    if (typeof params === "string") {
      params = AccountId2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.address = params.address;
  }
  AccountId2.parse = function parse4(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    var _getParams = getParams(id, this.spec), namespace = _getParams.namespace, reference = _getParams.reference, address2 = _getParams.address;
    var chainId = new ChainId({
      namespace,
      reference
    });
    return new AccountId2({
      chainId,
      address: address2
    }).toJSON();
  };
  AccountId2.format = function format2(params) {
    var chainId = new ChainId(params.chainId);
    var splitParams2 = _extends({}, chainId.toJSON(), {
      address: params.address
    });
    return joinParams(splitParams2, this.spec);
  };
  var _proto = AccountId2.prototype;
  _proto.toString = function toString7() {
    return AccountId2.format(this.toJSON());
  };
  _proto.toJSON = function toJSON() {
    return {
      chainId: this.chainId.toJSON(),
      address: this.address
    };
  };
  return AccountId2;
}();
AccountId.spec = CAIP["10"];
var AssetName = /* @__PURE__ */ function() {
  function AssetName2(params) {
    if (typeof params === "string") {
      params = AssetName2.parse(params);
    }
    this.namespace = params.namespace;
    this.reference = params.reference;
  }
  AssetName2.parse = function parse4(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    return new AssetName2(getParams(id, this.spec)).toJSON();
  };
  AssetName2.format = function format2(params) {
    return joinParams(params, this.spec);
  };
  var _proto = AssetName2.prototype;
  _proto.toString = function toString7() {
    return AssetName2.format(this.toJSON());
  };
  _proto.toJSON = function toJSON() {
    return {
      namespace: this.namespace,
      reference: this.reference
    };
  };
  return AssetName2;
}();
AssetName.spec = CAIP["19"].assetName;
var AssetType = /* @__PURE__ */ function() {
  function AssetType2(params) {
    if (typeof params === "string") {
      params = AssetType2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.assetName = new AssetName(params.assetName);
  }
  AssetType2.parse = function parse4(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    return new AssetType2(getParams(id, this.spec)).toJSON();
  };
  AssetType2.format = function format2(params) {
    return joinParams(params, this.spec);
  };
  var _proto = AssetType2.prototype;
  _proto.toString = function toString7() {
    return AssetType2.format(this.toJSON());
  };
  _proto.toJSON = function toJSON() {
    return {
      chainId: this.chainId.toJSON(),
      assetName: this.assetName
    };
  };
  return AssetType2;
}();
AssetType.spec = CAIP["19"].assetType;
var AssetId = /* @__PURE__ */ function() {
  function AssetId2(params) {
    if (typeof params === "string") {
      params = AssetId2.parse(params);
    }
    this.chainId = new ChainId(params.chainId);
    this.assetName = new AssetName(params.assetName);
    this.tokenId = params.tokenId;
  }
  AssetId2.parse = function parse4(id) {
    if (!isValidId(id, this.spec)) {
      throw new Error("Invalid " + this.spec.name + " provided: " + id);
    }
    return new AssetId2(getParams(id, this.spec)).toJSON();
  };
  AssetId2.format = function format2(params) {
    return joinParams(params, this.spec);
  };
  var _proto = AssetId2.prototype;
  _proto.toString = function toString7() {
    return AssetId2.format(this.toJSON());
  };
  _proto.toJSON = function toJSON() {
    return {
      chainId: this.chainId.toJSON(),
      assetName: this.assetName.toJSON(),
      tokenId: this.tokenId
    };
  };
  return AssetId2;
}();
AssetId.spec = CAIP["19"].assetId;

// node_modules/codeco/dist/either.js
function isLeft(either) {
  return either._tag === "Left";
}
function left(e) {
  return { _tag: "Left", left: e };
}
function right(a) {
  return { _tag: "Right", right: a };
}
function getOrThrow(maybe) {
  if (isLeft(maybe))
    throw maybe.left;
  return maybe.right;
}

// node_modules/codeco/dist/linear.js
var StringTape = class {
  constructor(input) {
    __publicField(this, "position");
    __publicField(this, "input");
    this.input = input;
    this.position = 0;
  }
  get isEOF() {
    return this.position >= this.input.length;
  }
};
function failure(error, prev, tape) {
  tape.position = prev;
  return fail(error);
}
function fail(error) {
  return left(error);
}
function literal(value) {
  return function(tape) {
    const probe = tape.input.slice(tape.position, tape.position + value.length);
    if (probe === value) {
      tape.position += value.length;
      return right(value);
    } else {
      return fail(new Error(`Can not match literal "${value}"`));
    }
  };
}
function foldMap(combinator, fn) {
  return function map2(tape) {
    const prev = tape.position;
    const parsed = combinator(tape);
    if (isLeft(parsed)) {
      tape.position = prev;
      return parsed;
    }
    const mapped = fn(parsed.right);
    if (isLeft(mapped))
      return failure(mapped.left, prev, tape);
    return mapped;
  };
}
function map(combinator, fn) {
  return function(tape) {
    const prev = tape.position;
    const parsed = combinator(tape);
    if (isLeft(parsed)) {
      tape.position = prev;
      return parsed;
    }
    return right(fn(parsed.right));
  };
}
function match(pattern) {
  return function(tape) {
    const probe = tape.input.slice(tape.position).match(pattern);
    if (!probe)
      return fail(new Error(`Can not match ${pattern}`));
    tape.position += probe[0].length;
    return right(probe[0]);
  };
}
function joinSeq(...combinators) {
  return join2(seqA(combinators));
}
function join2(input, separator = "") {
  return function(tape) {
    const prev = tape.position;
    const results = input(tape);
    if (isLeft(results)) {
      tape.position = prev;
      return results;
    }
    return right(results.right.join(separator));
  };
}
function seq(...combinators) {
  return seqA(combinators);
}
function seqA(combinators) {
  return function(tape) {
    const prev = tape.position;
    const results = [];
    for (const combinator of combinators) {
      const r = combinator(tape);
      if (isLeft(r)) {
        return failure(r.left, prev, tape);
      }
      results.push(r.right);
    }
    return right(results);
  };
}
function option(combinator, otherwise) {
  return function option2(tape) {
    const result = combinator(tape);
    if (isLeft(result)) {
      return right(otherwise);
    } else {
      return result;
    }
  };
}
function choice(...combinators) {
  return function choice2(tape) {
    for (const combinator of combinators) {
      const prev = tape.position;
      const result = combinator(tape);
      if (isLeft(result)) {
        tape.position = prev;
      } else {
        return result;
      }
    }
    return fail(new Error(`Can not find any of ${combinators.map((m) => m.name).join(", ")}`));
  };
}
function sepBy(element, separator, min = 1, max = Infinity) {
  return function(tape) {
    const prev = tape.position;
    const results = [];
    const first = element(tape);
    if (isLeft(first))
      return failure(first.left, prev, tape);
    results.push(first.right);
    let returnPosition = tape.position;
    const handleLeft = (miss) => {
      if (results.length < min) {
        return failure(miss.left, returnPosition, tape);
      } else {
        tape.position = returnPosition;
        return right(results);
      }
    };
    while (!tape.isEOF && results.length < max) {
      returnPosition = tape.position;
      const sepE = separator(tape);
      if (isLeft(sepE))
        return handleLeft(sepE);
      const seqE = element(tape);
      if (isLeft(seqE))
        return handleLeft(seqE);
      results.push(seqE.right);
    }
    if (results.length < min) {
      return failure(new Error(`Got ${results}/${min} instances of ${element.name}`), prev, tape);
    }
    return right(results);
  };
}
function many(element, min = 1, max = Infinity) {
  return function many2(tape) {
    const prev = tape.position;
    const result = [];
    while (!tape.isEOF && result.length < max) {
      const entry = element(tape);
      if (isLeft(entry)) {
        if (result.length < min) {
          return failure(entry.left, prev, tape);
        } else {
          return right(result);
        }
      } else {
        result.push(entry.right);
      }
    }
    return right(result);
  };
}
function parseAll(combinator) {
  return function parseAll2(tape) {
    const prev = tape.position;
    const result = combinator(tape);
    if (isLeft(result))
      return result;
    if (!tape.isEOF) {
      return failure(new Error(`Consumed only ${tape.position} of input`), prev, tape);
    }
    return result;
  };
}

// node_modules/codeco/dist/context.js
function getFunctionName(f) {
  return f.displayName || f.name || `<function${f.length}>`;
}
function stringify(v) {
  if (typeof v === "function") {
    return getFunctionName(v);
  }
  if (typeof v === "number" && !isFinite(v)) {
    if (isNaN(v)) {
      return "NaN";
    }
    return v > 0 ? "Infinity" : "-Infinity";
  }
  return JSON.stringify(v);
}
function getContextPath(trail) {
  return `/` + trail.map(({ key, type }) => `${key}(${type.name})`).join("/");
}
var ValidationError = class extends Error {
  constructor(trail, message = `Invalid value ${stringify(trail[trail.length - 1].actual)} supplied to ${getContextPath(trail)}`) {
    super(message);
    __publicField(this, "trail");
    this.trail = trail;
  }
  get value() {
    return this.trail[this.trail.length - 1].actual;
  }
};
function identity4(value) {
  return value;
}
var Codec3 = class {
  constructor(name4) {
    __publicField(this, "_A");
    __publicField(this, "_I");
    __publicField(this, "_O");
    __publicField(this, "name");
    this.name = name4;
  }
  pipe(ab, name4 = `${this.name}\u2192${ab.name}`) {
    return new Type2(name4, ab.is, (i2, c) => {
      const e = this.decode(i2, c);
      if (isLeft(e)) {
        return e;
      }
      return ab.decode(e.right, c);
    }, this.encode === identity4 && ab.encode === identity4 ? identity4 : (b) => this.encode(ab.encode(b)));
  }
  parse(input, context = ThrowContext.root(this, input)) {
    const decodeResult = this.decode(input, context);
    if (isLeft(decodeResult))
      throw new Error(`Something is wrong: ${decodeResult} should be Right`);
    return decodeResult.right;
  }
};
var Type2 = class extends Codec3 {
  constructor(name4, is2, decode17, encode13) {
    super(name4);
    __publicField(this, "name");
    __publicField(this, "is");
    __publicField(this, "decode");
    __publicField(this, "encode");
    this.name = name4;
    this.is = is2;
    this.decode = decode17;
    this.encode = encode13;
  }
};
var ThrowContext = class _ThrowContext {
  constructor(trail) {
    __publicField(this, "trail");
    this.trail = trail;
  }
  static root(codec, input) {
    return new _ThrowContext([{ key: "", type: codec, actual: input }]);
  }
  failures(errors) {
    throw errors[0];
  }
  success(value) {
    return right(value);
  }
  failure(message) {
    throw new ValidationError(this.trail, message);
  }
  child(key, codec, input) {
    const nextTrail = this.trail.concat([{ key, type: codec, actual: input }]);
    return new _ThrowContext(nextTrail);
  }
};

// node_modules/codeco/dist/struct.js
var TrivialCodec = class extends Codec3 {
  constructor(name4, is2) {
    super(name4);
    __publicField(this, "is");
    __publicField(this, "encode", identity4);
    this.is = is2;
  }
  decode(input, context) {
    if (this.is(input)) {
      return context.success(input);
    } else {
      return context.failure();
    }
  }
};
var nullCodec = new TrivialCodec("null", (input) => input === null);
var undefinedCodec = new TrivialCodec("undefined", (input) => input === void 0);
var voidCodec = new TrivialCodec("void", (input) => input === void 0);
var string2 = new TrivialCodec("string", (input) => typeof input === "string");
var number2 = new TrivialCodec("number", (input) => typeof input === "number");
var boolean = new TrivialCodec("boolean", (input) => typeof input === "boolean");
var bigint = new TrivialCodec("bigint", (input) => typeof input === "bigint");
var unknown = new TrivialCodec("unknown", (input) => true);
var object = new TrivialCodec("object", (input) => Boolean(input) && typeof input === "object");
var unknownArray = new TrivialCodec("UnknownArray", (input) => Array.isArray(input));
var unknownRecord = new TrivialCodec("UnknownDictionary", (input) => {
  const isObjectLike = Boolean(input) && typeof input === "object";
  if (!isObjectLike)
    return false;
  const isArrayLike = Array.isArray(input);
  if (isArrayLike)
    return false;
  const proto = Object.getPrototypeOf(input);
  if (!proto)
    return true;
  const Ctor = Object.hasOwn(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Ctor.toString() == Object.toString();
});
var any = new TrivialCodec("any", (input) => true);
var never = new TrivialCodec("never", (input) => false);

// node_modules/codeco/dist/decoder.js
function decode14(codec, input) {
  const context = ThrowContext.root(codec, input);
  const decodeResult = codec.decode(input, context);
  if (isLeft(decodeResult))
    throw new Error(`Something is wrong: ${decodeResult} should be Right`);
  return decodeResult.right;
}

// node_modules/@didtools/siwx/dist/parsing/ip-address.js
var DOT = literal(".");
var COLON = literal(":");
var DCOLON = literal("::");
var h16 = match(/^([0-9a-fA-F]{2}){1,4}/);
var decOctet = match(/^(25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]\d)|(\d)/);
var ipv4Address = joinSeq(decOctet, DOT, decOctet, DOT, decOctet, DOT, decOctet);
var ls32 = choice(joinSeq(h16, COLON, h16), ipv4Address);
function makeIPv6Address() {
  const singlet = (repeat) => join2(many(joinSeq(h16, COLON), repeat, repeat));
  const leftPart = (max) => option(join2(sepBy(h16, COLON, 1, max), ":"), "");
  const a = seq(singlet(6), ls32);
  const b = seq(DCOLON, singlet(5), ls32);
  const c = seq(leftPart(1), DCOLON, singlet(4), ls32);
  const d = seq(leftPart(2), DCOLON, singlet(3), ls32);
  const e = seq(leftPart(3), DCOLON, singlet(2), ls32);
  const f = seq(leftPart(4), DCOLON, singlet(1), ls32);
  const g = seq(leftPart(5), DCOLON, ls32);
  const h = seq(leftPart(6), DCOLON, h16);
  const i2 = seq(leftPart(7), DCOLON);
  return join2(choice(a, b, c, d, e, f, g, h, i2));
}
var ipv6address = makeIPv6Address();
var ipLiteral = joinSeq(literal("["), ipv6address, literal("]"));

// node_modules/@didtools/siwx/dist/parsing/domain.js
var port = foldMap(match(/^\d+/), (digits) => {
  if (String(parseInt(digits, 10)) === digits) return right(digits);
  return left(new Error(`Invalid port ${digits}`));
});
var regName = match(/^([a-zA-Z0-9\-._~!$&'()*+,;=]|(%[a-fA-F0-9]{2}))*/);
var host = choice(ipLiteral, ipv4Address, regName);
var colonPort = joinSeq(literal(":"), port);
var dnsauthority = joinSeq(host, option(colonPort, ""));
var domain = foldMap(dnsauthority, (found) => {
  if (!found) return left(new Error(`domain can not be empty`));
  return right(found);
});

// node_modules/@didtools/siwx/dist/parsing/uri.js
var uri = foldMap(match(/^\S+/), (s) => {
  try {
    new URL(s);
    return right(s);
  } catch (e) {
    return left(new Error(`Invalid URI ${s}`));
  }
});

// node_modules/@didtools/siwx/dist/parsing/siwx-message.js
var LF = literal("\n");
var DIGITS = match(/^\d+/);
var network = match(/^\w+/);
var wantLine = seq(domain, literal(" wants you to sign in with your "), network, literal(" account:"));
var wantClause = map(wantLine, (line) => {
  return {
    domain: line[0],
    network: line[2]
  };
});
var address = match(/^\w+/);
var statementLine = match(/^[^\n]+/);
var statementClause = map(option(seq(statementLine, LF), void 0), (parsed) => {
  if (!parsed) return void 0;
  return parsed[0];
});
var uriClause = map(seq(literal("URI: "), uri, LF), (line) => line[1]);
var versionClause = map(seq(literal("Version: 1"), LF), () => "1");
var chainIdClause = map(seq(literal("Chain ID: "), DIGITS, LF), (line) => line[1]);
var nonce = match(/^[a-zA-Z0-9]{8,}/);
var nonceClause = map(seq(literal("Nonce: "), nonce, LF), (line) => line[1]);
var dateTimeMatch = match(/\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(Z|([+-](\d\d):(\d\d)))/);
var dateTime = foldMap(dateTimeMatch, (input) => {
  const isDate = Number.isFinite(Date.parse(input));
  if (isDate) {
    return right(input);
  } else {
    return left(new Error(`Invalid date-time ${input}`));
  }
});
var dateTimeClause = (name4) => {
  return map(seq(literal(name4), dateTime), (line) => line[1]);
};
var issuedAtClause = dateTimeClause("Issued At: ");
var expirationTimeClause = dateTimeClause("Expiration Time: ");
var notBeforeClause = dateTimeClause("Not Before: ");
var anyPchar = match(/^([a-zA-Z0-9-._~!$&'():@]|(%[a-fA-F0-9]{2}))*/);
var requestIdLine = seq(literal("Request ID: "), anyPchar, LF);
var requestIdClause = map(requestIdLine, (line) => line[1]);
var resource = uri;
var resourceLine = seq(literal("- "), resource);
var resourceClause = map(resourceLine, (line) => line[1]);
var resourcesSection = seq(literal("Resources:"), LF, option(sepBy(resourceClause, LF), []));
var resourcesClause = map(resourcesSection, (section) => section[2]);
var header = seq(wantClause, LF, address, LF);
var headerClause = map(header, (h) => {
  return {
    domain: h[0].domain,
    network: h[0].network,
    address: h[2]
  };
});
var mandatoryFields = map(seq(uriClause, versionClause, chainIdClause, nonceClause, issuedAtClause), (clauses) => {
  return {
    uri: clauses[0],
    version: clauses[1],
    chainId: clauses[2],
    nonce: clauses[3],
    issuedAt: clauses[4]
  };
});
var optionalExpirationTime = option(seq(LF, expirationTimeClause), void 0);
var optionalNotBefore = option(seq(LF, notBeforeClause), void 0);
var optionalRequestId = option(seq(LF, requestIdClause), void 0);
var optionalResources = map(option(seq(LF, resourcesClause), void 0), (line) => {
  return line ? line[1] : void 0;
});
var optionalFields = map(seq(optionalExpirationTime, optionalNotBefore, optionalRequestId, optionalResources), (fields) => {
  return {
    expirationTime: fields[0],
    notBefore: fields[1],
    requestId: fields[2],
    resources: fields[3]
  };
});
var siwxMessageRaw = seq(headerClause, LF, statementClause, LF, mandatoryFields, optionalFields);
var siwxMessage = map(siwxMessageRaw, (result) => {
  const header2 = result[0];
  const statement = result[2];
  const mandatory = result[4];
  const optional = result[5];
  return {
    domain: header2.domain,
    network: header2.network,
    address: header2.address,
    statement,
    uri: mandatory.uri,
    version: mandatory.version,
    chainId: mandatory.chainId,
    nonce: mandatory.nonce,
    issuedAt: mandatory.issuedAt,
    resources: optional.resources
  };
});

// node_modules/@didtools/siwx/dist/fields.js
function toField(combinator) {
  const parser = parseAll(combinator);
  return function(input) {
    return getOrThrow(parser(new StringTape(input)));
  };
}
var toDomainString = toField(domain);
var toDateTimeString = toField(dateTime);
var toURIString = toField(uri);
function toNonEmptyString(input, name4) {
  if (input) return input;
  throw new Error(`Expect non-empty string for "${name4}" field`);
}
function toVersionString(input) {
  if (String(input) !== "1") {
    throw new Error(`Invalid version string: ${input}`);
  }
  return "1";
}
function toChainIdString(input) {
  return String(input);
}
function toNonceString(input) {
  return toField(nonce)(String(input));
}

// node_modules/@didtools/siwx/dist/siwx-message.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function resourcesList(resources) {
  return resources.map((r) => `- ${r}`).join(`
`);
}
var SiwxMessage = class {
  toString() {
    return toString5(this);
  }
  constructor(fields) {
    _define_property(this, "domain", void 0);
    _define_property(this, "network", void 0);
    _define_property(this, "address", void 0);
    _define_property(this, "statement", void 0);
    _define_property(this, "uri", void 0);
    _define_property(this, "version", void 0);
    _define_property(this, "chainId", void 0);
    _define_property(this, "nonce", void 0);
    _define_property(this, "issuedAt", void 0);
    _define_property(this, "expirationTime", void 0);
    _define_property(this, "notBefore", void 0);
    _define_property(this, "requestId", void 0);
    _define_property(this, "resources", void 0);
    this.domain = toDomainString(fields.domain);
    this.network = toNonEmptyString(fields.network, "network");
    this.address = toNonEmptyString(fields.address, "address");
    this.statement = mapUndefined(fields.statement, (s) => toNonEmptyString(s, "statement"));
    this.uri = toURIString(fields.uri);
    this.version = toVersionString(fields.version || "1");
    this.chainId = toChainIdString(fields.chainId);
    this.nonce = toNonceString(fields.nonce);
    this.issuedAt = toDateTimeString(fields.issuedAt);
    this.expirationTime = mapUndefined(fields.expirationTime, toDateTimeString);
    this.notBefore = mapUndefined(fields.notBefore, toDateTimeString);
    this.requestId = mapUndefined(fields.requestId, (s) => toNonEmptyString(s, "requestId"));
    this.resources = mapUndefined(fields.resources, (resources) => resources.map(toURIString));
  }
};
_define_property(SiwxMessage, "fromString", fromString5);
_define_property(SiwxMessage, "fromStringSafe", fromStringSafe);
function fromStringSafe(input) {
  const parser = parseAll(siwxMessage);
  const fields = parser(new StringTape(input));
  if (isLeft(fields)) return fields;
  return right(new SiwxMessage(fields.right));
}
function fromString5(input) {
  return getOrThrow(fromStringSafe(input));
}
function toString5(message) {
  const want = `${message.domain} wants you to sign in with your ${message.network} account:`;
  const address2 = message.address;
  const statement = message.statement;
  const uri2 = `URI: ${message.uri}`;
  const version3 = `Version: ${message.version}`;
  const chainId = `Chain ID: ${message.chainId}`;
  const nonce2 = `Nonce: ${message.nonce}`;
  const issuedAt = `Issued At: ${message.issuedAt}`;
  const expirationTime = message.expirationTime ? `Expiration Time: ${message.expirationTime}` : void 0;
  const notBefore = message.notBefore ? `Not Before: ${message.notBefore}` : void 0;
  const requestId = message.requestId ? `Request ID: ${message.requestId}` : void 0;
  const resources = message.resources ? `Resources:
${resourcesList(message.resources)}` : void 0;
  let header2 = `${want}
${address2}

`;
  if (statement) header2 += `${statement}
`;
  return [
    header2,
    uri2,
    version3,
    chainId,
    nonce2,
    issuedAt,
    expirationTime,
    notBefore,
    requestId,
    resources
  ].filter(Boolean).join("\n");
}
function mapUndefined(field, fn) {
  if (field !== void 0) {
    return fn(field);
  } else {
    return void 0;
  }
}

// node_modules/@didtools/cacao/dist/siwx/siwx.js
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ErrorTypes;
(function(ErrorTypes2) {
  ErrorTypes2["INVALID_SIGNATURE"] = "Invalid signature.";
  ErrorTypes2["EXPIRED_MESSAGE"] = "Expired message.";
  ErrorTypes2["MALFORMED_SESSION"] = "Malformed session.";
})(ErrorTypes || (ErrorTypes = {}));
var SignatureType;
(function(SignatureType2) {
  SignatureType2["PERSONAL_SIGNATURE"] = "Personal signature";
})(SignatureType || (SignatureType = {}));
var SiwxMessage2 = class {
  static fromCacao(cacao) {
    const account = AccountId.parse(cacao.p.iss.replace("did:pkh:", ""));
    const siwx = new this({
      domain: cacao.p.domain,
      address: account.address,
      uri: cacao.p.aud,
      version: cacao.p.version,
      chainId: new ChainId(account.chainId).reference
    });
    if (cacao.p.statement) siwx.statement = cacao.p.statement;
    if (cacao.p.nonce) siwx.nonce = cacao.p.nonce;
    if (cacao.p.iat) siwx.issuedAt = cacao.p.iat;
    if (cacao.p.exp) siwx.expirationTime = cacao.p.exp;
    if (cacao.p.nbf) siwx.notBefore = cacao.p.nbf;
    if (cacao.p.requestId) siwx.requestId = cacao.p.requestId;
    if (cacao.p.resources) siwx.resources = cacao.p.resources;
    if (cacao.s) {
      if (cacao.s.s) siwx.signature = cacao.s.s;
      if (cacao.s.t === "eip191") siwx.type = "Personal signature";
    }
    return siwx;
  }
  toMessage(chain3, address2) {
    return asString(this, chain3, address2);
  }
  constructor(param) {
    _define_property2(this, "domain", void 0);
    _define_property2(this, "address", void 0);
    _define_property2(this, "statement", void 0);
    _define_property2(this, "uri", void 0);
    _define_property2(this, "version", void 0);
    _define_property2(this, "nonce", void 0);
    _define_property2(this, "issuedAt", void 0);
    _define_property2(this, "expirationTime", void 0);
    _define_property2(this, "notBefore", void 0);
    _define_property2(this, "requestId", void 0);
    _define_property2(this, "chainId", void 0);
    _define_property2(this, "resources", void 0);
    _define_property2(this, "signature", void 0);
    _define_property2(this, "type", void 0);
    if (typeof param === "string") {
      const parsedMessage = fromString5(param);
      this.domain = parsedMessage.domain;
      this.address = parsedMessage.address;
      this.statement = parsedMessage.statement;
      this.uri = parsedMessage.uri;
      this.version = parsedMessage.version;
      this.nonce = parsedMessage.nonce;
      this.issuedAt = parsedMessage.issuedAt;
      this.expirationTime = parsedMessage.expirationTime;
      this.notBefore = parsedMessage.notBefore;
      this.requestId = parsedMessage.requestId;
      this.chainId = parsedMessage.chainId;
      this.resources = parsedMessage.resources;
    } else {
      Object.assign(this, param);
    }
  }
};
function asLegacyChainIdString(message, chainName) {
  const header2 = `${message.domain} wants you to sign in with your ${chainName} account:`;
  const uriField = `URI: ${message.uri}`;
  let prefix = [
    header2,
    message.address
  ].join("\n");
  const versionField = `Version: ${message.version}`;
  if (!message.nonce) {
    message.nonce = (Math.random() + 1).toString(36).substring(4);
  }
  const nonceField = `Nonce: ${message.nonce}`;
  const suffixArray = [
    uriField,
    versionField,
    nonceField
  ];
  if (message.issuedAt) {
    Date.parse(message.issuedAt);
  }
  message.issuedAt = message.issuedAt ? message.issuedAt : (/* @__PURE__ */ new Date()).toISOString();
  suffixArray.push(`Issued At: ${message.issuedAt}`);
  if (message.expirationTime) {
    const expiryField = `Expiration Time: ${message.expirationTime}`;
    suffixArray.push(expiryField);
  }
  if (message.notBefore) {
    suffixArray.push(`Not Before: ${message.notBefore}`);
  }
  if (message.requestId) {
    suffixArray.push(`Request ID: ${message.requestId}`);
  }
  if (message.chainId) {
    suffixArray.push(`Chain ID: ${message.chainId}`);
  }
  if (message.resources) {
    suffixArray.push([
      `Resources:`,
      ...message.resources.map((x) => `- ${x}`)
    ].join("\n"));
  }
  const suffix = suffixArray.join("\n");
  if (message.statement) {
    prefix = [
      prefix,
      message.statement
    ].join("\n\n");
  }
  return [
    prefix,
    suffix
  ].join("\n\n");
}
function asString(message, chainName, address2) {
  const header2 = `${message.domain} wants you to sign in with your ${chainName} account:`;
  const uriField = `URI: ${message.uri}`;
  let prefix = [
    header2,
    address2 || message.address
  ].join("\n");
  const versionField = `Version: ${message.version}`;
  if (!message.nonce) {
    message.nonce = (Math.random() + 1).toString(36).substring(4);
  }
  const nonceField = `Nonce: ${message.nonce}`;
  const chainIdField = `Chain ID: ${message.chainId}`;
  const suffixArray = [
    uriField,
    versionField,
    chainIdField,
    nonceField
  ];
  if (message.issuedAt) {
    Date.parse(message.issuedAt);
  }
  message.issuedAt = message.issuedAt ? message.issuedAt : (/* @__PURE__ */ new Date()).toISOString();
  suffixArray.push(`Issued At: ${message.issuedAt}`);
  if (message.expirationTime) {
    const expiryField = `Expiration Time: ${message.expirationTime}`;
    suffixArray.push(expiryField);
  }
  if (message.notBefore) {
    suffixArray.push(`Not Before: ${message.notBefore}`);
  }
  if (message.requestId) {
    suffixArray.push(`Request ID: ${message.requestId}`);
  }
  if (message.resources && message.resources.length >= 1) {
    suffixArray.push([
      `Resources:`,
      ...message.resources.map((x) => `- ${x}`)
    ].join("\n"));
  }
  const suffix = suffixArray.join("\n");
  if (message.statement) {
    prefix = [
      prefix,
      message.statement
    ].join("\n\n");
  }
  return [
    prefix,
    suffix
  ].join("\n\n");
}

// node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);
var wrapper_default = import_websocket.default;

// node_modules/viem/_esm/index.js
init_getAddress();

// node_modules/@didtools/cacao/dist/siwx/siwe.js
var SiweMessage = class extends SiwxMessage2 {
  /**
  * This function can be used to retrieve an EIP-4361 formated message for
  * signature, although you can call it directly it's advised to use
  * [signMessage()] instead which will resolve to the correct method based
  * on the [type] attribute of this object, in case of other formats being
  * implemented.
  * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.
  */
  toMessage() {
    return super.toMessage("Ethereum");
  }
  toMessageEip55() {
    const address2 = checksumAddress(this.address);
    return super.toMessage("Ethereum", address2);
  }
  /**
  * This method parses all the fields in the object and creates a sign
  * message according with the type defined.
  * @returns {string} Returns a message ready to be signed according with the
  * type defined in the object.
  */
  signMessage({ eip55 } = {}) {
    let message;
    switch (this.type) {
      case SignatureType.PERSONAL_SIGNATURE: {
        message = eip55 ? this.toMessageEip55() : this.toMessage();
        break;
      }
      default: {
        message = eip55 ? this.toMessageEip55() : this.toMessage();
        break;
      }
    }
    return message;
  }
};

// node_modules/uint8arrays/dist/src/alloc.node.js
var import_node_buffer = require("buffer");

// node_modules/uint8arrays/dist/src/util/as-uint8array.node.js
function asUint8Array2(buf2) {
  return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
}

// node_modules/uint8arrays/dist/src/alloc.node.js
function allocUnsafe2(size2 = 0) {
  return asUint8Array2(import_node_buffer.Buffer.allocUnsafe(size2));
}

// node_modules/uint8arrays/dist/src/compare.node.js
var import_node_buffer2 = require("buffer");

// node_modules/uint8arrays/dist/src/concat.node.js
var import_node_buffer3 = require("buffer");
function concat3(arrays, length3) {
  return asUint8Array2(import_node_buffer3.Buffer.concat(arrays, length3));
}

// node_modules/uint8arrays/dist/src/from-string.node.js
var import_node_buffer4 = require("buffer");

// node_modules/multiformats/dist/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102 = baseX2({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/dist/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc46482({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46482({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/dist/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base22
});
var base22 = rfc46482({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = alphabet3.reduce((p, c, i2) => {
  p[i2] = c;
  return p;
}, []);
var alphabetCharsToBytes2 = alphabet3.reduce((p, c, i2) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c}`);
  }
  p[codePoint] = i2;
  return p;
}, []);
function encode12(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode15(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes2[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from3({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode12,
  decode: decode15
});

// node_modules/multiformats/dist/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc46482({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/dist/src/bases/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity5
});
var identity5 = from3({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString3(buf2),
  decode: (str) => fromString3(str)
});

// node_modules/multiformats/dist/src/codecs/json.js
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// node_modules/multiformats/dist/src/basics.js
var bases2 = { ...identity_exports4, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_exports2, ...identity_exports3 };

// node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name4, prefix, encode13, decode17) {
  return {
    name: name4,
    prefix,
    encoder: {
      name: name4,
      prefix,
      encode: encode13
    },
    decoder: {
      decode: decode17
    }
  };
}
var string3 = createCodec2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder3 = new TextEncoder();
  return encoder3.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf2) => {
  let string4 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string4 += String.fromCharCode(buf2[i2]);
  }
  return string4;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe2(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES2 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases2.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases2
};
var bases_default2 = BASES2;

// node_modules/uint8arrays/dist/src/from-string.node.js
function fromString6(string4, encoding = "utf8") {
  const base4 = bases_default2[encoding];
  if (base4 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if (encoding === "utf8" || encoding === "utf-8") {
    return asUint8Array2(import_node_buffer4.Buffer.from(string4, "utf-8"));
  }
  return base4.decoder.decode(`${base4.prefix}${string4}`);
}

// node_modules/uint8arrays/dist/src/to-string.node.js
var import_node_buffer5 = require("buffer");
function toString6(array, encoding = "utf8") {
  const base4 = bases_default2[encoding];
  if (base4 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if (encoding === "utf8" || encoding === "utf-8") {
    return import_node_buffer5.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base4.encoder.encode(array).substring(1);
}

// node_modules/@didtools/cacao/dist/cacao.js
var CLOCK_SKEW_DEFAULT_SEC = 5 * 60;
var LEGACY_CHAIN_ID_REORG_DATE = (/* @__PURE__ */ new Date("2022-09-20")).valueOf();
var Cacao;
(function(Cacao2) {
  function fromSiweMessage(siweMessage) {
    const cacao = {
      h: {
        t: "eip4361"
      },
      p: {
        domain: siweMessage.domain,
        iat: siweMessage.issuedAt,
        iss: `did:pkh:eip155:${siweMessage.chainId}:${siweMessage.address}`,
        aud: siweMessage.uri,
        version: siweMessage.version,
        nonce: siweMessage.nonce
      }
    };
    if (siweMessage.signature) {
      cacao.s = {
        t: "eip191",
        s: siweMessage.signature
      };
    }
    if (siweMessage.notBefore) {
      cacao.p.nbf = siweMessage.notBefore;
    }
    if (siweMessage.expirationTime) {
      cacao.p.exp = siweMessage.expirationTime;
    }
    if (siweMessage.statement) {
      cacao.p.statement = siweMessage.statement;
    }
    if (siweMessage.requestId) {
      cacao.p.requestId = siweMessage.requestId;
    }
    if (siweMessage.resources) {
      cacao.p.resources = siweMessage.resources;
    }
    return cacao;
  }
  Cacao2.fromSiweMessage = fromSiweMessage;
  function fromSiwsMessage(siwsMessage) {
    const cacao = {
      h: {
        t: "caip122"
      },
      p: {
        domain: siwsMessage.domain,
        iat: siwsMessage.issuedAt,
        iss: `did:pkh:solana:${siwsMessage.chainId}:${siwsMessage.address}`,
        aud: siwsMessage.uri,
        version: siwsMessage.version,
        nonce: siwsMessage.nonce
      }
    };
    if (siwsMessage.signature) {
      cacao.s = {
        // https://github.com/solana-labs/wallet-adapter/issues/179
        t: "solana:ed25519",
        s: siwsMessage.signature
      };
    }
    if (siwsMessage.notBefore) {
      cacao.p.nbf = siwsMessage.notBefore;
    }
    if (siwsMessage.expirationTime) {
      cacao.p.exp = siwsMessage.expirationTime;
    }
    if (siwsMessage.statement) {
      cacao.p.statement = siwsMessage.statement;
    }
    if (siwsMessage.requestId) {
      cacao.p.requestId = siwsMessage.requestId;
    }
    if (siwsMessage.resources) {
      cacao.p.resources = siwsMessage.resources;
    }
    return cacao;
  }
  Cacao2.fromSiwsMessage = fromSiwsMessage;
  function fromSiwTezosMessage(siwTezosMessage) {
    const cacao = {
      h: {
        t: "caip122"
      },
      p: {
        domain: siwTezosMessage.domain,
        iat: siwTezosMessage.issuedAt,
        iss: `did:pkh:tezos:${siwTezosMessage.chainId}:${siwTezosMessage.address}`,
        aud: siwTezosMessage.uri,
        version: siwTezosMessage.version,
        nonce: siwTezosMessage.nonce
      }
    };
    if (siwTezosMessage.signature) {
      cacao.s = {
        t: "tezos:ed25519",
        s: siwTezosMessage.signature
      };
    }
    if (siwTezosMessage.notBefore) {
      cacao.p.nbf = siwTezosMessage.notBefore;
    }
    if (siwTezosMessage.expirationTime) {
      cacao.p.exp = siwTezosMessage.expirationTime;
    }
    if (siwTezosMessage.statement) {
      cacao.p.statement = siwTezosMessage.statement;
    }
    if (siwTezosMessage.requestId) {
      cacao.p.requestId = siwTezosMessage.requestId;
    }
    if (siwTezosMessage.resources) {
      cacao.p.resources = siwTezosMessage.resources;
    }
    return cacao;
  }
  Cacao2.fromSiwTezosMessage = fromSiwTezosMessage;
  function fromSiwStacksMessage(siwStacksMessage) {
    const cacao = {
      h: {
        t: "caip122"
      },
      p: {
        domain: siwStacksMessage.domain,
        iat: siwStacksMessage.issuedAt,
        iss: `did:pkh:stacks:${siwStacksMessage.chainId}:${siwStacksMessage.address}`,
        aud: siwStacksMessage.uri,
        version: siwStacksMessage.version,
        nonce: siwStacksMessage.nonce
      }
    };
    if (siwStacksMessage.signature) {
      cacao.s = {
        t: "stacks:secp256k1",
        s: siwStacksMessage.signature
      };
    }
    if (siwStacksMessage.notBefore) {
      cacao.p.nbf = siwStacksMessage.notBefore;
    }
    if (siwStacksMessage.expirationTime) {
      cacao.p.exp = siwStacksMessage.expirationTime;
    }
    if (siwStacksMessage.statement) {
      cacao.p.statement = siwStacksMessage.statement;
    }
    if (siwStacksMessage.requestId) {
      cacao.p.requestId = siwStacksMessage.requestId;
    }
    if (siwStacksMessage.resources) {
      cacao.p.resources = siwStacksMessage.resources;
    }
    return cacao;
  }
  Cacao2.fromSiwStacksMessage = fromSiwStacksMessage;
  async function fromBlockBytes(bytes6) {
    const block = await decode11({
      bytes: bytes6,
      codec: src_exports,
      hasher: sha2565
    });
    return block.value;
  }
  Cacao2.fromBlockBytes = fromBlockBytes;
  async function verify(cacao, opts = {}) {
    assertSigned(cacao);
    const verify2 = opts.verifiers[cacao.s.t];
    if (!verify2) throw new Error("Unsupported CACAO signature type, register the needed verifier");
    return verify2(cacao, opts);
  }
  Cacao2.verify = verify;
})(Cacao || (Cacao = {}));
var CacaoBlock;
(function(CacaoBlock2) {
  function fromCacao(cacao) {
    return encode8({
      value: cacao,
      codec: src_exports,
      hasher: sha2565
    });
  }
  CacaoBlock2.fromCacao = fromCacao;
})(CacaoBlock || (CacaoBlock = {}));
function assertSigned(cacao) {
  if (cacao.s === null || cacao.s === void 0) {
    throw new Error(`CACAO does not have a signature`);
  }
}
function verifyTimeChecks(cacao, options) {
  const atTime = options.atTime ? options.atTime.getTime() : Date.now();
  const clockSkew = (options.clockSkewSecs ?? CLOCK_SKEW_DEFAULT_SEC) * 1e3;
  if (Date.parse(cacao.p.iat) > atTime + clockSkew || Date.parse(cacao.p.nbf) > atTime + clockSkew) {
    throw new Error(`CACAO is not valid yet`);
  }
  const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1e3 : 0;
  if (!options.disableExpirationCheck && Date.parse(cacao.p.exp) + phaseOutMS + clockSkew < atTime) {
    throw new Error(`CACAO has expired`);
  }
}

// node_modules/@didtools/pkh-ethereum/dist/verifier.js
function getEIP191Verifier() {
  return {
    // eslint-disable-next-line @typescript-eslint/require-await
    eip191: async (cacao, opts) => {
      verifyEIP191Signature(cacao, opts);
    }
  };
}
var LEGACY_CHAIN_ID_REORG_DATE2 = (/* @__PURE__ */ new Date("2022-09-20")).valueOf();
var MESSAGE_PREFIX = "Ethereum Signed Message:\n";
function verifyMessage(message, signature) {
  const effectiveMessage = typeof message === "string" ? utf8ToBytes(message) : message;
  const digest3 = keccak_256(concatBytes(utf8ToBytes(MESSAGE_PREFIX), utf8ToBytes(String(message.length)), effectiveMessage));
  const signatureBytes = hexToBytes(signature.replace(/^0x/, ""));
  let v = signatureBytes[64];
  if (v === 0 || v === 1) v += 27;
  const publicKey = secp256k1.Signature.fromCompact(signatureBytes.slice(0, 64)).addRecoveryBit(v - 27).recoverPublicKey(digest3).toRawBytes(false);
  const recoveredAddress = keccak_256(publicKey.subarray(1)).subarray(-20);
  return `0x${bytesToHex(recoveredAddress)}`;
}
function verifyEIP191Signature(cacao, options) {
  assertSigned(cacao);
  verifyTimeChecks(cacao, options);
  const issuer = AccountId.parse(cacao.p.iss.replace("did:pkh:", "")).address.toLowerCase();
  let recovered = verifyMessage(SiweMessage.fromCacao(cacao).toMessage(), cacao.s.s);
  if (recovered !== issuer) {
    recovered = verifyMessage(SiweMessage.fromCacao(cacao).toMessageEip55(), cacao.s.s);
  }
  if (recovered !== issuer && Date.parse(cacao.p.iat) <= LEGACY_CHAIN_ID_REORG_DATE2) {
    recovered = verifyMessage(asLegacyChainIdString(SiweMessage.fromCacao(cacao), "Ethereum"), cacao.s.s);
  }
  if (recovered !== issuer) {
    throw new Error(`Signature does not belong to issuer`);
  }
}

// node_modules/@didtools/codecs/dist/binary.js
function isUint8Array(input) {
  return input instanceof Uint8Array;
}
var uint8array = new TrivialCodec("Uint8Array", isUint8Array);
function createUint8ArrayAsString(encoding) {
  return new Type2(`Uint8Array-as-${String(encoding)}`, isUint8Array, (input, context) => {
    try {
      return context.success(fromString6(input, encoding));
    } catch {
      return context.failure();
    }
  }, (value) => toString6(value, encoding));
}
var uint8ArrayAsBase64 = createUint8ArrayAsString("base64");
var uint8ArrayAsBase64pad = createUint8ArrayAsString("base64pad");
var uint8ArrayAsBase64url = createUint8ArrayAsString("base64url");

// node_modules/dids/dist/random-string.util.js
var import_random = __toESM(require_random2(), 1);
function randomString() {
  return toString6((0, import_random.randomBytes)(16), "base64");
}

// node_modules/dids/dist/utils.js
function encodeBase64(bytes6) {
  return uint8ArrayAsBase64pad.encode(bytes6);
}
function encodeBase64Url(bytes6) {
  return uint8ArrayAsBase64url.encode(bytes6);
}
function decodeBase64(s) {
  return decode14(uint8ArrayAsBase64pad, s);
}
function base64urlToJSON(s) {
  const decoded = decode14(uint8ArrayAsBase64url, s);
  return JSON.parse(toString6(decoded));
}
function fromDagJWS(jws) {
  if (jws.signatures.length > 1) throw new Error("Cant convert to compact jws");
  return `${jws.signatures[0].protected}.${jws.payload}.${jws.signatures[0].signature}`;
}
function didWithTime(did, atTime) {
  if (atTime) {
    const versionTime = atTime.toISOString().split(".")[0] + "Z";
    return `${did}?versionTime=${versionTime}`;
  } else {
    return did;
  }
}
function extractControllers(controllerProperty) {
  if (controllerProperty) {
    if (Array.isArray(controllerProperty)) {
      return controllerProperty;
    } else {
      return [
        controllerProperty
      ];
    }
  } else {
    return [];
  }
}

// node_modules/dids/dist/did.js
function _define_property3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var verifiers = {
  ...getEIP191Verifier()
};
function isResolver(resolver) {
  return "registry" in resolver && "cache" in resolver;
}
function issuerEquals(dida, didb) {
  if (dida === didb) return true;
  if (dida.startsWith("did:pkh:eip155:")) {
    return dida.toLowerCase() === didb.toLowerCase();
  }
  return false;
}
var DID = class _DID {
  /**
  *  Get attached capability
  */
  get capability() {
    if (!this._capability) {
      throw new Error("DID has no capability attached");
    }
    return this._capability;
  }
  /**
  * Check if the DID has a capability attached
  */
  get hasCapability() {
    return this._capability != null;
  }
  /**
  * Get parent DID, parent DID is the capability issuer
  */
  get parent() {
    if (!this._parentId) {
      throw new Error("DID has no parent DID");
    }
    return this._parentId;
  }
  /**
  * Check if DID has parent DID
  */
  get hasParent() {
    return this._parentId != null;
  }
  /**
  * Get the DID identifier of the user.
  */
  get id() {
    if (this._id == null) {
      throw new Error("DID is not authenticated");
    }
    return this._id;
  }
  /**
  * Check if user is authenticated.
  */
  get authenticated() {
    return this._id != null;
  }
  /**
  * Attach a capability to the DID instance
  * @param cap The capability to attach
  * @returns A new DID instance with the capability attached
  */
  withCapability(cap) {
    return new _DID({
      provider: this._client?.connection,
      resolver: this._resolver,
      capability: cap,
      parent: this._parentId
    });
  }
  /**
  * Set the DID provider of this instance.
  * Only callable if provider not already set.
  *
  * @param provider    The DIDProvider to use
  */
  setProvider(provider) {
    if (this._client == null) {
      this._client = new RPCClient(provider);
    } else if (this._client.connection !== provider) {
      throw new Error("A different provider is already set, create a new DID instance to use another provider");
    }
  }
  /**
  * Set the DID-resolver user by this instance
  *
  * @param resolver            Either a Resolver instance or an object with specific resolvers
  * @param resolverOptions     Options to use for the created resolver. Will be ignored if a Resolver instance is passed
  */
  setResolver(resolver, resolverOptions) {
    this._resolver = isResolver(resolver) ? resolver : new Resolver(resolver, resolverOptions);
  }
  /**
  * Authenticate the user.
  */
  async authenticate({ provider, paths = [], aud } = {}) {
    if (provider != null) {
      this.setProvider(provider);
    }
    if (this._client == null) {
      throw new Error("No provider available");
    }
    const nonce2 = randomString();
    const jws = await this._client.request("did_authenticate", {
      nonce: nonce2,
      aud,
      paths
    });
    const { kid } = await this.verifyJWS(jws);
    const payload = base64urlToJSON(jws.payload);
    if (!kid.includes(payload.did)) throw new Error("Invalid authencation response, kid mismatch");
    if (payload.nonce !== nonce2) throw new Error("Invalid authencation response, wrong nonce");
    if (payload.aud !== aud) throw new Error("Invalid authencation response, wrong aud");
    if (payload.exp < Date.now() / 1e3) throw new Error("Invalid authencation response, expired");
    this._id = payload.did;
    return this._id;
  }
  /**
  * Create a JWS encoded signature over the given payload.
  * Will be signed by the currently authenticated DID.
  *
  * @param payload             The payload to sign
  * @param options             Optional parameters
  */
  async createJWS(payload, options = {}) {
    if (this._client == null) throw new Error("No provider available");
    if (this._id == null) throw new Error("DID is not authenticated");
    if (this._capability) {
      const exp = this._capability.p.exp;
      if (exp && Date.parse(exp) < Date.now()) {
        throw new Error("Capability is expired, cannot create a valid signature");
      }
      const cacaoBlock = await CacaoBlock.fromCacao(this._capability);
      const capCID = CID2.asCID(cacaoBlock.cid);
      if (!capCID) {
        throw new Error(`Capability CID of the JWS cannot be set to the capability payload cid as they are incompatible`);
      }
      options.protected = options.protected || {};
      options.protected.cap = `ipfs://${capCID?.toString()}`;
    }
    const { jws } = await this._client.request("did_createJWS", {
      did: this._id,
      ...options,
      payload
    });
    return jws;
  }
  /**
  * Create an IPFS compatibe DagJWS encoded signature over the given payload.
  * Will be signed by the currently authenticated DID.
  *
  * @param payload             The payload to sign, may include ipld links
  * @param options             Optional parameters
  */
  async createDagJWS(payload, options = {}) {
    const { cid, linkedBlock } = await encodePayload(payload);
    const payloadCid = encodeBase64Url(cid.bytes);
    Object.assign(options, {
      linkedBlock: encodeBase64(linkedBlock)
    });
    const jws = await this.createJWS(payloadCid, options);
    const compatibleCID = CID2.asCID(cid);
    if (!compatibleCID) {
      throw new Error("CID of the JWS cannot be set to the encoded payload cid as they are incompatible");
    }
    jws.link = compatibleCID;
    if (this._capability) {
      const cacaoBlock = await CacaoBlock.fromCacao(this._capability);
      return {
        jws,
        linkedBlock,
        cacaoBlock: cacaoBlock.bytes
      };
    }
    return {
      jws,
      linkedBlock
    };
  }
  /**
  * Verify a JWS. Uses the 'kid' in the header as the way to resolve
  * the author public key.
  *
  * @param jws                 The JWS to verify
  * @param options             Optional arguments for verification
  * @returns                   Information about the signed JWS
  */
  async verifyJWS(jws, options = {}) {
    options = Object.assign({
      verifiers
    }, options);
    if (typeof jws !== "string") jws = fromDagJWS(jws);
    const kid = base64urlToJSON(jws.split(".")[0]).kid;
    if (!kid) throw new Error('No "kid" found in jws');
    const didResolutionResult = await this.resolve(kid);
    const timecheckEnabled = !options.disableTimecheck;
    if (timecheckEnabled) {
      const nextUpdate = didResolutionResult.didDocumentMetadata?.nextUpdate;
      if (nextUpdate) {
        const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1e3 : 0;
        const revocationTime = new Date(nextUpdate).valueOf() + phaseOutMS;
        const isEarlier = options.atTime && options.atTime.getTime() < revocationTime;
        const isLater = !isEarlier;
        if (isLater) {
          throw new Error(`invalid_jws: signature authored with a revoked DID version: ${kid}`);
        }
      }
      const updated = didResolutionResult.didDocumentMetadata?.updated;
      if (updated && options.atTime && options.atTime.getTime() < new Date(updated).valueOf()) {
        throw new Error(`invalid_jws: signature authored before creation of DID version: ${kid}`);
      }
    }
    const signerDid = didResolutionResult.didDocument?.id;
    if (options.issuer && options.capability && issuerEquals(options.issuer, options.capability?.p.iss) && signerDid === options.capability.p.aud) {
      if (!options.verifiers) throw new Error("Registered verifiers needed for CACAO");
      await Cacao.verify(options.capability, {
        disableExpirationCheck: options.disableTimecheck,
        atTime: options.atTime ? options.atTime : void 0,
        revocationPhaseOutSecs: options.revocationPhaseOutSecs,
        verifiers: options.verifiers ?? {}
      });
    } else if (options.issuer && options.issuer !== signerDid) {
      const issuerUrl = didWithTime(options.issuer, options.atTime);
      const issuerResolution = await this.resolve(issuerUrl);
      const controllerProperty = issuerResolution.didDocument?.controller;
      const controllers = extractControllers(controllerProperty);
      if (options.capability?.s && options.capability.p.aud === signerDid && controllers.includes(options.capability.p.iss)) {
        await Cacao.verify(options.capability, {
          atTime: options.atTime ? options.atTime : void 0,
          revocationPhaseOutSecs: options.revocationPhaseOutSecs,
          verifiers: options.verifiers ?? {}
        });
      } else {
        const signerIsController = signerDid ? controllers.includes(signerDid) : false;
        if (!signerIsController) {
          throw new Error(`invalid_jws: not a valid verificationMethod for issuer: ${kid}`);
        }
      }
    }
    const publicKeys = didResolutionResult.didDocument?.verificationMethod || [];
    verifyJWS(jws, publicKeys);
    let payload;
    try {
      payload = base64urlToJSON(jws.split(".")[1]);
    } catch (e) {
    }
    return {
      kid,
      payload,
      didResolutionResult
    };
  }
  /**
  * Create a JWE encrypted to the given recipients.
  *
  * @param cleartext           The cleartext to be encrypted
  * @param recipients          An array of DIDs
  * @param options             Optional parameters
  */
  async createJWE(cleartext, recipients, options = {}) {
    const encrypters = await resolveX25519Encrypters(recipients, this._resolver);
    return createJWE(cleartext, encrypters, options.protectedHeader, options.aad);
  }
  /**
  * Create an IPFS compatibe DagJWE encrypted to the given recipients.
  *
  * @param cleartext           The cleartext to be encrypted, may include ipld links
  * @param recipients          An array of DIDs
  * @param options             Optional parameters
  */
  async createDagJWE(cleartext, recipients, options = {}) {
    const preparedCleartext = await prepareCleartext(cleartext);
    return this.createJWE(preparedCleartext, recipients, options);
  }
  /**
  * Try to decrypt the given JWE with the currently authenticated user.
  *
  * @param jwe                 The JWE to decrypt
  * @param options             Optional parameters
  */
  async decryptJWE(jwe, options = {}) {
    if (this._client == null) throw new Error("No provider available");
    if (this._id == null) throw new Error("DID is not authenticated");
    const { cleartext } = await this._client.request("did_decryptJWE", {
      did: this._id,
      ...options,
      jwe
    });
    return decodeBase64(cleartext);
  }
  /**
  * Try to decrypt the given DagJWE with the currently authenticated user.
  *
  * @param jwe                 The JWE to decrypt
  * @returns                   An ipld object
  */
  async decryptDagJWE(jwe) {
    const bytes6 = await this.decryptJWE(jwe);
    return decodeCleartext(bytes6);
  }
  /**
  * Resolve the DID Document of the given DID.
  *
  * @param didUrl              The DID to resolve
  */
  async resolve(didUrl) {
    const result = await this._resolver.resolve(didUrl);
    if (result.didResolutionMetadata.error) {
      const { error, message } = result.didResolutionMetadata;
      const maybeMessage = message ? `, ${message}` : "";
      throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);
    }
    return result;
  }
  constructor({ provider, resolver = {}, resolverOptions, capability, parent } = {}) {
    _define_property3(this, "_client", void 0);
    _define_property3(this, "_id", void 0);
    _define_property3(this, "_resolver", void 0);
    _define_property3(this, "_capability", void 0);
    _define_property3(this, "_parentId", void 0);
    if (provider != null) {
      this._client = new RPCClient(provider);
    }
    if (capability) {
      this._capability = capability;
      this._parentId = this._capability.p.iss;
      if (this._parentId.startsWith("did:pkh:eip155:1:")) {
        this._parentId = this._parentId.toLowerCase();
      }
      if (parent && this._parentId !== parent) throw new Error("Capability issuer and parent not equal");
    } else if (parent) {
      this._parentId = parent;
    }
    this.setResolver(resolver, resolverOptions);
  }
};

// node_modules/key-did-provider-ed25519/dist/index.js
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify(), 1);
function _define_property4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var B64 = "base64pad";
function toStableObject(obj) {
  return JSON.parse((0, import_fast_json_stable_stringify.default)(obj));
}
function encodeDID(publicKey) {
  const bytes6 = new Uint8Array(publicKey.length + 2);
  bytes6[0] = 237;
  bytes6[1] = 1;
  bytes6.set(publicKey, 2);
  return `did:key:z${toString6(bytes6, "base58btc")}`;
}
function toGeneralJWS(jws) {
  const [protectedHeader, payload, signature] = jws.split(".");
  return {
    payload,
    signatures: [
      {
        protected: protectedHeader,
        signature
      }
    ]
  };
}
var sign = async (payload, did, secretKey, protectedHeader = {}) => {
  const kid = `${did}#${did.split(":")[2]}`;
  const signer = EdDSASigner(secretKey);
  const header2 = toStableObject(Object.assign(protectedHeader, {
    kid,
    alg: "EdDSA"
  }));
  return createJWS(typeof payload === "string" ? payload : toStableObject(payload), signer, header2);
};
var didMethods = {
  did_authenticate: async ({ did, secretKey }, params) => {
    const response = await sign({
      did,
      aud: params.aud,
      nonce: params.nonce,
      paths: params.paths,
      exp: Math.floor(Date.now() / 1e3) + 600
    }, did, secretKey);
    return toGeneralJWS(response);
  },
  did_createJWS: async ({ did, secretKey }, params) => {
    const requestDid = params.did.split("#")[0];
    if (requestDid !== did) throw new RPCError(4100, `Unknown DID: ${did}`);
    const jws = await sign(params.payload, did, secretKey, params.protected);
    return {
      jws: toGeneralJWS(jws)
    };
  },
  did_decryptJWE: async ({ secretKey }, params) => {
    const x25519PrivKey = edwardsToMontgomeryPriv(secretKey.subarray(0, 32));
    const decrypter = x25519Decrypter(x25519PrivKey);
    try {
      const bytes6 = await decryptJWE(params.jwe, decrypter);
      return {
        cleartext: toString6(bytes6, B64)
      };
    } catch (e) {
      throw new RPCError(-32e3, e.message);
    }
  }
};
var Ed25519Provider = class {
  get isDidProvider() {
    return true;
  }
  async send(msg) {
    return await this._handle(msg);
  }
  constructor(seed) {
    _define_property4(this, "_handle", void 0);
    const publicKey = ed25519.getPublicKey(seed);
    const secretKey = concat3([
      seed,
      ed25519.getPublicKey(seed)
    ]);
    const did = encodeDID(publicKey);
    const handler = createHandler(didMethods);
    this._handle = async (msg) => await handler({
      did,
      secretKey
    }, msg);
  }
};

// node_modules/key-did-resolver/dist/index.js
var import_varint3 = __toESM(require_varint(), 1);

// node_modules/key-did-resolver/dist/secp256k1.js
var secp256k1_exports = {};
__export(secp256k1_exports, {
  keyToDidDoc: () => keyToDidDoc
});
function keyToDidDoc(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "Secp256k1VerificationKey2018",
        controller: did,
        publicKeyBase58: toString6(pubKeyBytes, "base58btc")
      }
    ],
    authentication: [
      keyId
    ],
    assertionMethod: [
      keyId
    ],
    capabilityDelegation: [
      keyId
    ],
    capabilityInvocation: [
      keyId
    ]
  };
}

// node_modules/key-did-resolver/dist/ed25519.js
var ed25519_exports = {};
__export(ed25519_exports, {
  keyToDidDoc: () => keyToDidDoc2
});
function encodeKey(key) {
  const bytes6 = new Uint8Array(key.length + 2);
  bytes6[0] = 236;
  bytes6[1] = 1;
  bytes6.set(key, 2);
  return `z${toString6(bytes6, "base58btc")}`;
}
function keyToDidDoc2(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const x25519PubBytes = edwardsToMontgomeryPub(pubKeyBytes);
  const x25519KeyId = `${did}#${encodeKey(x25519PubBytes)}`;
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "Ed25519VerificationKey2018",
        controller: did,
        publicKeyBase58: toString6(pubKeyBytes, "base58btc")
      }
    ],
    authentication: [
      keyId
    ],
    assertionMethod: [
      keyId
    ],
    capabilityDelegation: [
      keyId
    ],
    capabilityInvocation: [
      keyId
    ],
    keyAgreement: [
      {
        id: x25519KeyId,
        type: "X25519KeyAgreementKey2019",
        controller: did,
        publicKeyBase58: toString6(x25519PubBytes, "base58btc")
      }
    ]
  };
}

// node_modules/key-did-resolver/dist/secp256r1.js
var secp256r1_exports = {};
__export(secp256r1_exports, {
  keyToDidDoc: () => keyToDidDoc3
});
function keyToDidDoc3(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const point = p2562.ProjectivePoint.fromHex(normalizePubKeyBytes(pubKeyBytes));
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk: {
          kty: "EC",
          crv: "P-256",
          x: toString6(numberToVarBytesBE(point.x), "base64url"),
          y: toString6(numberToVarBytesBE(point.y), "base64url")
        }
      }
    ],
    authentication: [
      keyId
    ],
    assertionMethod: [
      keyId
    ],
    capabilityDelegation: [
      keyId
    ],
    capabilityInvocation: [
      keyId
    ]
  };
}
function normalizePubKeyBytes(pubKeyBytes) {
  if (pubKeyBytes.length === 64) {
    return concat3([
      new Uint8Array([
        4
      ]),
      pubKeyBytes
    ]);
  } else {
    return pubKeyBytes;
  }
}

// node_modules/key-did-resolver/dist/secp384r1.js
var secp384r1_exports = {};
__export(secp384r1_exports, {
  keyToDidDoc: () => keyToDidDoc4
});

// node_modules/@noble/curves/esm/p384.js
var p3842 = p384;

// node_modules/key-did-resolver/dist/secp384r1.js
function keyToDidDoc4(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const point = p3842.ProjectivePoint.fromHex(normalizePubKeyBytes2(pubKeyBytes));
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk: {
          kty: "EC",
          crv: "P-384",
          x: toString6(numberToVarBytesBE(point.x), "base64url"),
          y: toString6(numberToVarBytesBE(point.y), "base64url")
        }
      }
    ],
    authentication: [
      keyId
    ],
    assertionMethod: [
      keyId
    ],
    capabilityDelegation: [
      keyId
    ],
    capabilityInvocation: [
      keyId
    ]
  };
}
function normalizePubKeyBytes2(pubKeyBytes) {
  if (pubKeyBytes.length === 96) {
    return concat3([
      new Uint8Array([
        4
      ]),
      pubKeyBytes
    ]);
  } else {
    return pubKeyBytes;
  }
}

// node_modules/key-did-resolver/dist/secp521r1.js
var secp521r1_exports = {};
__export(secp521r1_exports, {
  keyToDidDoc: () => keyToDidDoc5
});

// node_modules/@noble/curves/esm/p521.js
var p5212 = p521;

// node_modules/key-did-resolver/dist/secp521r1.js
function keyToDidDoc5(pubKeyBytes, fingerprint) {
  const did = `did:key:${fingerprint}`;
  const keyId = `${did}#${fingerprint}`;
  const point = p5212.ProjectivePoint.fromHex(pubKeyBytes);
  return {
    id: did,
    verificationMethod: [
      {
        id: keyId,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk: {
          kty: "EC",
          crv: "P-521",
          x: toString6(numberToVarBytesBE(point.x), "base64url"),
          y: toString6(numberToVarBytesBE(point.y), "base64url")
        }
      }
    ],
    authentication: [
      keyId
    ],
    assertionMethod: [
      keyId
    ],
    capabilityDelegation: [
      keyId
    ],
    capabilityInvocation: [
      keyId
    ]
  };
}

// node_modules/key-did-resolver/dist/index.js
var DID_LD_JSON = "application/did+ld+json";
var DID_JSON = "application/did+json";
var prefixToDriverMap = {
  231: secp256k1_exports,
  237: ed25519_exports,
  4608: secp256r1_exports,
  4609: secp384r1_exports,
  4610: secp521r1_exports
};
function getResolver() {
  return {
    // @ts-ignore
    key: async (did, parsed, r, options) => {
      const contentType = options.accept || DID_JSON;
      const response = {
        didResolutionMetadata: {
          contentType
        },
        didDocument: null,
        didDocumentMetadata: {}
      };
      try {
        const multicodecPubKey = base58btc2.decode(parsed.id);
        const keyType = import_varint3.default.decode(multicodecPubKey);
        const pubKeyBytes = multicodecPubKey.slice(import_varint3.default.decode.bytes);
        const doc = await prefixToDriverMap[keyType].keyToDidDoc(pubKeyBytes, parsed.id);
        if (contentType === DID_LD_JSON) {
          doc["@context"] = "https://w3id.org/did/v1";
          response.didDocument = doc;
        } else if (contentType === DID_JSON) {
          response.didDocument = doc;
        } else {
          delete response.didResolutionMetadata.contentType;
          response.didResolutionMetadata.error = "representationNotSupported";
        }
      } catch (e) {
        response.didResolutionMetadata.error = "invalidDid";
        response.didResolutionMetadata.message = e.toString();
      }
      return response;
    }
  };
}

// src/signature/sign_did.ts
var DIDSigner = class {
  /**
  * Verifies a DID-signed JWS against a verification hash
  * 
  * @param jws - JSON Web Signature to verify
  * @param key - DID key used for signing
  * @param hash - Verification hash that was signed
  * @returns Promise resolving to boolean indicating signature validity
  * 
  * This method:
  * - Constructs the expected signature payload
  * - Verifies the JWS using DID resolver
  * - Validates payload message and key match
  */
  async verify(jws, key, hash3) {
    const expected = { message: `I sign this revision: [${hash3}]` };
    try {
      const resolver = getResolver();
      const result = await new DID({ resolver }).verifyJWS(jws);
      if (!result.payload || expected.message !== result.payload.message) return false;
      if (key !== result.kid.split("#")[0]) return false;
    } catch (e) {
      console.log(e);
      return false;
    }
    return true;
  }
  /**
  * Signs a verification hash using DID with Ed25519 provider
  * 
  * @param verificationHash - Hash of the revision to sign
  * @param privateKey - Ed25519 private key as Uint8Array
  * @returns Promise resolving to SignatureResult containing JWS and DID
  * 
  * This method:
  * - Creates a standardized signature payload
  * - Initializes Ed25519 DID provider with private key
  * - Authenticates the DID
  * - Creates and returns a JSON Web Signature
  */
  async sign(verificationHash, privateKey) {
    const payload = {
      message: `I sign this revision: [${verificationHash}]`
    };
    const provider = new Ed25519Provider(privateKey);
    const resolver = getResolver();
    const did = new DID({ provider, resolver });
    await did.authenticate();
    const jws = await did.createJWS(payload);
    return { jws, key: did.id };
  }
};

// src/signature/sign_p12.ts
init_crypto();
var P12Signer = class {
  // Use our platform compatibility layer instead of direct Node.js imports
  async getCrypto() {
    return await getCrypto();
  }
  async getForge() {
    return await getForge();
  }
  async verify(signature, pubKey, data) {
    const { createVerify } = await this.getCrypto();
    const pubKeyBuffer = Buffer.from(pubKey, "hex");
    const signatureBuffer = Buffer.from(signature, "hex");
    try {
      const verifier = createVerify("RSA-SHA256");
      verifier.update(data);
      return verifier.verify(pubKeyBuffer, signatureBuffer);
    } catch (error) {
      console.error("Error verifying signature:", error);
      return false;
    }
  }
  async sign(verificationHash, privateKey, password) {
    const { createSign } = await this.getCrypto();
    const forge2 = await this.getForge();
    const p12Asn1 = forge2.asn1.fromDer(privateKey);
    const p12 = forge2.pkcs12.pkcs12FromAsn1(p12Asn1, password);
    const bagType = forge2.pki.oids.pkcs8ShroudedKeyBag;
    const bag = p12.getBags({ bagType })[bagType][0];
    const keyPem = forge2.pki.privateKeyToPem(bag.key);
    const privateKeyObj = forge2.pki.privateKeyFromPem(keyPem);
    const publicKey = forge2.pki.rsa.setPublicKey(privateKeyObj.n, privateKeyObj.e);
    const publicKeyAsn1 = forge2.pki.publicKeyToAsn1(publicKey);
    const publicKeyDer = forge2.asn1.toDer(publicKeyAsn1).getBytes();
    const pubKeyString = Buffer.from(publicKeyDer, "binary").toString("hex");
    const signer = createSign("RSA-SHA256");
    signer.update(verificationHash);
    let signature;
    try {
      signature = signer.sign(privateKeyObj);
    } catch (error) {
      console.warn("Crypto signer failed, falling back to forge:", error);
      const md2 = forge2.md.sha256.create();
      md2.update(verificationHash);
      signature = privateKeyObj.sign(md2);
    }
    return {
      signature: Buffer.from(signature, "binary").toString("hex"),
      pubKey: pubKeyString,
      walletAddress: pubKeyString
    };
  }
};

// src/core/signature.ts
var import_ethers3 = require("ethers");
async function signAquaTreeUtil(aquaTreeView, signType, credentials, enableScalar = false, identCharacter = "", reactNativeOptions) {
  let aquaTree = aquaTreeView.aquaTree;
  let logs = [];
  let targetRevisionHash = "";
  if (aquaTreeView.revision == void 0 || aquaTreeView.revision == null || aquaTreeView.revision.length == 0) {
    const verificationHashes = Object.keys(aquaTreeView.aquaTree.revisions);
    const lastRevisionHash = verificationHashes[verificationHashes.length - 1];
    targetRevisionHash = lastRevisionHash;
  } else {
    targetRevisionHash = aquaTreeView.revision;
  }
  let signature, walletAddress, publicKey, signature_type;
  switch (signType) {
    case "metamask":
      let sign2 = new MetaMaskSigner({
        reactNativeOptions
      });
      [signature, walletAddress, publicKey] = await sign2.sign(targetRevisionHash, credentials.witness_eth_network);
      signature_type = "ethereum:eip-191";
      break;
    case "cli":
      try {
        if (credentials == null || credentials == void 0) {
          logs.push({
            log: "Credentials not found ",
            logType: "error" /* ERROR */,
            ident: identCharacter
          });
          return Err(logs);
        }
        let [wallet, _walletAddress, _publicKey] = await getWallet(
          credentials.mnemonic
        );
        let sign3 = new CLISigner();
        signature = await sign3.doSign(wallet, targetRevisionHash);
        walletAddress = _walletAddress;
        publicKey = _publicKey;
      } catch (error) {
        logs.push({
          log: "Failed to read mnemonic:" + error,
          logType: "error" /* ERROR */,
          ident: identCharacter
        });
        return Err(logs);
      }
      signature_type = "ethereum:eip-191";
      break;
    case "did":
      if (credentials == null || credentials == void 0 || credentials["did_key"].length === 0 || !credentials["did_key"]) {
        logs.push({
          log: "DID key is required.  Please get a key from https://hub.ebsi.eu/tools/did-generator",
          logType: "error" /* ERROR */,
          ident: identCharacter
        });
        return Err(logs);
      }
      let did = new DIDSigner();
      const { jws, key } = await did.sign(
        targetRevisionHash,
        Buffer.from(credentials["did_key"], "hex")
      );
      signature = jws;
      walletAddress = key;
      publicKey = key;
      signature_type = "did_key";
      break;
    case "p12":
      const p12signer = new P12Signer();
      const { signature: _signature, pubKey } = await p12signer.sign(targetRevisionHash, credentials["p12_content"], credentials["p12_password"]);
      signature = _signature;
      walletAddress = pubKey;
      publicKey = pubKey;
      signature_type = "p12";
      break;
  }
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const timestamp = formatMwTimestamp(now2.slice(0, now2.indexOf(".")));
  let verificationDataRaw = {
    previous_verification_hash: targetRevisionHash,
    //previousVerificationHash,
    local_timestamp: timestamp,
    version: `https://aqua-protocol.org/docs/v3/schema_2 | SHA256 | Method: ${enableScalar ? "scalar" : "tree"}`,
    revision_type: "signature",
    signature,
    signature_public_key: publicKey,
    signature_wallet_address: walletAddress,
    signature_type
  };
  let verificationData = reorderRevisionsProperties(verificationDataRaw);
  const leaves = dict2Leaves(verificationData);
  let verification_hash = "";
  if (enableScalar) {
    verification_hash = "0x" + getHashSum(JSON.stringify(verificationData));
  } else {
    verification_hash = getMerkleRoot(leaves);
    verificationData.leaves = leaves;
  }
  const revisions = aquaTree.revisions;
  revisions[verification_hash] = verificationData;
  let aquaTreeWithTree = createAquaTree(aquaTree);
  if (!aquaTreeWithTree) {
    logs.push({
      log: "Failed to create AquaTree",
      logType: "error" /* ERROR */,
      ident: identCharacter
    });
    return Err(logs);
  }
  logs.push({
    log: `AquaTree signed succesfully`,
    logType: "success" /* SUCCESS */,
    ident: identCharacter
  });
  let result = {
    aquaTree: aquaTreeWithTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(result);
}
async function signMultipleAquaTreesUtil(aquaTrees, signType, credentials, reactNativeOptions, enableScalar = false, identCharacter = "") {
  console.log("signMultipleAquaTreesUtil unused parameters:", aquaTrees, signType, credentials, reactNativeOptions, enableScalar, identCharacter);
  let logs = [];
  logs.push({
    log: "unimplmented need to be fixes",
    logType: "error" /* ERROR */,
    ident: identCharacter
  });
  return Err(logs);
}
function recoverWalletAddress(verificationHash, signature) {
  try {
    const message = `I sign this revision: [${verificationHash}]`;
    const messageHash = import_ethers3.ethers.hashMessage(message);
    const recoveredAddress = import_ethers3.ethers.recoverAddress(messageHash, signature);
    return recoveredAddress;
  } catch (error) {
    console.error("Error recovering wallet address:", error);
    throw new Error("Invalid signature or message");
  }
}
async function verifySignature(data, verificationHash, identCharacter = "") {
  let logs = [];
  let signatureOk = false;
  if (verificationHash === "") {
    logs.push({
      log: `The verificationHash MUST NOT be empty`,
      logType: "error" /* ERROR */
    });
    return [signatureOk, logs];
  }
  logs.push({
    log: `Wallet address:  ${data.signature_wallet_address}`,
    logType: "signature" /* SIGNATURE */,
    ident: identCharacter
  });
  let signerDID = new DIDSigner();
  switch (data.signature_type) {
    case "did_key":
      signatureOk = await signerDID.verify(
        data.signature,
        data.signature_public_key,
        verificationHash
      );
      break;
    case "ethereum:eip-191":
      const paddedMessage = `I sign this revision: [${verificationHash}]`;
      try {
        const recoveredAddress = import_ethers3.ethers.recoverAddress(
          import_ethers3.ethers.hashMessage(paddedMessage),
          data.signature
        );
        signatureOk = recoveredAddress.toLowerCase() === data.signature_wallet_address.toLowerCase();
      } catch (e) {
        logs.push({
          log: `A critical error : ${e}`,
          logType: "error" /* ERROR */
        });
      }
      break;
    case "p12":
      const signerP12 = new P12Signer();
      signatureOk = await signerP12.verify(
        data.signature,
        data.signature_public_key,
        verificationHash
      );
      break;
  }
  return [signatureOk, logs];
}

// src/witness/wintess_eth.ts
var import_ethers4 = require("ethers");
init_platform();
var WitnessEth = class {
  // Utility Methods
  /**
  * Utility method to pause execution
  * 
  * @param ms - Number of milliseconds to sleep
  * @returns Promise that resolves after the specified delay
  */
  static sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  // Environment detection
  /**
  * Detects the current runtime environment
  * 
  * @returns WitnessEnvironment indicating 'browser' or 'node'
  * 
  * Checks for presence of window.ethereum to determine if running
  * in a browser environment with MetaMask available
  */
  static detectEnvironment() {
    return typeof window !== "undefined" && window.ethereum ? "browser" : "node";
  }
  /**
  * Main entry point for MetaMask-based witnessing
  * 
  * @param config - Configuration for witness operation
  * @returns Promise resolving to witness transaction data
  * 
  * This method:
  * - Detects environment (browser/node)
  * - Routes to appropriate witness implementation
  * - Handles error cases
  */
  static async witnessMetamask(config) {
    const environment = this.detectEnvironment();
    try {
      switch (environment) {
        case "browser":
          return await this.browserWitness(config);
        case "node":
          return await this.nodeWitnessMetamask(config);
        default:
          throw new Error("Unsupported environment");
      }
    } catch (error) {
      console.error("Witness error:", error);
      throw error;
    }
  }
  /**
  * Creates common HTTP request listener for witness server
  * 
  * @param htmlContent - HTML content to serve for witness page
  * @returns Request listener function
  * 
  * This method handles:
  * - GET / - Serves witness page
  * - GET /result - Returns current transaction status
  * - POST / - Receives transaction data from browser
  */
  static async commonPrepareListener(htmlContent) {
    let output6 = "{}";
    const requestListener = async (req, res) => {
      if (req.method == "POST") {
        let data = "";
        req.on("data", (chunk) => {
          data += chunk;
        });
        await new Promise((resolve) => {
          req.on("end", resolve);
        });
        output6 = data;
        res.writeHead(200);
        res.end();
      } else {
        if (req.url === "/result") {
          res.writeHead(200);
          res.end(output6);
          return;
        }
        res.setHeader("Content-Type", "text/html");
        res.writeHead(200);
        res.end(htmlContent);
      }
    };
    return requestListener;
  }
  // Metamask Witness Method
  /**
  * Handles witnessing in Node.js environment
  * 
  * @param config - Witness configuration
  * @param port - Port for local server (default: 8420)
  * @param host - Host for local server (default: 'localhost')
  * @returns Promise resolving to witness transaction data
  * 
  * This method:
  * - Creates local HTTP server
  * - Serves witness page for MetaMask interaction
  * - Polls for transaction completion
  * - Returns transaction hash and wallet address
  */
  static async nodeWitnessMetamask(config, port2 = 8420, host2 = "localhost") {
    const serverUrl = `http://${host2}:${port2}`;
    const html = this.generateWitnessHtml(config);
    const requestListener = await this.commonPrepareListener(html);
    const server = await createHttpServer(requestListener);
    if (!server) {
      throw new Error("Failed to create HTTP server. This feature may not be supported in your environment.");
    }
    server.listen(port2, host2, () => {
      console.log(`\u2728 Server is running on ${serverUrl}`);
    });
    let response, content;
    while (true) {
      response = await fetch(serverUrl + "/result");
      content = await response.json();
      if (content.transaction_hash) {
        const transactionHash = content.transaction_hash;
        const walletAddress = content.wallet_address;
        console.log(`The witness tx hash has been retrieved: ${transactionHash}`);
        server.close();
        let data = {
          transaction_hash: transactionHash,
          wallet_address: walletAddress
        };
        return Promise.resolve(data);
      }
      console.log("Waiting for the witness...");
      await this.sleep(1e4);
    }
  }
  // Browser-specific implementation
  /**
  * Handles witnessing in browser environment
  * 
  * @param config - Witness configuration
  * @returns Promise resolving to witness transaction data
  * 
  * This method:
  * - Verifies MetaMask presence
  * - Requests account access
  * - Ensures correct network chain
  * - Sends witness transaction
  * - Returns transaction details
  */
  static async browserWitness(config) {
    const ethChainIdMap = {
      "mainnet": "0x1",
      "sepolia": "0xaa36a7",
      "holesky": "0x4268"
    };
    if (!window.ethereum.isMetaMask) {
      throw new Error("MetaMask not detected");
    }
    await window.ethereum.enable();
    const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
    const wallet = accounts[0];
    const { ethers: ethers5 } = await import("ethers");
    const walletAddress = ethers5.getAddress(wallet);
    const chainId = await window.ethereum.request({ method: "eth_chainId" });
    const requestedChainId = ethChainIdMap[config.witnessNetwork];
    if (requestedChainId !== chainId) {
      await window.ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: requestedChainId }]
      });
    }
    let hashToWitness = config.witnessEventVerificationHash.replace(/^0x/, "");
    const getBytesLength = hashToWitness.length / 2;
    const zeroPadding = "0".repeat(64);
    const params = [{
      from: walletAddress,
      to: config.smartContractAddress,
      data: "0x9cef4ea1" + (getBytesLength === 64 ? hashToWitness : `${zeroPadding}${hashToWitness}`)
    }];
    const transactionHash = await window.ethereum.request({
      method: "eth_sendTransaction",
      params
    });
    return {
      transaction_hash: transactionHash,
      wallet_address: walletAddress
    };
  }
  // Generate Witness HTML for Metamask
  static generateWitnessHtml(config) {
    return `
    <html>
      <script type="module">
       import { getAddress } from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.min.js';
    
        const witnessNetwork = "${config.witnessNetwork}"
        const smart_contract_address = "${config.smartContractAddress}"
        const witness_event_verification_hash = "${config.witnessEventVerificationHash}"
        const localServerUrl = window.location.href;

        const doWitness = async (wallet_address) => {
        // Apply ethers.js checksumming to the address
        wallet_address = getAddress(wallet_address);

          const chainId = await window.ethereum.request({ method: 'eth_chainId' })
          const requestedChainId = ${JSON.stringify(this.ethChainIdMap)}[witnessNetwork]
          
          if (requestedChainId !== chainId) {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: requestedChainId }],
            })
          }

          const params = [{
            from: wallet_address,
            to: smart_contract_address,
            data: '0x9cef4ea1' + witness_event_verification_hash.replace(/^0x/, ''),
          }]

          const transaction_hash = await window.ethereum.request({
            method: 'eth_sendTransaction',
            params: params,
          })

          document.getElementById("transaction_hash").innerHTML = 
            \`Transaction hash of the witness network: \${transaction_hash} (you may close this tab)\`
          
          await fetch(localServerUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ transaction_hash, wallet_address })
          })
        }

        if (window.ethereum && window.ethereum.isMetaMask) {
          window.ethereum.request({ method: 'eth_requestAccounts' }).then(async (accounts) => {
            await doWitness(accounts[0])
          })
        } else {
          alert("Metamask not detected")
        }
      </script>
      <body>
        <div id="transaction_hash"></div>
      </body>
    </html>
    `;
  }
  // CLI Witness Method
  static async witnessCli(walletPrivateKey, witnessEventVerificationHash, smartContractAddress, WitnessNetwork4, providerUrl, _alchemyKey) {
    const logData = [];
    try {
      const fetchRequest = new import_ethers4.ethers.FetchRequest(providerUrl);
      fetchRequest.timeout = 6e3;
      const provider = new import_ethers4.ethers.JsonRpcProvider(fetchRequest, {
        name: WitnessNetwork4,
        chainId: Number(this.ethChainIdMap[WitnessNetwork4])
      });
      const wallet = new import_ethers4.ethers.Wallet(walletPrivateKey, provider);
      const sender = wallet.address;
      console.log(`Using wallet: ${sender}`);
      if (!witnessEventVerificationHash.startsWith("0x")) {
        throw new Error("Invalid witness verification hash: must start with '0x'");
      }
      const tx = {
        from: sender,
        to: smartContractAddress,
        data: `0x9cef4ea1${witnessEventVerificationHash.slice(2)}`
      };
      const balance = await provider.getBalance(sender);
      const balanceInEth = import_ethers4.ethers.formatEther(balance);
      logData.push({
        log: `Sender Balance: ${balanceInEth} ETH`,
        logType: "debug_data" /* DEBUGDATA */
      });
      const estimatedGas = await provider.estimateGas(tx);
      logData.push({
        log: `Estimated Gas: ${estimatedGas.toString()} units`,
        logType: "debug_data" /* DEBUGDATA */
      });
      const feeData = await provider.getFeeData();
      logData.push({
        log: `Fee data: ", ${feeData}`,
        logType: "debug_data" /* DEBUGDATA */
      });
      const gasPrice = feeData.gasPrice ? feeData.gasPrice : BigInt(0);
      logData.push({
        log: `Gas Price: ${import_ethers4.ethers.formatUnits(gasPrice, "gwei")} Gwei`,
        logType: "debug_data" /* DEBUGDATA */
      });
      const gasCost = estimatedGas * gasPrice;
      const gasCostInEth = import_ethers4.ethers.formatEther(gasCost);
      logData.push({
        log: `Estimated Gas Fee: ${gasCostInEth} ETH`,
        logType: "debug_data" /* DEBUGDATA */
      });
      if (balance < gasCost) {
        logData.push({
          log: `Estimated Gas Fee: ${gasCostInEth} ETH`,
          logType: "debug_data" /* DEBUGDATA */
        });
        throw new Error("Insufficient balance for gas fee.");
      }
      const signedTx = await wallet.sendTransaction({
        ...tx,
        gasLimit: estimatedGas,
        gasPrice
      });
      logData.push({
        log: `Transaction sent! Hash: ${signedTx.hash}`,
        logType: "debug_data" /* DEBUGDATA */
      });
      return [{ error: null, transactionHash: signedTx.hash }, logData];
    } catch (error) {
      logData.push({
        log: `Error sending transaction:', ${error}`,
        logType: "error" /* ERROR */
      });
      return [{ error: error.message }, logData];
    }
  }
  // Verify Transaction Method
  static async verify(witnessNetwork, transactionHash, expectedMR, _expectedTimestamp, providerUrl, _alchemyKey) {
    const fetchRequest = new import_ethers4.ethers.FetchRequest(providerUrl);
    fetchRequest.timeout = 6e3;
    const provider = new import_ethers4.ethers.JsonRpcProvider(fetchRequest, {
      name: witnessNetwork,
      chainId: Number(this.ethChainIdMap[witnessNetwork])
    });
    provider.ready;
    const tx = await provider.getTransaction(transactionHash);
    if (!tx) {
      return [false, "Transaction not found"];
    }
    ;
    let actual = tx.data.split("0x9cef4ea1")[1];
    let containsHash = actual.includes(expectedMR.slice(2));
    return [containsHash, `${containsHash ? "On-Chain Witness hash verified" : "On-Chain Witness verification failed"}`];
  }
};
// Internal Configuration Maps
/**
* Maps witness networks to their corresponding Ethereum chain IDs
* 
* @private
* @readonly
*/
WitnessEth.ethChainIdMap = {
  mainnet: "0x1",
  sepolia: "0xaa36a7",
  holesky: "0x4268"
};

// src/witness/witness_tsa.ts
var asn1js2 = __toESM(require("asn1js"), 1);

// node_modules/pkijs/build/index.es.js
var asn1js = __toESM(require("asn1js"));

// node_modules/pvtsutils/build/index.es.js
var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
var BufferSourceConverter = class _BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a, b) {
    const aView = _BufferSourceConverter.toUint8Array(a);
    const bView = _BufferSourceConverter.toUint8Array(b);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i2 = 0; i2 < aView.length; i2++) {
      if (aView[i2] !== bView[i2]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size2 = 0;
    for (const buffer2 of buffers) {
      size2 += buffer2.byteLength;
    }
    const res = new Uint8Array(size2);
    let offset = 0;
    for (const buffer2 of buffers) {
      const view = this.toUint8Array(buffer2);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
};
var STRING_TYPE = "string";
var HEX_REGEX = /^[0-9a-f\s]+$/i;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
var Utf8Converter = class {
  static fromString(text) {
    const s = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s.length);
    for (let i2 = 0; i2 < s.length; i2++) {
      uintArray[i2] = s.charCodeAt(i2);
    }
    return uintArray.buffer;
  }
  static toString(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    let encodedString = "";
    for (let i2 = 0; i2 < buf2.length; i2++) {
      encodedString += String.fromCharCode(buf2[i2]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
};
var Utf16Converter = class {
  static toString(buffer2, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer2);
    const dataView2 = new DataView(arrayBuffer);
    let res = "";
    for (let i2 = 0; i2 < arrayBuffer.byteLength; i2 += 2) {
      const code4 = dataView2.getUint16(i2, littleEndian);
      res += String.fromCharCode(code4);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView2 = new DataView(res);
    for (let i2 = 0; i2 < text.length; i2++) {
      dataView2.setUint16(i2 * 2, text.charCodeAt(i2), littleEndian);
    }
    return res;
  }
};
var Convert = class _Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer2, enc = "utf8") {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf2);
      case "binary":
        return this.ToBinary(buf2);
      case "hex":
        return this.ToHex(buf2);
      case "base64":
        return this.ToBase64(buf2);
      case "base64url":
        return this.ToBase64Url(buf2);
      case "utf16le":
        return Utf16Converter.toString(buf2, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf2);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf2, "binary");
      return btoa(binary);
    } else {
      return Buffer.from(buf2).toString("base64");
    }
  }
  static FromBase64(base644) {
    const formatted = this.formatString(base644);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url4) {
    const formatted = this.formatString(base64url4);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer2, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer2);
      case "utf8":
        return Utf8Converter.toString(buffer2);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer2);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer2, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i2 = 0; i2 < stringLength; i2++) {
      resultView[i2] = text.charCodeAt(i2);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    let res = "";
    for (let i2 = 0; i2 < buf2.length; i2++) {
      res += String.fromCharCode(buf2[i2]);
    }
    return res;
  }
  static ToHex(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    let result = "";
    const len = buf2.length;
    for (let i2 = 0; i2 < len; i2++) {
      const byte = buf2[i2];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i2 = 0; i2 < formatted.length; i2 = i2 + 2) {
      const c = formatted.slice(i2, i2 + 2);
      res[i2 / 2] = parseInt(c, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer2, littleEndian = false) {
    return Utf16Converter.toString(buffer2, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base644) {
    const padCount = 4 - base644.length % 4;
    if (padCount < 4) {
      for (let i2 = 0; i2 < padCount; i2++) {
        base644 += "=";
      }
    }
    return base644;
  }
  static formatString(data) {
    return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
  }
};
Convert.DEFAULT_UTF8_ENCODING = "utf8";

// node_modules/pvutils/build/utils.es.js
function getParametersValue(parameters, name4, defaultValue) {
  var _a3;
  if (parameters instanceof Object === false) {
    return defaultValue;
  }
  return (_a3 = parameters[name4]) !== null && _a3 !== void 0 ? _a3 : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {
  let result = "";
  for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)) {
    const str = item.toString(16).toUpperCase();
    if (str.length === 1) {
      result += "0";
    }
    result += str;
    if (insertSpace) {
      result += " ";
    }
  }
  return result.trim();
}
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i2 = inputBuffer.length - 1; i2 >= 0; i2--) {
    result += inputBuffer[inputBuffer.length - 1 - i2] * Math.pow(2, inputBase * i2);
  }
  return result;
}
function utilToBase(value, base4, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base4);
  for (let i2 = 1; i2 < 8; i2++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i2);
        result = i2;
      } else {
        if (internalReserved < i2) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i2 - 1; j >= 0; j--) {
        const basis = Math.pow(2, j * base4);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base4);
  }
  return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (const buffer2 of buffers) {
    outputLength += buffer2.byteLength;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const buffer2 of buffers) {
    retView.set(new Uint8Array(buffer2), prevLength);
    prevLength += buffer2.byteLength;
  }
  return retBuf;
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i2 = 0; i2 < view1.length; i2++) {
    if (view1[i2] !== view2[i2]) {
      return false;
    }
  }
  return true;
}
var base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
  let i2 = 0;
  let flag1 = 0;
  let flag2 = 0;
  let output6 = "";
  const template = useUrlTemplate ? base64UrlTemplate : base64Template;
  if (skipLeadingZeros) {
    let nonZeroPosition = 0;
    for (let i3 = 0; i3 < input.length; i3++) {
      if (input.charCodeAt(i3) !== 0) {
        nonZeroPosition = i3;
        break;
      }
    }
    input = input.slice(nonZeroPosition);
  }
  while (i2 < input.length) {
    const chr1 = input.charCodeAt(i2++);
    if (i2 >= input.length) {
      flag1 = 1;
    }
    const chr2 = input.charCodeAt(i2++);
    if (i2 >= input.length) {
      flag2 = 1;
    }
    const chr3 = input.charCodeAt(i2++);
    const enc1 = chr1 >> 2;
    const enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    let enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    let enc4 = chr3 & 63;
    if (flag1 === 1) {
      enc3 = enc4 = 64;
    } else {
      if (flag2 === 1) {
        enc4 = 64;
      }
    }
    if (skipPadding) {
      if (enc3 === 64) {
        output6 += `${template.charAt(enc1)}${template.charAt(enc2)}`;
      } else {
        if (enc4 === 64) {
          output6 += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
        } else {
          output6 += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
      }
    } else {
      output6 += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
    }
  }
  return output6;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
  const template = useUrlTemplate ? base64UrlTemplate : base64Template;
  function indexOf(toSearch) {
    for (let i3 = 0; i3 < 64; i3++) {
      if (template.charAt(i3) === toSearch)
        return i3;
    }
    return 64;
  }
  function test2(incoming) {
    return incoming === 64 ? 0 : incoming;
  }
  let i2 = 0;
  let output6 = "";
  while (i2 < input.length) {
    const enc1 = indexOf(input.charAt(i2++));
    const enc2 = i2 >= input.length ? 0 : indexOf(input.charAt(i2++));
    const enc3 = i2 >= input.length ? 0 : indexOf(input.charAt(i2++));
    const enc4 = i2 >= input.length ? 0 : indexOf(input.charAt(i2++));
    const chr1 = test2(enc1) << 2 | test2(enc2) >> 4;
    const chr2 = (test2(enc2) & 15) << 4 | test2(enc3) >> 2;
    const chr3 = (test2(enc3) & 3) << 6 | test2(enc4);
    output6 += String.fromCharCode(chr1);
    if (enc3 !== 64) {
      output6 += String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output6 += String.fromCharCode(chr3);
    }
  }
  if (cutTailZeros) {
    const outputLength = output6.length;
    let nonZeroStart = -1;
    for (let i3 = outputLength - 1; i3 >= 0; i3--) {
      if (output6.charCodeAt(i3) !== 0) {
        nonZeroStart = i3;
        break;
      }
    }
    if (nonZeroStart !== -1) {
      output6 = output6.slice(0, nonZeroStart + 1);
    } else {
      output6 = "";
    }
  }
  return output6;
}
function arrayBufferToString(buffer2) {
  let resultString = "";
  const view = new Uint8Array(buffer2);
  for (const element of view) {
    resultString += String.fromCharCode(element);
  }
  return resultString;
}
function stringToArrayBuffer(str) {
  const stringLength = str.length;
  const resultBuffer = new ArrayBuffer(stringLength);
  const resultView = new Uint8Array(resultBuffer);
  for (let i2 = 0; i2 < stringLength; i2++) {
    resultView[i2] = str.charCodeAt(i2);
  }
  return resultBuffer;
}
var log2 = Math.log(2);
function nearestPowerOf2(length3) {
  const base4 = Math.log(length3) / log2;
  const floor = Math.floor(base4);
  const round = Math.round(base4);
  return floor === round ? floor : round;
}
function clearProps(object2, propsArray) {
  for (const prop of propsArray) {
    delete object2[prop];
  }
}

// node_modules/bytestreamjs/build/mjs/byte_stream.js
var ByteStream = class _ByteStream {
  constructor(parameters = {}) {
    if ("view" in parameters) {
      this.fromUint8Array(parameters.view);
    } else if ("buffer" in parameters) {
      this.fromArrayBuffer(parameters.buffer);
    } else if ("string" in parameters) {
      this.fromString(parameters.string);
    } else if ("hexstring" in parameters) {
      this.fromHexString(parameters.hexstring);
    } else {
      if ("length" in parameters && parameters.length > 0) {
        this.length = parameters.length;
        if (parameters.stub) {
          for (let i2 = 0; i2 < this._view.length; i2++) {
            this._view[i2] = parameters.stub;
          }
        }
      } else {
        this.length = 0;
      }
    }
  }
  set buffer(value) {
    this._buffer = value;
    this._view = new Uint8Array(this._buffer);
  }
  get buffer() {
    return this._buffer;
  }
  set view(value) {
    this._buffer = new ArrayBuffer(value.length);
    this._view = new Uint8Array(this._buffer);
    this._view.set(value);
  }
  get view() {
    return this._view;
  }
  get length() {
    return this.view.byteLength;
  }
  set length(value) {
    this._buffer = new ArrayBuffer(value);
    this._view = new Uint8Array(this._buffer);
  }
  clear() {
    this._buffer = new ArrayBuffer(0);
    this._view = new Uint8Array(this._buffer);
  }
  fromArrayBuffer(array) {
    this._buffer = array;
    this._view = new Uint8Array(this._buffer);
  }
  fromUint8Array(array) {
    this.fromArrayBuffer(new Uint8Array(array).buffer);
  }
  fromString(string4) {
    const stringLength = string4.length;
    this.length = stringLength;
    for (let i2 = 0; i2 < stringLength; i2++)
      this.view[i2] = string4.charCodeAt(i2);
  }
  toString(start = 0, length3 = this.view.length - start) {
    let result = "";
    if (start >= this.view.length || start < 0) {
      start = 0;
    }
    if (length3 >= this.view.length || length3 < 0) {
      length3 = this.view.length - start;
    }
    for (let i2 = start; i2 < start + length3; i2++)
      result += String.fromCharCode(this.view[i2]);
    return result;
  }
  fromHexString(hexString) {
    const stringLength = hexString.length;
    this.buffer = new ArrayBuffer(stringLength >> 1);
    this.view = new Uint8Array(this.buffer);
    const hexMap = /* @__PURE__ */ new Map();
    hexMap.set("0", 0);
    hexMap.set("1", 1);
    hexMap.set("2", 2);
    hexMap.set("3", 3);
    hexMap.set("4", 4);
    hexMap.set("5", 5);
    hexMap.set("6", 6);
    hexMap.set("7", 7);
    hexMap.set("8", 8);
    hexMap.set("9", 9);
    hexMap.set("A", 10);
    hexMap.set("a", 10);
    hexMap.set("B", 11);
    hexMap.set("b", 11);
    hexMap.set("C", 12);
    hexMap.set("c", 12);
    hexMap.set("D", 13);
    hexMap.set("d", 13);
    hexMap.set("E", 14);
    hexMap.set("e", 14);
    hexMap.set("F", 15);
    hexMap.set("f", 15);
    let j = 0;
    let temp = 0;
    for (let i2 = 0; i2 < stringLength; i2++) {
      if (!(i2 % 2)) {
        temp = hexMap.get(hexString.charAt(i2)) << 4;
      } else {
        temp |= hexMap.get(hexString.charAt(i2));
        this.view[j] = temp;
        j++;
      }
    }
  }
  toHexString(start = 0, length3 = this.view.length - start) {
    let result = "";
    if (start >= this.view.length || start < 0) {
      start = 0;
    }
    if (length3 >= this.view.length || length3 < 0) {
      length3 = this.view.length - start;
    }
    for (let i2 = start; i2 < start + length3; i2++) {
      const str = this.view[i2].toString(16).toUpperCase();
      result = result + (str.length == 1 ? "0" : "") + str;
    }
    return result;
  }
  copy(start = 0, length3 = this.length - start) {
    if (!start && !this.length) {
      return new _ByteStream();
    }
    if (start < 0 || start > this.length - 1) {
      throw new Error(`Wrong start position: ${start}`);
    }
    const stream2 = new _ByteStream({
      buffer: this._buffer.slice(start, start + length3)
    });
    return stream2;
  }
  slice(start = 0, end = this.length) {
    if (!start && !this.length) {
      return new _ByteStream();
    }
    if (start < 0 || start > this.length - 1) {
      throw new Error(`Wrong start position: ${start}`);
    }
    const stream2 = new _ByteStream({
      buffer: this._buffer.slice(start, end)
    });
    return stream2;
  }
  realloc(size2) {
    const buffer2 = new ArrayBuffer(size2);
    const view = new Uint8Array(buffer2);
    if (size2 > this._view.length)
      view.set(this._view);
    else {
      view.set(new Uint8Array(this._buffer, 0, size2));
    }
    this._buffer = buffer2;
    this._view = new Uint8Array(this._buffer);
  }
  append(stream2) {
    const initialSize = this.length;
    const streamViewLength = stream2.length;
    const subarrayView = stream2._view.subarray();
    this.realloc(initialSize + streamViewLength);
    this._view.set(subarrayView, initialSize);
  }
  insert(stream2, start = 0, length3 = this.length - start) {
    if (start > this.length - 1)
      return false;
    if (length3 > this.length - start) {
      length3 = this.length - start;
    }
    if (length3 > stream2.length) {
      length3 = stream2.length;
    }
    if (length3 == stream2.length)
      this._view.set(stream2._view, start);
    else {
      this._view.set(stream2._view.subarray(0, length3), start);
    }
    return true;
  }
  isEqual(stream2) {
    if (this.length != stream2.length)
      return false;
    for (let i2 = 0; i2 < stream2.length; i2++) {
      if (this.view[i2] != stream2.view[i2])
        return false;
    }
    return true;
  }
  isEqualView(view) {
    if (view.length != this.view.length)
      return false;
    for (let i2 = 0; i2 < view.length; i2++) {
      if (this.view[i2] != view[i2])
        return false;
    }
    return true;
  }
  findPattern(pattern, start_, length_, backward_) {
    const { start, length: length3, backward } = this.prepareFindParameters(start_, length_, backward_);
    const patternLength = pattern.length;
    if (patternLength > length3) {
      return -1;
    }
    const patternArray = [];
    for (let i2 = 0; i2 < patternLength; i2++)
      patternArray.push(pattern.view[i2]);
    for (let i2 = 0; i2 <= length3 - patternLength; i2++) {
      let equal = true;
      const equalStart = backward ? start - patternLength - i2 : start + i2;
      for (let j = 0; j < patternLength; j++) {
        if (this.view[j + equalStart] != patternArray[j]) {
          equal = false;
          break;
        }
      }
      if (equal) {
        return backward ? start - patternLength - i2 : start + patternLength + i2;
      }
    }
    return -1;
  }
  findFirstIn(patterns, start_, length_, backward_) {
    const { start, length: length3, backward } = this.prepareFindParameters(start_, length_, backward_);
    const result = {
      id: -1,
      position: backward ? 0 : start + length3,
      length: 0
    };
    for (let i2 = 0; i2 < patterns.length; i2++) {
      const position = this.findPattern(patterns[i2], start, length3, backward);
      if (position != -1) {
        let valid = false;
        const patternLength = patterns[i2].length;
        if (backward) {
          if (position - patternLength >= result.position - result.length)
            valid = true;
        } else {
          if (position - patternLength <= result.position - result.length)
            valid = true;
        }
        if (valid) {
          result.position = position;
          result.id = i2;
          result.length = patternLength;
        }
      }
    }
    return result;
  }
  findAllIn(patterns, start_, length_) {
    let { start, length: length3 } = this.prepareFindParameters(start_, length_);
    const result = [];
    let patternFound = {
      id: -1,
      position: start
    };
    do {
      const position = patternFound.position;
      patternFound = this.findFirstIn(patterns, patternFound.position, length3);
      if (patternFound.id == -1) {
        break;
      }
      length3 -= patternFound.position - position;
      result.push({
        id: patternFound.id,
        position: patternFound.position
      });
    } while (true);
    return result;
  }
  findAllPatternIn(pattern, start_, length_) {
    const { start, length: length3 } = this.prepareFindParameters(start_, length_);
    const result = [];
    const patternLength = pattern.length;
    if (patternLength > length3) {
      return -1;
    }
    const patternArray = Array.from(pattern.view);
    for (let i2 = 0; i2 <= length3 - patternLength; i2++) {
      let equal = true;
      const equalStart = start + i2;
      for (let j = 0; j < patternLength; j++) {
        if (this.view[j + equalStart] != patternArray[j]) {
          equal = false;
          break;
        }
      }
      if (equal) {
        result.push(start + patternLength + i2);
        i2 += patternLength - 1;
      }
    }
    return result;
  }
  findFirstNotIn(patterns, start_, length_, backward_) {
    let { start, length: length3, backward } = this.prepareFindParameters(start_, length_, backward_);
    const result = {
      left: {
        id: -1,
        position: start
      },
      right: {
        id: -1,
        position: 0
      },
      value: new _ByteStream()
    };
    let currentLength = length3;
    while (currentLength > 0) {
      result.right = this.findFirstIn(patterns, backward ? start - length3 + currentLength : start + length3 - currentLength, currentLength, backward);
      if (result.right.id == -1) {
        length3 = currentLength;
        if (backward) {
          start -= length3;
        } else {
          start = result.left.position;
        }
        result.value = new _ByteStream({
          buffer: this._buffer.slice(start, start + length3)
        });
        break;
      }
      if (result.right.position != (backward ? result.left.position - patterns[result.right.id].length : result.left.position + patterns[result.right.id].length)) {
        if (backward) {
          start = result.right.position + patterns[result.right.id].length;
          length3 = result.left.position - result.right.position - patterns[result.right.id].length;
        } else {
          start = result.left.position;
          length3 = result.right.position - result.left.position - patterns[result.right.id].length;
        }
        result.value = new _ByteStream({
          buffer: this._buffer.slice(start, start + length3)
        });
        break;
      }
      result.left = result.right;
      currentLength -= patterns[result.right.id].length;
    }
    if (backward) {
      const temp = result.right;
      result.right = result.left;
      result.left = temp;
    }
    return result;
  }
  findAllNotIn(patterns, start_, length_) {
    let { start, length: length3 } = this.prepareFindParameters(start_, length_);
    const result = [];
    let patternFound = {
      left: {
        id: -1,
        position: start
      },
      right: {
        id: -1,
        position: start
      },
      value: new _ByteStream()
    };
    do {
      const position = patternFound.right.position;
      patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length3);
      length3 -= patternFound.right.position - position;
      result.push({
        left: {
          id: patternFound.left.id,
          position: patternFound.left.position
        },
        right: {
          id: patternFound.right.id,
          position: patternFound.right.position
        },
        value: patternFound.value
      });
    } while (patternFound.right.id != -1);
    return result;
  }
  findFirstSequence(patterns, start_, length_, backward_) {
    let { start, length: length3, backward } = this.prepareFindParameters(start_, length_, backward_);
    const firstIn = this.skipNotPatterns(patterns, start, length3, backward);
    if (firstIn == -1) {
      return {
        position: -1,
        value: new _ByteStream()
      };
    }
    const firstNotIn = this.skipPatterns(patterns, firstIn, length3 - (backward ? start - firstIn : firstIn - start), backward);
    if (backward) {
      start = firstNotIn;
      length3 = firstIn - firstNotIn;
    } else {
      start = firstIn;
      length3 = firstNotIn - firstIn;
    }
    const value = new _ByteStream({
      buffer: this._buffer.slice(start, start + length3)
    });
    return {
      position: firstNotIn,
      value
    };
  }
  findAllSequences(patterns, start_, length_) {
    let { start, length: length3 } = this.prepareFindParameters(start_, length_);
    const result = [];
    let patternFound = {
      position: start,
      value: new _ByteStream()
    };
    do {
      const position = patternFound.position;
      patternFound = this.findFirstSequence(patterns, patternFound.position, length3);
      if (patternFound.position != -1) {
        length3 -= patternFound.position - position;
        result.push({
          position: patternFound.position,
          value: patternFound.value
        });
      }
    } while (patternFound.position != -1);
    return result;
  }
  findPairedPatterns(leftPattern, rightPattern, start_, length_) {
    const result = [];
    if (leftPattern.isEqual(rightPattern))
      return result;
    const { start, length: length3 } = this.prepareFindParameters(start_, length_);
    let currentPositionLeft = 0;
    const leftPatterns = this.findAllPatternIn(leftPattern, start, length3);
    if (!Array.isArray(leftPatterns) || leftPatterns.length == 0) {
      return result;
    }
    const rightPatterns = this.findAllPatternIn(rightPattern, start, length3);
    if (!Array.isArray(rightPatterns) || rightPatterns.length == 0) {
      return result;
    }
    while (currentPositionLeft < leftPatterns.length) {
      if (rightPatterns.length == 0) {
        break;
      }
      if (leftPatterns[0] == rightPatterns[0]) {
        result.push({
          left: leftPatterns[0],
          right: rightPatterns[0]
        });
        leftPatterns.splice(0, 1);
        rightPatterns.splice(0, 1);
        continue;
      }
      if (leftPatterns[currentPositionLeft] > rightPatterns[0]) {
        break;
      }
      while (leftPatterns[currentPositionLeft] < rightPatterns[0]) {
        currentPositionLeft++;
        if (currentPositionLeft >= leftPatterns.length) {
          break;
        }
      }
      result.push({
        left: leftPatterns[currentPositionLeft - 1],
        right: rightPatterns[0]
      });
      leftPatterns.splice(currentPositionLeft - 1, 1);
      rightPatterns.splice(0, 1);
      currentPositionLeft = 0;
    }
    result.sort((a, b) => a.left - b.left);
    return result;
  }
  findPairedArrays(inputLeftPatterns, inputRightPatterns, start_, length_) {
    const { start, length: length3 } = this.prepareFindParameters(start_, length_);
    const result = [];
    let currentPositionLeft = 0;
    const leftPatterns = this.findAllIn(inputLeftPatterns, start, length3);
    if (leftPatterns.length == 0)
      return result;
    const rightPatterns = this.findAllIn(inputRightPatterns, start, length3);
    if (rightPatterns.length == 0)
      return result;
    while (currentPositionLeft < leftPatterns.length) {
      if (rightPatterns.length == 0) {
        break;
      }
      if (leftPatterns[0].position == rightPatterns[0].position) {
        result.push({
          left: leftPatterns[0],
          right: rightPatterns[0]
        });
        leftPatterns.splice(0, 1);
        rightPatterns.splice(0, 1);
        continue;
      }
      if (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {
        break;
      }
      while (leftPatterns[currentPositionLeft].position < rightPatterns[0].position) {
        currentPositionLeft++;
        if (currentPositionLeft >= leftPatterns.length) {
          break;
        }
      }
      result.push({
        left: leftPatterns[currentPositionLeft - 1],
        right: rightPatterns[0]
      });
      leftPatterns.splice(currentPositionLeft - 1, 1);
      rightPatterns.splice(0, 1);
      currentPositionLeft = 0;
    }
    result.sort((a, b) => a.left.position - b.left.position);
    return result;
  }
  replacePattern(searchPattern, replacePattern, start_, length_, findAllResult = null) {
    let result = [];
    let i2;
    const output6 = {
      status: -1,
      searchPatternPositions: [],
      replacePatternPositions: []
    };
    const { start, length: length3 } = this.prepareFindParameters(start_, length_);
    if (findAllResult == null) {
      result = this.findAllIn([searchPattern], start, length3);
      if (result.length == 0) {
        return output6;
      }
    } else {
      result = findAllResult;
    }
    output6.searchPatternPositions.push(...Array.from(result, (element) => element.position));
    const patternDifference = searchPattern.length - replacePattern.length;
    const changedBuffer = new ArrayBuffer(this.view.length - result.length * patternDifference);
    const changedView = new Uint8Array(changedBuffer);
    changedView.set(new Uint8Array(this.buffer, 0, start));
    for (i2 = 0; i2 < result.length; i2++) {
      const currentPosition = i2 == 0 ? start : result[i2 - 1].position;
      changedView.set(new Uint8Array(this.buffer, currentPosition, result[i2].position - searchPattern.length - currentPosition), currentPosition - i2 * patternDifference);
      changedView.set(replacePattern.view, result[i2].position - searchPattern.length - i2 * patternDifference);
      output6.replacePatternPositions.push(result[i2].position - searchPattern.length - i2 * patternDifference);
    }
    i2--;
    changedView.set(new Uint8Array(this.buffer, result[i2].position, this.length - result[i2].position), result[i2].position - searchPattern.length + replacePattern.length - i2 * patternDifference);
    this.buffer = changedBuffer;
    this.view = new Uint8Array(this.buffer);
    output6.status = 1;
    return output6;
  }
  skipPatterns(patterns, start_, length_, backward_) {
    const { start, length: length3, backward } = this.prepareFindParameters(start_, length_, backward_);
    let result = start;
    for (let k = 0; k < patterns.length; k++) {
      const patternLength = patterns[k].length;
      const equalStart = backward ? result - patternLength : result;
      let equal = true;
      for (let j = 0; j < patternLength; j++) {
        if (this.view[j + equalStart] != patterns[k].view[j]) {
          equal = false;
          break;
        }
      }
      if (equal) {
        k = -1;
        if (backward) {
          result -= patternLength;
          if (result <= 0)
            return result;
        } else {
          result += patternLength;
          if (result >= start + length3)
            return result;
        }
      }
    }
    return result;
  }
  skipNotPatterns(patterns, start_, length_, backward_) {
    const { start, length: length3, backward } = this.prepareFindParameters(start_, length_, backward_);
    let result = -1;
    for (let i2 = 0; i2 < length3; i2++) {
      for (let k = 0; k < patterns.length; k++) {
        const patternLength = patterns[k].length;
        const equalStart = backward ? start - i2 - patternLength : start + i2;
        let equal = true;
        for (let j = 0; j < patternLength; j++) {
          if (this.view[j + equalStart] != patterns[k].view[j]) {
            equal = false;
            break;
          }
        }
        if (equal) {
          result = backward ? start - i2 : start + i2;
          break;
        }
      }
      if (result != -1) {
        break;
      }
    }
    return result;
  }
  prepareFindParameters(start = null, length3 = null, backward = false) {
    if (start === null) {
      start = backward ? this.length : 0;
    }
    if (start > this.length) {
      start = this.length;
    }
    if (backward) {
      if (length3 === null) {
        length3 = start;
      }
      if (length3 > start) {
        length3 = start;
      }
    } else {
      if (length3 === null) {
        length3 = this.length - start;
      }
      if (length3 > this.length - start) {
        length3 = this.length - start;
      }
    }
    return { start, length: length3, backward };
  }
};

// node_modules/bytestreamjs/build/mjs/seq_stream.js
var pow2_24 = 16777216;
var SeqStream = class _SeqStream {
  constructor(parameters = {}) {
    this._stream = new ByteStream();
    this._length = 0;
    this._start = 0;
    this.backward = false;
    this.appendBlock = 0;
    this.prevLength = 0;
    this.prevStart = 0;
    if ("view" in parameters) {
      this.stream = new ByteStream({ view: parameters.view });
    } else if ("buffer" in parameters) {
      this.stream = new ByteStream({ buffer: parameters.buffer });
    } else if ("string" in parameters) {
      this.stream = new ByteStream({ string: parameters.string });
    } else if ("hexstring" in parameters) {
      this.stream = new ByteStream({ hexstring: parameters.hexstring });
    } else if ("stream" in parameters) {
      this.stream = parameters.stream.slice();
    } else {
      this.stream = new ByteStream();
    }
    if ("backward" in parameters && parameters.backward) {
      this.backward = parameters.backward;
      this._start = this.stream.length;
    }
    if ("length" in parameters && parameters.length > 0) {
      this._length = parameters.length;
    }
    if ("start" in parameters && parameters.start && parameters.start > 0) {
      this._start = parameters.start;
    }
    if ("appendBlock" in parameters && parameters.appendBlock && parameters.appendBlock > 0) {
      this.appendBlock = parameters.appendBlock;
    }
  }
  set stream(value) {
    this._stream = value;
    this.prevLength = this._length;
    this._length = value.length;
    this.prevStart = this._start;
    this._start = 0;
  }
  get stream() {
    return this._stream;
  }
  set length(value) {
    this.prevLength = this._length;
    this._length = value;
  }
  get length() {
    if (this.appendBlock) {
      return this.start;
    }
    return this._length;
  }
  set start(value) {
    if (value > this.stream.length)
      return;
    this.prevStart = this._start;
    this.prevLength = this._length;
    this._length -= this.backward ? this._start - value : value - this._start;
    this._start = value;
  }
  get start() {
    return this._start;
  }
  get buffer() {
    return this._stream.buffer.slice(0, this._length);
  }
  resetPosition() {
    this._start = this.prevStart;
    this._length = this.prevLength;
  }
  findPattern(pattern, gap = null) {
    if (gap == null || gap > this.length) {
      gap = this.length;
    }
    const result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
    if (result == -1)
      return result;
    if (this.backward) {
      if (result < this.start - pattern.length - gap) {
        return -1;
      }
    } else {
      if (result > this.start + pattern.length + gap) {
        return -1;
      }
    }
    this.start = result;
    return result;
  }
  findFirstIn(patterns, gap = null) {
    if (gap == null || gap > this.length) {
      gap = this.length;
    }
    const result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
    if (result.id == -1)
      return result;
    if (this.backward) {
      if (result.position < this.start - patterns[result.id].length - gap) {
        return {
          id: -1,
          position: this.backward ? 0 : this.start + this.length
        };
      }
    } else {
      if (result.position > this.start + patterns[result.id].length + gap) {
        return {
          id: -1,
          position: this.backward ? 0 : this.start + this.length
        };
      }
    }
    this.start = result.position;
    return result;
  }
  findAllIn(patterns) {
    const start = this.backward ? this.start - this.length : this.start;
    return this.stream.findAllIn(patterns, start, this.length);
  }
  findFirstNotIn(patterns, gap = null) {
    if (gap == null || gap > this._length) {
      gap = this._length;
    }
    const result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
    if (result.left.id == -1 && result.right.id == -1) {
      return result;
    }
    if (this.backward) {
      if (result.right.id != -1) {
        if (result.right.position < this._start - patterns[result.right.id].length - gap) {
          return {
            left: {
              id: -1,
              position: this._start
            },
            right: {
              id: -1,
              position: 0
            },
            value: new ByteStream()
          };
        }
      }
    } else {
      if (result.left.id != -1) {
        if (result.left.position > this._start + patterns[result.left.id].length + gap) {
          return {
            left: {
              id: -1,
              position: this._start
            },
            right: {
              id: -1,
              position: 0
            },
            value: new ByteStream()
          };
        }
      }
    }
    if (this.backward) {
      if (result.left.id == -1) {
        this.start = 0;
      } else {
        this.start = result.left.position;
      }
    } else {
      if (result.right.id == -1) {
        this.start = this._start + this._length;
      } else {
        this.start = result.right.position;
      }
    }
    return result;
  }
  findAllNotIn(patterns) {
    const start = this.backward ? this._start - this._length : this._start;
    return this._stream.findAllNotIn(patterns, start, this._length);
  }
  findFirstSequence(patterns, length3 = null, gap = null) {
    if (length3 == null || length3 > this._length) {
      length3 = this._length;
    }
    if (gap == null || gap > length3) {
      gap = length3;
    }
    const result = this._stream.findFirstSequence(patterns, this._start, length3, this.backward);
    if (result.value.length == 0) {
      return result;
    }
    if (this.backward) {
      if (result.position < this._start - result.value.length - gap) {
        return {
          position: -1,
          value: new ByteStream()
        };
      }
    } else {
      if (result.position > this._start + result.value.length + gap) {
        return {
          position: -1,
          value: new ByteStream()
        };
      }
    }
    this.start = result.position;
    return result;
  }
  findAllSequences(patterns) {
    const start = this.backward ? this.start - this.length : this.start;
    return this.stream.findAllSequences(patterns, start, this.length);
  }
  findPairedPatterns(leftPattern, rightPattern, gap = null) {
    if (gap == null || gap > this.length) {
      gap = this.length;
    }
    const start = this.backward ? this.start - this.length : this.start;
    const result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
    if (result.length) {
      if (this.backward) {
        if (result[0].right < this.start - rightPattern.length - gap) {
          return [];
        }
      } else {
        if (result[0].left > this.start + leftPattern.length + gap) {
          return [];
        }
      }
    }
    return result;
  }
  findPairedArrays(leftPatterns, rightPatterns, gap = null) {
    if (gap == null || gap > this.length) {
      gap = this.length;
    }
    const start = this.backward ? this.start - this.length : this.start;
    const result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
    if (result.length) {
      if (this.backward) {
        if (result[0].right.position < this.start - rightPatterns[result[0].right.id].length - gap) {
          return [];
        }
      } else {
        if (result[0].left.position > this.start + leftPatterns[result[0].left.id].length + gap) {
          return [];
        }
      }
    }
    return result;
  }
  replacePattern(searchPattern, replacePattern) {
    const start = this.backward ? this.start - this.length : this.start;
    return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
  }
  skipPatterns(patterns) {
    const result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
    this.start = result;
    return result;
  }
  skipNotPatterns(patterns) {
    const result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
    if (result == -1)
      return -1;
    this.start = result;
    return result;
  }
  append(stream2) {
    this.beforeAppend(stream2.length);
    this._stream.view.set(stream2.view, this._start);
    this._length += stream2.length * 2;
    this.start = this._start + stream2.length;
    this.prevLength -= stream2.length * 2;
  }
  appendView(view) {
    this.beforeAppend(view.length);
    this._stream.view.set(view, this._start);
    this._length += view.length * 2;
    this.start = this._start + view.length;
    this.prevLength -= view.length * 2;
  }
  appendChar(char) {
    this.beforeAppend(1);
    this._stream.view[this._start] = char;
    this._length += 2;
    this.start = this._start + 1;
    this.prevLength -= 2;
  }
  appendUint16(number7) {
    this.beforeAppend(2);
    const value = new Uint16Array([number7]);
    const view = new Uint8Array(value.buffer);
    this.stream.view[this._start] = view[1];
    this._stream.view[this._start + 1] = view[0];
    this._length += 4;
    this.start = this._start + 2;
    this.prevLength -= 4;
  }
  appendUint24(number7) {
    this.beforeAppend(3);
    const value = new Uint32Array([number7]);
    const view = new Uint8Array(value.buffer);
    this._stream.view[this._start] = view[2];
    this._stream.view[this._start + 1] = view[1];
    this._stream.view[this._start + 2] = view[0];
    this._length += 6;
    this.start = this._start + 3;
    this.prevLength -= 6;
  }
  appendUint32(number7) {
    this.beforeAppend(4);
    const value = new Uint32Array([number7]);
    const view = new Uint8Array(value.buffer);
    this._stream.view[this._start] = view[3];
    this._stream.view[this._start + 1] = view[2];
    this._stream.view[this._start + 2] = view[1];
    this._stream.view[this._start + 3] = view[0];
    this._length += 8;
    this.start = this._start + 4;
    this.prevLength -= 8;
  }
  appendInt16(number7) {
    this.beforeAppend(2);
    const value = new Int16Array([number7]);
    const view = new Uint8Array(value.buffer);
    this._stream.view[this._start] = view[1];
    this._stream.view[this._start + 1] = view[0];
    this._length += 4;
    this.start = this._start + 2;
    this.prevLength -= 4;
  }
  appendInt32(number7) {
    this.beforeAppend(4);
    const value = new Int32Array([number7]);
    const view = new Uint8Array(value.buffer);
    this._stream.view[this._start] = view[3];
    this._stream.view[this._start + 1] = view[2];
    this._stream.view[this._start + 2] = view[1];
    this._stream.view[this._start + 3] = view[0];
    this._length += 8;
    this.start = this._start + 4;
    this.prevLength -= 8;
  }
  getBlock(size2, changeLength = true) {
    if (this._length <= 0) {
      return new Uint8Array(0);
    }
    if (this._length < size2) {
      size2 = this._length;
    }
    let result;
    if (this.backward) {
      const view = this._stream.view.subarray(this._length - size2, this._length);
      result = new Uint8Array(size2);
      for (let i2 = 0; i2 < size2; i2++) {
        result[size2 - 1 - i2] = view[i2];
      }
    } else {
      result = this._stream.view.subarray(this._start, this._start + size2);
    }
    if (changeLength) {
      this.start += this.backward ? -1 * size2 : size2;
    }
    return result;
  }
  getUint16(changeLength = true) {
    const block = this.getBlock(2, changeLength);
    if (block.length < 2)
      return 0;
    return block[0] << 8 | block[1];
  }
  getInt16(changeLength = true) {
    const num = this.getUint16(changeLength);
    const negative = 32768;
    if (num & negative) {
      return -(negative - (num ^ negative));
    }
    return num;
  }
  getUint24(changeLength = true) {
    const block = this.getBlock(4, changeLength);
    if (block.length < 3)
      return 0;
    return block[0] << 16 | block[1] << 8 | block[2];
  }
  getUint32(changeLength = true) {
    const block = this.getBlock(4, changeLength);
    if (block.length < 4)
      return 0;
    return block[0] * pow2_24 + (block[1] << 16) + (block[2] << 8) + block[3];
  }
  getInt32(changeLength = true) {
    const num = this.getUint32(changeLength);
    const negative = 2147483648;
    if (num & negative) {
      return -(negative - (num ^ negative));
    }
    return num;
  }
  beforeAppend(size2) {
    if (this._start + size2 > this._stream.length) {
      if (size2 > this.appendBlock) {
        this.appendBlock = size2 + _SeqStream.APPEND_BLOCK;
      }
      this._stream.realloc(this._stream.length + this.appendBlock);
    }
  }
};
SeqStream.APPEND_BLOCK = 1e3;

// node_modules/@noble/hashes/esm/sha1.js
var sha12 = sha1;

// node_modules/@noble/hashes/esm/sha512.js
var sha5124 = sha5122;
var sha3842 = sha384;

// node_modules/pkijs/build/index.es.js
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_STRING = "";
var ArgumentError = class _ArgumentError extends TypeError {
  constructor() {
    super(...arguments);
    this.name = _ArgumentError.NAME;
  }
  static isType(value, type) {
    if (typeof type === "string") {
      if (type === "Array" && Array.isArray(value)) {
        return true;
      } else if (type === "ArrayBuffer" && value instanceof ArrayBuffer) {
        return true;
      } else if (type === "ArrayBufferView" && ArrayBuffer.isView(value)) {
        return true;
      } else if (typeof value === type) {
        return true;
      }
    } else if (value instanceof type) {
      return true;
    }
    return false;
  }
  static assert(value, name4, ...types) {
    for (const type of types) {
      if (this.isType(value, type)) {
        return;
      }
    }
    const typeNames = types.map((o) => o instanceof Function && "name" in o ? o.name : `${o}`);
    throw new _ArgumentError(`Parameter '${name4}' is not of type ${typeNames.length > 1 ? `(${typeNames.join(" or ")})` : typeNames[0]}`);
  }
};
ArgumentError.NAME = "ArgumentError";
var ParameterError = class _ParameterError extends TypeError {
  static assert(...args) {
    let target = null;
    let params;
    let fields;
    if (typeof args[0] === "string") {
      target = args[0];
      params = args[1];
      fields = args.slice(2);
    } else {
      params = args[0];
      fields = args.slice(1);
    }
    ArgumentError.assert(params, "parameters", "object");
    for (const field of fields) {
      const value = params[field];
      if (value === void 0 || value === null) {
        throw new _ParameterError(field, target);
      }
    }
  }
  static assertEmpty(value, name4, target) {
    if (value === void 0 || value === null) {
      throw new _ParameterError(name4, target);
    }
  }
  constructor(field, target = null, message) {
    super();
    this.name = _ParameterError.NAME;
    this.field = field;
    if (target) {
      this.target = target;
    }
    if (message) {
      this.message = message;
    } else {
      this.message = `Absent mandatory parameter '${field}' ${target ? ` in '${target}'` : EMPTY_STRING}`;
    }
  }
};
ParameterError.NAME = "ParameterError";
var AsnError = class _AsnError extends Error {
  static assertSchema(asn1, target) {
    if (!asn1.verified) {
      throw new Error(`Object's schema was not verified against input data for ${target}`);
    }
  }
  static assert(asn, target) {
    if (asn.offset === -1) {
      throw new _AsnError(`Error during parsing of ASN.1 data. Data is not correct for '${target}'.`);
    }
  }
  constructor(message) {
    super(message);
    this.name = "AsnError";
  }
};
var PkiObject = class {
  static blockName() {
    return this.CLASS_NAME;
  }
  static fromBER(raw) {
    const asn1 = asn1js.fromBER(raw);
    AsnError.assert(asn1, this.name);
    try {
      return new this({ schema: asn1.result });
    } catch (e) {
      throw new AsnError(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`);
    }
  }
  static defaultValues(memberName) {
    throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${memberName}`);
  }
  static schema(parameters = {}) {
    throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`);
  }
  get className() {
    return this.constructor.CLASS_NAME;
  }
  toString(encoding = "hex") {
    let schema;
    try {
      schema = this.toSchema();
    } catch {
      schema = this.toSchema(true);
    }
    return Convert.ToString(schema.toBER(), encoding);
  }
};
PkiObject.CLASS_NAME = "PkiObject";
function stringPrep(inputString) {
  let isSpace = false;
  let cutResult = EMPTY_STRING;
  const result = inputString.trim();
  for (let i2 = 0; i2 < result.length; i2++) {
    if (result.charCodeAt(i2) === 32) {
      if (isSpace === false)
        isSpace = true;
    } else {
      if (isSpace) {
        cutResult += " ";
        isSpace = false;
      }
      cutResult += result[i2];
    }
  }
  return cutResult.toLowerCase();
}
var TYPE$5 = "type";
var VALUE$6 = "value";
var AttributeTypeAndValue = class _AttributeTypeAndValue extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.type = getParametersValue(parameters, TYPE$5, _AttributeTypeAndValue.defaultValues(TYPE$5));
    this.value = getParametersValue(parameters, VALUE$6, _AttributeTypeAndValue.defaultValues(VALUE$6));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TYPE$5:
        return EMPTY_STRING;
      case VALUE$6:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.type || EMPTY_STRING }),
        new asn1js.Any({ name: names.value || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      TYPE$5,
      "typeValue"
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _AttributeTypeAndValue.schema({
      names: {
        type: TYPE$5,
        value: "typeValue"
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.type = asn1.result.type.valueBlock.toString();
    this.value = asn1.result.typeValue;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.type }),
        this.value
      ]
    });
  }
  toJSON() {
    const _object = {
      type: this.type
    };
    if (Object.keys(this.value).length !== 0) {
      _object.value = this.value.toJSON();
    } else {
      _object.value = this.value;
    }
    return _object;
  }
  isEqual(compareTo) {
    const stringBlockNames = [
      asn1js.Utf8String.blockName(),
      asn1js.BmpString.blockName(),
      asn1js.UniversalString.blockName(),
      asn1js.NumericString.blockName(),
      asn1js.PrintableString.blockName(),
      asn1js.TeletexString.blockName(),
      asn1js.VideotexString.blockName(),
      asn1js.IA5String.blockName(),
      asn1js.GraphicString.blockName(),
      asn1js.VisibleString.blockName(),
      asn1js.GeneralString.blockName(),
      asn1js.CharacterString.blockName()
    ];
    if (compareTo instanceof ArrayBuffer) {
      return BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView, compareTo);
    }
    if (compareTo.constructor.blockName() === _AttributeTypeAndValue.blockName()) {
      if (this.type !== compareTo.type)
        return false;
      const isStringPair = [false, false];
      const thisName = this.value.constructor.blockName();
      for (const name4 of stringBlockNames) {
        if (thisName === name4) {
          isStringPair[0] = true;
        }
        if (compareTo.value.constructor.blockName() === name4) {
          isStringPair[1] = true;
        }
      }
      if (isStringPair[0] !== isStringPair[1]) {
        return false;
      }
      const isString = isStringPair[0] && isStringPair[1];
      if (isString) {
        const value1 = stringPrep(this.value.valueBlock.value);
        const value2 = stringPrep(compareTo.value.valueBlock.value);
        if (value1.localeCompare(value2) !== 0)
          return false;
      } else {
        if (!BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView, compareTo.value.valueBeforeDecodeView))
          return false;
      }
      return true;
    }
    return false;
  }
};
AttributeTypeAndValue.CLASS_NAME = "AttributeTypeAndValue";
var TYPE_AND_VALUES = "typesAndValues";
var VALUE_BEFORE_DECODE = "valueBeforeDecode";
var RDN = "RDN";
var RelativeDistinguishedNames = class _RelativeDistinguishedNames extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.typesAndValues = getParametersValue(parameters, TYPE_AND_VALUES, _RelativeDistinguishedNames.defaultValues(TYPE_AND_VALUES));
    this.valueBeforeDecode = getParametersValue(parameters, VALUE_BEFORE_DECODE, _RelativeDistinguishedNames.defaultValues(VALUE_BEFORE_DECODE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TYPE_AND_VALUES:
        return [];
      case VALUE_BEFORE_DECODE:
        return EMPTY_BUFFER;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TYPE_AND_VALUES:
        return memberValue.length === 0;
      case VALUE_BEFORE_DECODE:
        return memberValue.byteLength === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.repeatedSequence || EMPTY_STRING,
          value: new asn1js.Set({
            value: [
              new asn1js.Repeated({
                name: names.repeatedSet || EMPTY_STRING,
                value: AttributeTypeAndValue.schema(names.typeAndValue || {})
              })
            ]
          })
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      RDN,
      TYPE_AND_VALUES
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _RelativeDistinguishedNames.schema({
      names: {
        blockName: RDN,
        repeatedSet: TYPE_AND_VALUES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (TYPE_AND_VALUES in asn1.result) {
      this.typesAndValues = Array.from(asn1.result.typesAndValues, (element) => new AttributeTypeAndValue({ schema: element }));
    }
    this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecodeView.slice().buffer;
  }
  toSchema() {
    if (this.valueBeforeDecode.byteLength === 0) {
      return new asn1js.Sequence({
        value: [new asn1js.Set({
          value: Array.from(this.typesAndValues, (o) => o.toSchema())
        })]
      });
    }
    const asn1 = asn1js.fromBER(this.valueBeforeDecode);
    AsnError.assert(asn1, "RelativeDistinguishedNames");
    if (!(asn1.result instanceof asn1js.Sequence)) {
      throw new Error("ASN.1 result should be SEQUENCE");
    }
    return asn1.result;
  }
  toJSON() {
    return {
      typesAndValues: Array.from(this.typesAndValues, (o) => o.toJSON())
    };
  }
  isEqual(compareTo) {
    if (compareTo instanceof _RelativeDistinguishedNames) {
      if (this.typesAndValues.length !== compareTo.typesAndValues.length)
        return false;
      for (const [index, typeAndValue] of this.typesAndValues.entries()) {
        if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false)
          return false;
      }
      return true;
    }
    if (compareTo instanceof ArrayBuffer) {
      return isEqualBuffer(this.valueBeforeDecode, compareTo);
    }
    return false;
  }
};
RelativeDistinguishedNames.CLASS_NAME = "RelativeDistinguishedNames";
var TYPE$4 = "type";
var VALUE$5 = "value";
function builtInStandardAttributes(parameters = {}, optional = false) {
  const names = getParametersValue(parameters, "names", {});
  return new asn1js.Sequence({
    optional,
    value: [
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 2,
          tagNumber: 1
        },
        name: names.country_name || EMPTY_STRING,
        value: [
          new asn1js.Choice({
            value: [
              new asn1js.NumericString(),
              new asn1js.PrintableString()
            ]
          })
        ]
      }),
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 2,
          tagNumber: 2
        },
        name: names.administration_domain_name || EMPTY_STRING,
        value: [
          new asn1js.Choice({
            value: [
              new asn1js.NumericString(),
              new asn1js.PrintableString()
            ]
          })
        ]
      }),
      new asn1js.Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        name: names.network_address || EMPTY_STRING,
        isHexOnly: true
      }),
      new asn1js.Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        name: names.terminal_identifier || EMPTY_STRING,
        isHexOnly: true
      }),
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        name: names.private_domain_name || EMPTY_STRING,
        value: [
          new asn1js.Choice({
            value: [
              new asn1js.NumericString(),
              new asn1js.PrintableString()
            ]
          })
        ]
      }),
      new asn1js.Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        name: names.organization_name || EMPTY_STRING,
        isHexOnly: true
      }),
      new asn1js.Primitive({
        optional: true,
        name: names.numeric_user_identifier || EMPTY_STRING,
        idBlock: {
          tagClass: 3,
          tagNumber: 4
        },
        isHexOnly: true
      }),
      new asn1js.Constructed({
        optional: true,
        name: names.personal_name || EMPTY_STRING,
        idBlock: {
          tagClass: 3,
          tagNumber: 5
        },
        value: [
          new asn1js.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            isHexOnly: true
          }),
          new asn1js.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            isHexOnly: true
          }),
          new asn1js.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            isHexOnly: true
          }),
          new asn1js.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            isHexOnly: true
          })
        ]
      }),
      new asn1js.Constructed({
        optional: true,
        name: names.organizational_unit_names || EMPTY_STRING,
        idBlock: {
          tagClass: 3,
          tagNumber: 6
        },
        value: [
          new asn1js.Repeated({
            value: new asn1js.PrintableString()
          })
        ]
      })
    ]
  });
}
function builtInDomainDefinedAttributes(optional = false) {
  return new asn1js.Sequence({
    optional,
    value: [
      new asn1js.PrintableString(),
      new asn1js.PrintableString()
    ]
  });
}
function extensionAttributes(optional = false) {
  return new asn1js.Set({
    optional,
    value: [
      new asn1js.Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        isHexOnly: true
      }),
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [new asn1js.Any()]
      })
    ]
  });
}
var GeneralName = class _GeneralName extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.type = getParametersValue(parameters, TYPE$4, _GeneralName.defaultValues(TYPE$4));
    this.value = getParametersValue(parameters, VALUE$5, _GeneralName.defaultValues(VALUE$5));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TYPE$4:
        return 9;
      case VALUE$5:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TYPE$4:
        return memberValue === _GeneralName.defaultValues(memberName);
      case VALUE$5:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Choice({
      value: [
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js.ObjectIdentifier(),
            new asn1js.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js.Any()]
            })
          ]
        }),
        new asn1js.Primitive({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          }
        }),
        new asn1js.Primitive({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          }
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 3
          },
          name: names.blockName || EMPTY_STRING,
          value: [
            builtInStandardAttributes(names.builtInStandardAttributes || {}, false),
            builtInDomainDefinedAttributes(true),
            extensionAttributes(true)
          ]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 4
          },
          name: names.blockName || EMPTY_STRING,
          value: [RelativeDistinguishedNames.schema(names.directoryName || {})]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 5
          },
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js.Choice({
                  value: [
                    new asn1js.TeletexString(),
                    new asn1js.PrintableString(),
                    new asn1js.UniversalString(),
                    new asn1js.Utf8String(),
                    new asn1js.BmpString()
                  ]
                })
              ]
            }),
            new asn1js.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js.Choice({
                  value: [
                    new asn1js.TeletexString(),
                    new asn1js.PrintableString(),
                    new asn1js.UniversalString(),
                    new asn1js.Utf8String(),
                    new asn1js.BmpString()
                  ]
                })
              ]
            })
          ]
        }),
        new asn1js.Primitive({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 6
          }
        }),
        new asn1js.Primitive({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 7
          }
        }),
        new asn1js.Primitive({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 8
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      "blockName",
      "otherName",
      "rfc822Name",
      "dNSName",
      "x400Address",
      "directoryName",
      "ediPartyName",
      "uniformResourceIdentifier",
      "iPAddress",
      "registeredID"
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _GeneralName.schema({
      names: {
        blockName: "blockName",
        otherName: "otherName",
        rfc822Name: "rfc822Name",
        dNSName: "dNSName",
        x400Address: "x400Address",
        directoryName: {
          names: {
            blockName: "directoryName"
          }
        },
        ediPartyName: "ediPartyName",
        uniformResourceIdentifier: "uniformResourceIdentifier",
        iPAddress: "iPAddress",
        registeredID: "registeredID"
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.type = asn1.result.blockName.idBlock.tagNumber;
    switch (this.type) {
      case 0:
        this.value = asn1.result.blockName;
        break;
      case 1:
      case 2:
      case 6:
        {
          const value = asn1.result.blockName;
          value.idBlock.tagClass = 1;
          value.idBlock.tagNumber = 22;
          const valueBER = value.toBER(false);
          const asnValue = asn1js.fromBER(valueBER);
          AsnError.assert(asnValue, "GeneralName value");
          this.value = asnValue.result.valueBlock.value;
        }
        break;
      case 3:
        this.value = asn1.result.blockName;
        break;
      case 4:
        this.value = new RelativeDistinguishedNames({ schema: asn1.result.directoryName });
        break;
      case 5:
        this.value = asn1.result.ediPartyName;
        break;
      case 7:
        this.value = new asn1js.OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });
        break;
      case 8:
        {
          const value = asn1.result.blockName;
          value.idBlock.tagClass = 1;
          value.idBlock.tagNumber = 6;
          const valueBER = value.toBER(false);
          const asnValue = asn1js.fromBER(valueBER);
          AsnError.assert(asnValue, "GeneralName registeredID");
          this.value = asnValue.result.valueBlock.toString();
        }
        break;
    }
  }
  toSchema() {
    switch (this.type) {
      case 0:
      case 3:
      case 5:
        return new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: this.type
          },
          value: [
            this.value
          ]
        });
      case 1:
      case 2:
      case 6: {
        const value = new asn1js.IA5String({ value: this.value });
        value.idBlock.tagClass = 3;
        value.idBlock.tagNumber = this.type;
        return value;
      }
      case 4:
        return new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 4
          },
          value: [this.value.toSchema()]
        });
      case 7: {
        const value = this.value;
        value.idBlock.tagClass = 3;
        value.idBlock.tagNumber = this.type;
        return value;
      }
      case 8: {
        const value = new asn1js.ObjectIdentifier({ value: this.value });
        value.idBlock.tagClass = 3;
        value.idBlock.tagNumber = this.type;
        return value;
      }
      default:
        return _GeneralName.schema();
    }
  }
  toJSON() {
    const _object = {
      type: this.type,
      value: EMPTY_STRING
    };
    if (typeof this.value === "string")
      _object.value = this.value;
    else {
      try {
        _object.value = this.value.toJSON();
      } catch (ex) {
      }
    }
    return _object;
  }
};
GeneralName.CLASS_NAME = "GeneralName";
var ACCESS_METHOD = "accessMethod";
var ACCESS_LOCATION = "accessLocation";
var CLEAR_PROPS$1v = [
  ACCESS_METHOD,
  ACCESS_LOCATION
];
var AccessDescription = class _AccessDescription extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.accessMethod = getParametersValue(parameters, ACCESS_METHOD, _AccessDescription.defaultValues(ACCESS_METHOD));
    this.accessLocation = getParametersValue(parameters, ACCESS_LOCATION, _AccessDescription.defaultValues(ACCESS_LOCATION));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ACCESS_METHOD:
        return EMPTY_STRING;
      case ACCESS_LOCATION:
        return new GeneralName();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.accessMethod || EMPTY_STRING }),
        GeneralName.schema(names.accessLocation || {})
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1v);
    const asn1 = asn1js.compareSchema(schema, schema, _AccessDescription.schema({
      names: {
        accessMethod: ACCESS_METHOD,
        accessLocation: {
          names: {
            blockName: ACCESS_LOCATION
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
    this.accessLocation = new GeneralName({ schema: asn1.result.accessLocation });
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.accessMethod }),
        this.accessLocation.toSchema()
      ]
    });
  }
  toJSON() {
    return {
      accessMethod: this.accessMethod,
      accessLocation: this.accessLocation.toJSON()
    };
  }
};
AccessDescription.CLASS_NAME = "AccessDescription";
var SECONDS = "seconds";
var MILLIS = "millis";
var MICROS = "micros";
var Accuracy = class _Accuracy extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (SECONDS in parameters) {
      this.seconds = getParametersValue(parameters, SECONDS, _Accuracy.defaultValues(SECONDS));
    }
    if (MILLIS in parameters) {
      this.millis = getParametersValue(parameters, MILLIS, _Accuracy.defaultValues(MILLIS));
    }
    if (MICROS in parameters) {
      this.micros = getParametersValue(parameters, MICROS, _Accuracy.defaultValues(MICROS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SECONDS:
      case MILLIS:
      case MICROS:
        return 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case SECONDS:
      case MILLIS:
      case MICROS:
        return memberValue === _Accuracy.defaultValues(memberName);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      optional: true,
      value: [
        new asn1js.Integer({
          optional: true,
          name: names.seconds || EMPTY_STRING
        }),
        new asn1js.Primitive({
          name: names.millis || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          }
        }),
        new asn1js.Primitive({
          name: names.micros || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      SECONDS,
      MILLIS,
      MICROS
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _Accuracy.schema({
      names: {
        seconds: SECONDS,
        millis: MILLIS,
        micros: MICROS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if ("seconds" in asn1.result) {
      this.seconds = asn1.result.seconds.valueBlock.valueDec;
    }
    if ("millis" in asn1.result) {
      const intMillis = new asn1js.Integer({ valueHex: asn1.result.millis.valueBlock.valueHex });
      this.millis = intMillis.valueBlock.valueDec;
    }
    if ("micros" in asn1.result) {
      const intMicros = new asn1js.Integer({ valueHex: asn1.result.micros.valueBlock.valueHex });
      this.micros = intMicros.valueBlock.valueDec;
    }
  }
  toSchema() {
    const outputArray = [];
    if (this.seconds !== void 0)
      outputArray.push(new asn1js.Integer({ value: this.seconds }));
    if (this.millis !== void 0) {
      const intMillis = new asn1js.Integer({ value: this.millis });
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        valueHex: intMillis.valueBlock.valueHexView
      }));
    }
    if (this.micros !== void 0) {
      const intMicros = new asn1js.Integer({ value: this.micros });
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        valueHex: intMicros.valueBlock.valueHexView
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const _object = {};
    if (this.seconds !== void 0)
      _object.seconds = this.seconds;
    if (this.millis !== void 0)
      _object.millis = this.millis;
    if (this.micros !== void 0)
      _object.micros = this.micros;
    return _object;
  }
};
Accuracy.CLASS_NAME = "Accuracy";
var ALGORITHM_ID = "algorithmId";
var ALGORITHM_PARAMS = "algorithmParams";
var ALGORITHM$2 = "algorithm";
var PARAMS2 = "params";
var CLEAR_PROPS$1u = [
  ALGORITHM$2,
  PARAMS2
];
var AlgorithmIdentifier = class _AlgorithmIdentifier extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.algorithmId = getParametersValue(parameters, ALGORITHM_ID, _AlgorithmIdentifier.defaultValues(ALGORITHM_ID));
    if (ALGORITHM_PARAMS in parameters) {
      this.algorithmParams = getParametersValue(parameters, ALGORITHM_PARAMS, _AlgorithmIdentifier.defaultValues(ALGORITHM_PARAMS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ALGORITHM_ID:
        return EMPTY_STRING;
      case ALGORITHM_PARAMS:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case ALGORITHM_ID:
        return memberValue === EMPTY_STRING;
      case ALGORITHM_PARAMS:
        return memberValue instanceof asn1js.Any;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      optional: names.optional || false,
      value: [
        new asn1js.ObjectIdentifier({ name: names.algorithmIdentifier || EMPTY_STRING }),
        new asn1js.Any({ name: names.algorithmParams || EMPTY_STRING, optional: true })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1u);
    const asn1 = asn1js.compareSchema(schema, schema, _AlgorithmIdentifier.schema({
      names: {
        algorithmIdentifier: ALGORITHM$2,
        algorithmParams: PARAMS2
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.algorithmId = asn1.result.algorithm.valueBlock.toString();
    if (PARAMS2 in asn1.result) {
      this.algorithmParams = asn1.result.params;
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.algorithmId }));
    if (this.algorithmParams && !(this.algorithmParams instanceof asn1js.Any)) {
      outputArray.push(this.algorithmParams);
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const object2 = {
      algorithmId: this.algorithmId
    };
    if (this.algorithmParams && !(this.algorithmParams instanceof asn1js.Any)) {
      object2.algorithmParams = this.algorithmParams.toJSON();
    }
    return object2;
  }
  isEqual(algorithmIdentifier) {
    if (!(algorithmIdentifier instanceof _AlgorithmIdentifier)) {
      return false;
    }
    if (this.algorithmId !== algorithmIdentifier.algorithmId) {
      return false;
    }
    if (this.algorithmParams) {
      if (algorithmIdentifier.algorithmParams) {
        return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);
      }
      return false;
    }
    if (algorithmIdentifier.algorithmParams) {
      return false;
    }
    return true;
  }
};
AlgorithmIdentifier.CLASS_NAME = "AlgorithmIdentifier";
var ALT_NAMES = "altNames";
var CLEAR_PROPS$1t = [
  ALT_NAMES
];
var AltName = class _AltName extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.altNames = getParametersValue(parameters, ALT_NAMES, _AltName.defaultValues(ALT_NAMES));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ALT_NAMES:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.altNames || EMPTY_STRING,
          value: GeneralName.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1t);
    const asn1 = asn1js.compareSchema(schema, schema, _AltName.schema({
      names: {
        altNames: ALT_NAMES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (ALT_NAMES in asn1.result) {
      this.altNames = Array.from(asn1.result.altNames, (element) => new GeneralName({ schema: element }));
    }
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.altNames, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      altNames: Array.from(this.altNames, (o) => o.toJSON())
    };
  }
};
AltName.CLASS_NAME = "AltName";
var TYPE$3 = "type";
var VALUES$1 = "values";
var CLEAR_PROPS$1s = [
  TYPE$3,
  VALUES$1
];
var Attribute = class _Attribute extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.type = getParametersValue(parameters, TYPE$3, _Attribute.defaultValues(TYPE$3));
    this.values = getParametersValue(parameters, VALUES$1, _Attribute.defaultValues(VALUES$1));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TYPE$3:
        return EMPTY_STRING;
      case VALUES$1:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TYPE$3:
        return memberValue === EMPTY_STRING;
      case VALUES$1:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.type || EMPTY_STRING }),
        new asn1js.Set({
          name: names.setName || EMPTY_STRING,
          value: [
            new asn1js.Repeated({
              name: names.values || EMPTY_STRING,
              value: new asn1js.Any()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1s);
    const asn1 = asn1js.compareSchema(schema, schema, _Attribute.schema({
      names: {
        type: TYPE$3,
        values: VALUES$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.type = asn1.result.type.valueBlock.toString();
    this.values = asn1.result.values;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.type }),
        new asn1js.Set({
          value: this.values
        })
      ]
    });
  }
  toJSON() {
    return {
      type: this.type,
      values: Array.from(this.values, (o) => o.toJSON())
    };
  }
};
Attribute.CLASS_NAME = "Attribute";
var NOT_BEFORE_TIME = "notBeforeTime";
var NOT_AFTER_TIME = "notAfterTime";
var CLEAR_PROPS$1r = [
  NOT_BEFORE_TIME,
  NOT_AFTER_TIME
];
var AttCertValidityPeriod = class _AttCertValidityPeriod extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.notBeforeTime = getParametersValue(parameters, NOT_BEFORE_TIME, _AttCertValidityPeriod.defaultValues(NOT_BEFORE_TIME));
    this.notAfterTime = getParametersValue(parameters, NOT_AFTER_TIME, _AttCertValidityPeriod.defaultValues(NOT_AFTER_TIME));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case NOT_BEFORE_TIME:
      case NOT_AFTER_TIME:
        return new Date(0, 0, 0);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.GeneralizedTime({ name: names.notBeforeTime || EMPTY_STRING }),
        new asn1js.GeneralizedTime({ name: names.notAfterTime || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1r);
    const asn1 = asn1js.compareSchema(schema, schema, _AttCertValidityPeriod.schema({
      names: {
        notBeforeTime: NOT_BEFORE_TIME,
        notAfterTime: NOT_AFTER_TIME
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.notBeforeTime = asn1.result.notBeforeTime.toDate();
    this.notAfterTime = asn1.result.notAfterTime.toDate();
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.GeneralizedTime({ valueDate: this.notBeforeTime }),
        new asn1js.GeneralizedTime({ valueDate: this.notAfterTime })
      ]
    });
  }
  toJSON() {
    return {
      notBeforeTime: this.notBeforeTime,
      notAfterTime: this.notAfterTime
    };
  }
};
AttCertValidityPeriod.CLASS_NAME = "AttCertValidityPeriod";
var NAMES = "names";
var GENERAL_NAMES = "generalNames";
var GeneralNames = class _GeneralNames extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.names = getParametersValue(parameters, NAMES, _GeneralNames.defaultValues(NAMES));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case "names":
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}, optional = false) {
    const names = getParametersValue(parameters, NAMES, {});
    return new asn1js.Sequence({
      optional,
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.generalNames || EMPTY_STRING,
          value: GeneralName.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      NAMES,
      GENERAL_NAMES
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _GeneralNames.schema({
      names: {
        blockName: NAMES,
        generalNames: GENERAL_NAMES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.names = Array.from(asn1.result.generalNames, (element) => new GeneralName({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.names, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      names: Array.from(this.names, (o) => o.toJSON())
    };
  }
};
GeneralNames.CLASS_NAME = "GeneralNames";
var id_SubjectDirectoryAttributes = "2.5.29.9";
var id_SubjectKeyIdentifier = "2.5.29.14";
var id_KeyUsage = "2.5.29.15";
var id_PrivateKeyUsagePeriod = "2.5.29.16";
var id_SubjectAltName = "2.5.29.17";
var id_IssuerAltName = "2.5.29.18";
var id_BasicConstraints = "2.5.29.19";
var id_CRLNumber = "2.5.29.20";
var id_BaseCRLNumber = "2.5.29.27";
var id_CRLReason = "2.5.29.21";
var id_InvalidityDate = "2.5.29.24";
var id_IssuingDistributionPoint = "2.5.29.28";
var id_CertificateIssuer = "2.5.29.29";
var id_NameConstraints = "2.5.29.30";
var id_CRLDistributionPoints = "2.5.29.31";
var id_FreshestCRL = "2.5.29.46";
var id_CertificatePolicies = "2.5.29.32";
var id_AnyPolicy = "2.5.29.32.0";
var id_MicrosoftAppPolicies = "1.3.6.1.4.1.311.21.10";
var id_PolicyMappings = "2.5.29.33";
var id_AuthorityKeyIdentifier = "2.5.29.35";
var id_PolicyConstraints = "2.5.29.36";
var id_ExtKeyUsage = "2.5.29.37";
var id_InhibitAnyPolicy = "2.5.29.54";
var id_AuthorityInfoAccess = "1.3.6.1.5.5.7.1.1";
var id_SubjectInfoAccess = "1.3.6.1.5.5.7.1.11";
var id_SignedCertificateTimestampList = "1.3.6.1.4.1.11129.2.4.2";
var id_MicrosoftCertTemplateV2 = "1.3.6.1.4.1.311.21.7";
var id_MicrosoftCaVersion = "1.3.6.1.4.1.311.21.1";
var id_QCStatements = "1.3.6.1.5.5.7.1.3";
var id_ContentType_Data = "1.2.840.113549.1.7.1";
var id_ContentType_SignedData = "1.2.840.113549.1.7.2";
var id_ContentType_EnvelopedData = "1.2.840.113549.1.7.3";
var id_ContentType_EncryptedData = "1.2.840.113549.1.7.6";
var id_eContentType_TSTInfo = "1.2.840.113549.1.9.16.1.4";
var id_CertBag_X509Certificate = "1.2.840.113549.1.9.22.1";
var id_CertBag_SDSICertificate = "1.2.840.113549.1.9.22.2";
var id_CertBag_AttributeCertificate = "1.2.840.113549.1.9.22.3";
var id_CRLBag_X509CRL = "1.2.840.113549.1.9.23.1";
var id_pkix = "1.3.6.1.5.5.7";
var id_ad = `${id_pkix}.48`;
var id_PKIX_OCSP_Basic = `${id_ad}.1.1`;
var id_ad_caIssuers = `${id_ad}.2`;
var id_ad_ocsp = `${id_ad}.1`;
var KEY_IDENTIFIER$1 = "keyIdentifier";
var AUTHORITY_CERT_ISSUER = "authorityCertIssuer";
var AUTHORITY_CERT_SERIAL_NUMBER = "authorityCertSerialNumber";
var CLEAR_PROPS$1q = [
  KEY_IDENTIFIER$1,
  AUTHORITY_CERT_ISSUER,
  AUTHORITY_CERT_SERIAL_NUMBER
];
var AuthorityKeyIdentifier = class _AuthorityKeyIdentifier extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (KEY_IDENTIFIER$1 in parameters) {
      this.keyIdentifier = getParametersValue(parameters, KEY_IDENTIFIER$1, _AuthorityKeyIdentifier.defaultValues(KEY_IDENTIFIER$1));
    }
    if (AUTHORITY_CERT_ISSUER in parameters) {
      this.authorityCertIssuer = getParametersValue(parameters, AUTHORITY_CERT_ISSUER, _AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_ISSUER));
    }
    if (AUTHORITY_CERT_SERIAL_NUMBER in parameters) {
      this.authorityCertSerialNumber = getParametersValue(parameters, AUTHORITY_CERT_SERIAL_NUMBER, _AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_SERIAL_NUMBER));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case KEY_IDENTIFIER$1:
        return new asn1js.OctetString();
      case AUTHORITY_CERT_ISSUER:
        return [];
      case AUTHORITY_CERT_SERIAL_NUMBER:
        return new asn1js.Integer();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Primitive({
          name: names.keyIdentifier || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          }
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [
            new asn1js.Repeated({
              name: names.authorityCertIssuer || EMPTY_STRING,
              value: GeneralName.schema()
            })
          ]
        }),
        new asn1js.Primitive({
          name: names.authorityCertSerialNumber || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1q);
    const asn1 = asn1js.compareSchema(schema, schema, _AuthorityKeyIdentifier.schema({
      names: {
        keyIdentifier: KEY_IDENTIFIER$1,
        authorityCertIssuer: AUTHORITY_CERT_ISSUER,
        authorityCertSerialNumber: AUTHORITY_CERT_SERIAL_NUMBER
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (KEY_IDENTIFIER$1 in asn1.result)
      this.keyIdentifier = new asn1js.OctetString({ valueHex: asn1.result.keyIdentifier.valueBlock.valueHex });
    if (AUTHORITY_CERT_ISSUER in asn1.result)
      this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, (o) => new GeneralName({ schema: o }));
    if (AUTHORITY_CERT_SERIAL_NUMBER in asn1.result)
      this.authorityCertSerialNumber = new asn1js.Integer({ valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex });
  }
  toSchema() {
    const outputArray = [];
    if (this.keyIdentifier) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        valueHex: this.keyIdentifier.valueBlock.valueHexView
      }));
    }
    if (this.authorityCertIssuer) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: Array.from(this.authorityCertIssuer, (o) => o.toSchema())
      }));
    }
    if (this.authorityCertSerialNumber) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        valueHex: this.authorityCertSerialNumber.valueBlock.valueHexView
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const object2 = {};
    if (this.keyIdentifier) {
      object2.keyIdentifier = this.keyIdentifier.toJSON();
    }
    if (this.authorityCertIssuer) {
      object2.authorityCertIssuer = Array.from(this.authorityCertIssuer, (o) => o.toJSON());
    }
    if (this.authorityCertSerialNumber) {
      object2.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();
    }
    return object2;
  }
};
AuthorityKeyIdentifier.CLASS_NAME = "AuthorityKeyIdentifier";
var PATH_LENGTH_CONSTRAINT = "pathLenConstraint";
var CA = "cA";
var BasicConstraints = class _BasicConstraints extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.cA = getParametersValue(parameters, CA, false);
    if (PATH_LENGTH_CONSTRAINT in parameters) {
      this.pathLenConstraint = getParametersValue(parameters, PATH_LENGTH_CONSTRAINT, 0);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CA:
        return false;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Boolean({
          optional: true,
          name: names.cA || EMPTY_STRING
        }),
        new asn1js.Integer({
          optional: true,
          name: names.pathLenConstraint || EMPTY_STRING
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      CA,
      PATH_LENGTH_CONSTRAINT
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _BasicConstraints.schema({
      names: {
        cA: CA,
        pathLenConstraint: PATH_LENGTH_CONSTRAINT
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (CA in asn1.result) {
      this.cA = asn1.result.cA.valueBlock.value;
    }
    if (PATH_LENGTH_CONSTRAINT in asn1.result) {
      if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) {
        this.pathLenConstraint = asn1.result.pathLenConstraint;
      } else {
        this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
      }
    }
  }
  toSchema() {
    const outputArray = [];
    if (this.cA !== _BasicConstraints.defaultValues(CA))
      outputArray.push(new asn1js.Boolean({ value: this.cA }));
    if (PATH_LENGTH_CONSTRAINT in this) {
      if (this.pathLenConstraint instanceof asn1js.Integer) {
        outputArray.push(this.pathLenConstraint);
      } else {
        outputArray.push(new asn1js.Integer({ value: this.pathLenConstraint }));
      }
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const object2 = {};
    if (this.cA !== _BasicConstraints.defaultValues(CA)) {
      object2.cA = this.cA;
    }
    if (PATH_LENGTH_CONSTRAINT in this) {
      if (this.pathLenConstraint instanceof asn1js.Integer) {
        object2.pathLenConstraint = this.pathLenConstraint.toJSON();
      } else {
        object2.pathLenConstraint = this.pathLenConstraint;
      }
    }
    return object2;
  }
};
BasicConstraints.CLASS_NAME = "BasicConstraints";
var CERTIFICATE_INDEX = "certificateIndex";
var KEY_INDEX = "keyIndex";
var CAVersion = class _CAVersion extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.certificateIndex = getParametersValue(parameters, CERTIFICATE_INDEX, _CAVersion.defaultValues(CERTIFICATE_INDEX));
    this.keyIndex = getParametersValue(parameters, KEY_INDEX, _CAVersion.defaultValues(KEY_INDEX));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CERTIFICATE_INDEX:
      case KEY_INDEX:
        return 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema() {
    return new asn1js.Integer();
  }
  fromSchema(schema) {
    if (schema.constructor.blockName() !== asn1js.Integer.blockName()) {
      throw new Error("Object's schema was not verified against input data for CAVersion");
    }
    let value = schema.valueBlock.valueHex.slice(0);
    const valueView = new Uint8Array(value);
    switch (true) {
      case value.byteLength < 4:
        {
          const tempValue = new ArrayBuffer(4);
          const tempValueView = new Uint8Array(tempValue);
          tempValueView.set(valueView, 4 - value.byteLength);
          value = tempValue.slice(0);
        }
        break;
      case value.byteLength > 4:
        {
          const tempValue = new ArrayBuffer(4);
          const tempValueView = new Uint8Array(tempValue);
          tempValueView.set(valueView.slice(0, 4));
          value = tempValue.slice(0);
        }
        break;
    }
    const keyIndexBuffer = value.slice(0, 2);
    const keyIndexView8 = new Uint8Array(keyIndexBuffer);
    let temp = keyIndexView8[0];
    keyIndexView8[0] = keyIndexView8[1];
    keyIndexView8[1] = temp;
    const keyIndexView16 = new Uint16Array(keyIndexBuffer);
    this.keyIndex = keyIndexView16[0];
    const certificateIndexBuffer = value.slice(2);
    const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
    temp = certificateIndexView8[0];
    certificateIndexView8[0] = certificateIndexView8[1];
    certificateIndexView8[1] = temp;
    const certificateIndexView16 = new Uint16Array(certificateIndexBuffer);
    this.certificateIndex = certificateIndexView16[0];
  }
  toSchema() {
    const certificateIndexBuffer = new ArrayBuffer(2);
    const certificateIndexView = new Uint16Array(certificateIndexBuffer);
    certificateIndexView[0] = this.certificateIndex;
    const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
    let temp = certificateIndexView8[0];
    certificateIndexView8[0] = certificateIndexView8[1];
    certificateIndexView8[1] = temp;
    const keyIndexBuffer = new ArrayBuffer(2);
    const keyIndexView = new Uint16Array(keyIndexBuffer);
    keyIndexView[0] = this.keyIndex;
    const keyIndexView8 = new Uint8Array(keyIndexBuffer);
    temp = keyIndexView8[0];
    keyIndexView8[0] = keyIndexView8[1];
    keyIndexView8[1] = temp;
    return new asn1js.Integer({
      valueHex: utilConcatBuf(keyIndexBuffer, certificateIndexBuffer)
    });
  }
  toJSON() {
    return {
      certificateIndex: this.certificateIndex,
      keyIndex: this.keyIndex
    };
  }
};
CAVersion.CLASS_NAME = "CAVersion";
var POLICY_QUALIFIER_ID = "policyQualifierId";
var QUALIFIER = "qualifier";
var CLEAR_PROPS$1p = [
  POLICY_QUALIFIER_ID,
  QUALIFIER
];
var PolicyQualifierInfo = class _PolicyQualifierInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.policyQualifierId = getParametersValue(parameters, POLICY_QUALIFIER_ID, _PolicyQualifierInfo.defaultValues(POLICY_QUALIFIER_ID));
    this.qualifier = getParametersValue(parameters, QUALIFIER, _PolicyQualifierInfo.defaultValues(QUALIFIER));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case POLICY_QUALIFIER_ID:
        return EMPTY_STRING;
      case QUALIFIER:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.policyQualifierId || EMPTY_STRING }),
        new asn1js.Any({ name: names.qualifier || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1p);
    const asn1 = asn1js.compareSchema(schema, schema, _PolicyQualifierInfo.schema({
      names: {
        policyQualifierId: POLICY_QUALIFIER_ID,
        qualifier: QUALIFIER
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
    this.qualifier = asn1.result.qualifier;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.policyQualifierId }),
        this.qualifier
      ]
    });
  }
  toJSON() {
    return {
      policyQualifierId: this.policyQualifierId,
      qualifier: this.qualifier.toJSON()
    };
  }
};
PolicyQualifierInfo.CLASS_NAME = "PolicyQualifierInfo";
var POLICY_IDENTIFIER = "policyIdentifier";
var POLICY_QUALIFIERS = "policyQualifiers";
var CLEAR_PROPS$1o = [
  POLICY_IDENTIFIER,
  POLICY_QUALIFIERS
];
var PolicyInformation = class _PolicyInformation extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.policyIdentifier = getParametersValue(parameters, POLICY_IDENTIFIER, _PolicyInformation.defaultValues(POLICY_IDENTIFIER));
    if (POLICY_QUALIFIERS in parameters) {
      this.policyQualifiers = getParametersValue(parameters, POLICY_QUALIFIERS, _PolicyInformation.defaultValues(POLICY_QUALIFIERS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case POLICY_IDENTIFIER:
        return EMPTY_STRING;
      case POLICY_QUALIFIERS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.policyIdentifier || EMPTY_STRING }),
        new asn1js.Sequence({
          optional: true,
          value: [
            new asn1js.Repeated({
              name: names.policyQualifiers || EMPTY_STRING,
              value: PolicyQualifierInfo.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1o);
    const asn1 = asn1js.compareSchema(schema, schema, _PolicyInformation.schema({
      names: {
        policyIdentifier: POLICY_IDENTIFIER,
        policyQualifiers: POLICY_QUALIFIERS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();
    if (POLICY_QUALIFIERS in asn1.result) {
      this.policyQualifiers = Array.from(asn1.result.policyQualifiers, (element) => new PolicyQualifierInfo({ schema: element }));
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.policyIdentifier }));
    if (this.policyQualifiers) {
      outputArray.push(new asn1js.Sequence({
        value: Array.from(this.policyQualifiers, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      policyIdentifier: this.policyIdentifier
    };
    if (this.policyQualifiers)
      res.policyQualifiers = Array.from(this.policyQualifiers, (o) => o.toJSON());
    return res;
  }
};
PolicyInformation.CLASS_NAME = "PolicyInformation";
var CERTIFICATE_POLICIES = "certificatePolicies";
var CLEAR_PROPS$1n = [
  CERTIFICATE_POLICIES
];
var CertificatePolicies = class _CertificatePolicies extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.certificatePolicies = getParametersValue(parameters, CERTIFICATE_POLICIES, _CertificatePolicies.defaultValues(CERTIFICATE_POLICIES));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CERTIFICATE_POLICIES:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.certificatePolicies || EMPTY_STRING,
          value: PolicyInformation.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1n);
    const asn1 = asn1js.compareSchema(schema, schema, _CertificatePolicies.schema({
      names: {
        certificatePolicies: CERTIFICATE_POLICIES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.certificatePolicies = Array.from(asn1.result.certificatePolicies, (element) => new PolicyInformation({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.certificatePolicies, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      certificatePolicies: Array.from(this.certificatePolicies, (o) => o.toJSON())
    };
  }
};
CertificatePolicies.CLASS_NAME = "CertificatePolicies";
var TEMPLATE_ID = "templateID";
var TEMPLATE_MAJOR_VERSION = "templateMajorVersion";
var TEMPLATE_MINOR_VERSION = "templateMinorVersion";
var CLEAR_PROPS$1m = [
  TEMPLATE_ID,
  TEMPLATE_MAJOR_VERSION,
  TEMPLATE_MINOR_VERSION
];
var CertificateTemplate = class _CertificateTemplate extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.templateID = getParametersValue(parameters, TEMPLATE_ID, _CertificateTemplate.defaultValues(TEMPLATE_ID));
    if (TEMPLATE_MAJOR_VERSION in parameters) {
      this.templateMajorVersion = getParametersValue(parameters, TEMPLATE_MAJOR_VERSION, _CertificateTemplate.defaultValues(TEMPLATE_MAJOR_VERSION));
    }
    if (TEMPLATE_MINOR_VERSION in parameters) {
      this.templateMinorVersion = getParametersValue(parameters, TEMPLATE_MINOR_VERSION, _CertificateTemplate.defaultValues(TEMPLATE_MINOR_VERSION));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TEMPLATE_ID:
        return EMPTY_STRING;
      case TEMPLATE_MAJOR_VERSION:
      case TEMPLATE_MINOR_VERSION:
        return 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.templateID || EMPTY_STRING }),
        new asn1js.Integer({
          name: names.templateMajorVersion || EMPTY_STRING,
          optional: true
        }),
        new asn1js.Integer({
          name: names.templateMinorVersion || EMPTY_STRING,
          optional: true
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1m);
    const asn1 = asn1js.compareSchema(schema, schema, _CertificateTemplate.schema({
      names: {
        templateID: TEMPLATE_ID,
        templateMajorVersion: TEMPLATE_MAJOR_VERSION,
        templateMinorVersion: TEMPLATE_MINOR_VERSION
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.templateID = asn1.result.templateID.valueBlock.toString();
    if (TEMPLATE_MAJOR_VERSION in asn1.result) {
      this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;
    }
    if (TEMPLATE_MINOR_VERSION in asn1.result) {
      this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec;
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.templateID }));
    if (TEMPLATE_MAJOR_VERSION in this) {
      outputArray.push(new asn1js.Integer({ value: this.templateMajorVersion }));
    }
    if (TEMPLATE_MINOR_VERSION in this) {
      outputArray.push(new asn1js.Integer({ value: this.templateMinorVersion }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      templateID: this.templateID
    };
    if (TEMPLATE_MAJOR_VERSION in this)
      res.templateMajorVersion = this.templateMajorVersion;
    if (TEMPLATE_MINOR_VERSION in this)
      res.templateMinorVersion = this.templateMinorVersion;
    return res;
  }
};
var DISTRIBUTION_POINT$1 = "distributionPoint";
var DISTRIBUTION_POINT_NAMES$1 = "distributionPointNames";
var REASONS = "reasons";
var CRL_ISSUER = "cRLIssuer";
var CRL_ISSUER_NAMES = "cRLIssuerNames";
var CLEAR_PROPS$1l = [
  DISTRIBUTION_POINT$1,
  DISTRIBUTION_POINT_NAMES$1,
  REASONS,
  CRL_ISSUER,
  CRL_ISSUER_NAMES
];
var DistributionPoint = class _DistributionPoint extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (DISTRIBUTION_POINT$1 in parameters) {
      this.distributionPoint = getParametersValue(parameters, DISTRIBUTION_POINT$1, _DistributionPoint.defaultValues(DISTRIBUTION_POINT$1));
    }
    if (REASONS in parameters) {
      this.reasons = getParametersValue(parameters, REASONS, _DistributionPoint.defaultValues(REASONS));
    }
    if (CRL_ISSUER in parameters) {
      this.cRLIssuer = getParametersValue(parameters, CRL_ISSUER, _DistributionPoint.defaultValues(CRL_ISSUER));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case DISTRIBUTION_POINT$1:
        return [];
      case REASONS:
        return new asn1js.BitString();
      case CRL_ISSUER:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Choice({
              value: [
                new asn1js.Constructed({
                  name: names.distributionPoint || EMPTY_STRING,
                  optional: true,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [
                    new asn1js.Repeated({
                      name: names.distributionPointNames || EMPTY_STRING,
                      value: GeneralName.schema()
                    })
                  ]
                }),
                new asn1js.Constructed({
                  name: names.distributionPoint || EMPTY_STRING,
                  optional: true,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: RelativeDistinguishedNames.schema().valueBlock.value
                })
              ]
            })
          ]
        }),
        new asn1js.Primitive({
          name: names.reasons || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          }
        }),
        new asn1js.Constructed({
          name: names.cRLIssuer || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [
            new asn1js.Repeated({
              name: names.cRLIssuerNames || EMPTY_STRING,
              value: GeneralName.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1l);
    const asn1 = asn1js.compareSchema(schema, schema, _DistributionPoint.schema({
      names: {
        distributionPoint: DISTRIBUTION_POINT$1,
        distributionPointNames: DISTRIBUTION_POINT_NAMES$1,
        reasons: REASONS,
        cRLIssuer: CRL_ISSUER,
        cRLIssuerNames: CRL_ISSUER_NAMES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (DISTRIBUTION_POINT$1 in asn1.result) {
      if (asn1.result.distributionPoint.idBlock.tagNumber === 0) {
        this.distributionPoint = Array.from(asn1.result.distributionPointNames, (element) => new GeneralName({ schema: element }));
      }
      if (asn1.result.distributionPoint.idBlock.tagNumber === 1) {
        this.distributionPoint = new RelativeDistinguishedNames({
          schema: new asn1js.Sequence({
            value: asn1.result.distributionPoint.valueBlock.value
          })
        });
      }
    }
    if (REASONS in asn1.result) {
      this.reasons = new asn1js.BitString({ valueHex: asn1.result.reasons.valueBlock.valueHex });
    }
    if (CRL_ISSUER in asn1.result) {
      this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, (element) => new GeneralName({ schema: element }));
    }
  }
  toSchema() {
    const outputArray = [];
    if (this.distributionPoint) {
      let internalValue;
      if (this.distributionPoint instanceof Array) {
        internalValue = new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: Array.from(this.distributionPoint, (o) => o.toSchema())
        });
      } else {
        internalValue = new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [this.distributionPoint.toSchema()]
        });
      }
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [internalValue]
      }));
    }
    if (this.reasons) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        valueHex: this.reasons.valueBlock.valueHexView
      }));
    }
    if (this.cRLIssuer) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        value: Array.from(this.cRLIssuer, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const object2 = {};
    if (this.distributionPoint) {
      if (this.distributionPoint instanceof Array) {
        object2.distributionPoint = Array.from(this.distributionPoint, (o) => o.toJSON());
      } else {
        object2.distributionPoint = this.distributionPoint.toJSON();
      }
    }
    if (this.reasons) {
      object2.reasons = this.reasons.toJSON();
    }
    if (this.cRLIssuer) {
      object2.cRLIssuer = Array.from(this.cRLIssuer, (o) => o.toJSON());
    }
    return object2;
  }
};
DistributionPoint.CLASS_NAME = "DistributionPoint";
var DISTRIBUTION_POINTS = "distributionPoints";
var CLEAR_PROPS$1k = [
  DISTRIBUTION_POINTS
];
var CRLDistributionPoints = class _CRLDistributionPoints extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.distributionPoints = getParametersValue(parameters, DISTRIBUTION_POINTS, _CRLDistributionPoints.defaultValues(DISTRIBUTION_POINTS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case DISTRIBUTION_POINTS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.distributionPoints || EMPTY_STRING,
          value: DistributionPoint.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1k);
    const asn1 = asn1js.compareSchema(schema, schema, _CRLDistributionPoints.schema({
      names: {
        distributionPoints: DISTRIBUTION_POINTS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.distributionPoints = Array.from(asn1.result.distributionPoints, (element) => new DistributionPoint({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.distributionPoints, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      distributionPoints: Array.from(this.distributionPoints, (o) => o.toJSON())
    };
  }
};
CRLDistributionPoints.CLASS_NAME = "CRLDistributionPoints";
var KEY_PURPOSES = "keyPurposes";
var CLEAR_PROPS$1j = [
  KEY_PURPOSES
];
var ExtKeyUsage = class _ExtKeyUsage extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.keyPurposes = getParametersValue(parameters, KEY_PURPOSES, _ExtKeyUsage.defaultValues(KEY_PURPOSES));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case KEY_PURPOSES:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.keyPurposes || EMPTY_STRING,
          value: new asn1js.ObjectIdentifier()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1j);
    const asn1 = asn1js.compareSchema(schema, schema, _ExtKeyUsage.schema({
      names: {
        keyPurposes: KEY_PURPOSES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.keyPurposes = Array.from(asn1.result.keyPurposes, (element) => element.valueBlock.toString());
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.keyPurposes, (element) => new asn1js.ObjectIdentifier({ value: element }))
    });
  }
  toJSON() {
    return {
      keyPurposes: Array.from(this.keyPurposes)
    };
  }
};
ExtKeyUsage.CLASS_NAME = "ExtKeyUsage";
var ACCESS_DESCRIPTIONS = "accessDescriptions";
var InfoAccess = class _InfoAccess extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.accessDescriptions = getParametersValue(parameters, ACCESS_DESCRIPTIONS, _InfoAccess.defaultValues(ACCESS_DESCRIPTIONS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ACCESS_DESCRIPTIONS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.accessDescriptions || EMPTY_STRING,
          value: AccessDescription.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      ACCESS_DESCRIPTIONS
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _InfoAccess.schema({
      names: {
        accessDescriptions: ACCESS_DESCRIPTIONS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.accessDescriptions = Array.from(asn1.result.accessDescriptions, (element) => new AccessDescription({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.accessDescriptions, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      accessDescriptions: Array.from(this.accessDescriptions, (o) => o.toJSON())
    };
  }
};
InfoAccess.CLASS_NAME = "InfoAccess";
var DISTRIBUTION_POINT = "distributionPoint";
var DISTRIBUTION_POINT_NAMES = "distributionPointNames";
var ONLY_CONTAINS_USER_CERTS = "onlyContainsUserCerts";
var ONLY_CONTAINS_CA_CERTS = "onlyContainsCACerts";
var ONLY_SOME_REASON = "onlySomeReasons";
var INDIRECT_CRL = "indirectCRL";
var ONLY_CONTAINS_ATTRIBUTE_CERTS = "onlyContainsAttributeCerts";
var CLEAR_PROPS$1i = [
  DISTRIBUTION_POINT,
  DISTRIBUTION_POINT_NAMES,
  ONLY_CONTAINS_USER_CERTS,
  ONLY_CONTAINS_CA_CERTS,
  ONLY_SOME_REASON,
  INDIRECT_CRL,
  ONLY_CONTAINS_ATTRIBUTE_CERTS
];
var IssuingDistributionPoint = class _IssuingDistributionPoint extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (DISTRIBUTION_POINT in parameters) {
      this.distributionPoint = getParametersValue(parameters, DISTRIBUTION_POINT, _IssuingDistributionPoint.defaultValues(DISTRIBUTION_POINT));
    }
    this.onlyContainsUserCerts = getParametersValue(parameters, ONLY_CONTAINS_USER_CERTS, _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS));
    this.onlyContainsCACerts = getParametersValue(parameters, ONLY_CONTAINS_CA_CERTS, _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS));
    if (ONLY_SOME_REASON in parameters) {
      this.onlySomeReasons = getParametersValue(parameters, ONLY_SOME_REASON, _IssuingDistributionPoint.defaultValues(ONLY_SOME_REASON));
    }
    this.indirectCRL = getParametersValue(parameters, INDIRECT_CRL, _IssuingDistributionPoint.defaultValues(INDIRECT_CRL));
    this.onlyContainsAttributeCerts = getParametersValue(parameters, ONLY_CONTAINS_ATTRIBUTE_CERTS, _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case DISTRIBUTION_POINT:
        return [];
      case ONLY_CONTAINS_USER_CERTS:
        return false;
      case ONLY_CONTAINS_CA_CERTS:
        return false;
      case ONLY_SOME_REASON:
        return 0;
      case INDIRECT_CRL:
        return false;
      case ONLY_CONTAINS_ATTRIBUTE_CERTS:
        return false;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Choice({
              value: [
                new asn1js.Constructed({
                  name: names.distributionPoint || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [
                    new asn1js.Repeated({
                      name: names.distributionPointNames || EMPTY_STRING,
                      value: GeneralName.schema()
                    })
                  ]
                }),
                new asn1js.Constructed({
                  name: names.distributionPoint || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: RelativeDistinguishedNames.schema().valueBlock.value
                })
              ]
            })
          ]
        }),
        new asn1js.Primitive({
          name: names.onlyContainsUserCerts || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          }
        }),
        new asn1js.Primitive({
          name: names.onlyContainsCACerts || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          }
        }),
        new asn1js.Primitive({
          name: names.onlySomeReasons || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 3
          }
        }),
        new asn1js.Primitive({
          name: names.indirectCRL || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 4
          }
        }),
        new asn1js.Primitive({
          name: names.onlyContainsAttributeCerts || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 5
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1i);
    const asn1 = asn1js.compareSchema(schema, schema, _IssuingDistributionPoint.schema({
      names: {
        distributionPoint: DISTRIBUTION_POINT,
        distributionPointNames: DISTRIBUTION_POINT_NAMES,
        onlyContainsUserCerts: ONLY_CONTAINS_USER_CERTS,
        onlyContainsCACerts: ONLY_CONTAINS_CA_CERTS,
        onlySomeReasons: ONLY_SOME_REASON,
        indirectCRL: INDIRECT_CRL,
        onlyContainsAttributeCerts: ONLY_CONTAINS_ATTRIBUTE_CERTS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (DISTRIBUTION_POINT in asn1.result) {
      switch (true) {
        case asn1.result.distributionPoint.idBlock.tagNumber === 0:
          this.distributionPoint = Array.from(asn1.result.distributionPointNames, (element) => new GeneralName({ schema: element }));
          break;
        case asn1.result.distributionPoint.idBlock.tagNumber === 1:
          {
            this.distributionPoint = new RelativeDistinguishedNames({
              schema: new asn1js.Sequence({
                value: asn1.result.distributionPoint.valueBlock.value
              })
            });
          }
          break;
        default:
          throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
      }
    }
    if (ONLY_CONTAINS_USER_CERTS in asn1.result) {
      const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
      this.onlyContainsUserCerts = view[0] !== 0;
    }
    if (ONLY_CONTAINS_CA_CERTS in asn1.result) {
      const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
      this.onlyContainsCACerts = view[0] !== 0;
    }
    if (ONLY_SOME_REASON in asn1.result) {
      const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
      this.onlySomeReasons = view[0];
    }
    if (INDIRECT_CRL in asn1.result) {
      const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
      this.indirectCRL = view[0] !== 0;
    }
    if (ONLY_CONTAINS_ATTRIBUTE_CERTS in asn1.result) {
      const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
      this.onlyContainsAttributeCerts = view[0] !== 0;
    }
  }
  toSchema() {
    const outputArray = [];
    if (this.distributionPoint) {
      let value;
      if (this.distributionPoint instanceof Array) {
        value = new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: Array.from(this.distributionPoint, (o) => o.toSchema())
        });
      } else {
        value = this.distributionPoint.toSchema();
        value.idBlock.tagClass = 3;
        value.idBlock.tagNumber = 1;
      }
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [value]
      }));
    }
    if (this.onlyContainsUserCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        valueHex: new Uint8Array([255]).buffer
      }));
    }
    if (this.onlyContainsCACerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        valueHex: new Uint8Array([255]).buffer
      }));
    }
    if (this.onlySomeReasons !== void 0) {
      const buffer2 = new ArrayBuffer(1);
      const view = new Uint8Array(buffer2);
      view[0] = this.onlySomeReasons;
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        valueHex: buffer2
      }));
    }
    if (this.indirectCRL !== _IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 4
        },
        valueHex: new Uint8Array([255]).buffer
      }));
    }
    if (this.onlyContainsAttributeCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 5
        },
        valueHex: new Uint8Array([255]).buffer
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const obj = {};
    if (this.distributionPoint) {
      if (this.distributionPoint instanceof Array) {
        obj.distributionPoint = Array.from(this.distributionPoint, (o) => o.toJSON());
      } else {
        obj.distributionPoint = this.distributionPoint.toJSON();
      }
    }
    if (this.onlyContainsUserCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
      obj.onlyContainsUserCerts = this.onlyContainsUserCerts;
    }
    if (this.onlyContainsCACerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
      obj.onlyContainsCACerts = this.onlyContainsCACerts;
    }
    if (ONLY_SOME_REASON in this) {
      obj.onlySomeReasons = this.onlySomeReasons;
    }
    if (this.indirectCRL !== _IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
      obj.indirectCRL = this.indirectCRL;
    }
    if (this.onlyContainsAttributeCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
      obj.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
    }
    return obj;
  }
};
IssuingDistributionPoint.CLASS_NAME = "IssuingDistributionPoint";
var BASE = "base";
var MINIMUM = "minimum";
var MAXIMUM = "maximum";
var CLEAR_PROPS$1h = [
  BASE,
  MINIMUM,
  MAXIMUM
];
var GeneralSubtree = class _GeneralSubtree extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.base = getParametersValue(parameters, BASE, _GeneralSubtree.defaultValues(BASE));
    this.minimum = getParametersValue(parameters, MINIMUM, _GeneralSubtree.defaultValues(MINIMUM));
    if (MAXIMUM in parameters) {
      this.maximum = getParametersValue(parameters, MAXIMUM, _GeneralSubtree.defaultValues(MAXIMUM));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case BASE:
        return new GeneralName();
      case MINIMUM:
        return 0;
      case MAXIMUM:
        return 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        GeneralName.schema(names.base || {}),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Integer({ name: names.minimum || EMPTY_STRING })]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [new asn1js.Integer({ name: names.maximum || EMPTY_STRING })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1h);
    const asn1 = asn1js.compareSchema(schema, schema, _GeneralSubtree.schema({
      names: {
        base: {
          names: {
            blockName: BASE
          }
        },
        minimum: MINIMUM,
        maximum: MAXIMUM
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.base = new GeneralName({ schema: asn1.result.base });
    if (MINIMUM in asn1.result) {
      if (asn1.result.minimum.valueBlock.isHexOnly)
        this.minimum = asn1.result.minimum;
      else
        this.minimum = asn1.result.minimum.valueBlock.valueDec;
    }
    if (MAXIMUM in asn1.result) {
      if (asn1.result.maximum.valueBlock.isHexOnly)
        this.maximum = asn1.result.maximum;
      else
        this.maximum = asn1.result.maximum.valueBlock.valueDec;
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.base.toSchema());
    if (this.minimum !== 0) {
      let valueMinimum = 0;
      if (this.minimum instanceof asn1js.Integer) {
        valueMinimum = this.minimum;
      } else {
        valueMinimum = new asn1js.Integer({ value: this.minimum });
      }
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [valueMinimum]
      }));
    }
    if (MAXIMUM in this) {
      let valueMaximum = 0;
      if (this.maximum instanceof asn1js.Integer) {
        valueMaximum = this.maximum;
      } else {
        valueMaximum = new asn1js.Integer({ value: this.maximum });
      }
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [valueMaximum]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      base: this.base.toJSON()
    };
    if (this.minimum !== 0) {
      if (typeof this.minimum === "number") {
        res.minimum = this.minimum;
      } else {
        res.minimum = this.minimum.toJSON();
      }
    }
    if (this.maximum !== void 0) {
      if (typeof this.maximum === "number") {
        res.maximum = this.maximum;
      } else {
        res.maximum = this.maximum.toJSON();
      }
    }
    return res;
  }
};
GeneralSubtree.CLASS_NAME = "GeneralSubtree";
var PERMITTED_SUBTREES = "permittedSubtrees";
var EXCLUDED_SUBTREES = "excludedSubtrees";
var CLEAR_PROPS$1g = [
  PERMITTED_SUBTREES,
  EXCLUDED_SUBTREES
];
var NameConstraints = class _NameConstraints extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (PERMITTED_SUBTREES in parameters) {
      this.permittedSubtrees = getParametersValue(parameters, PERMITTED_SUBTREES, _NameConstraints.defaultValues(PERMITTED_SUBTREES));
    }
    if (EXCLUDED_SUBTREES in parameters) {
      this.excludedSubtrees = getParametersValue(parameters, EXCLUDED_SUBTREES, _NameConstraints.defaultValues(EXCLUDED_SUBTREES));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case PERMITTED_SUBTREES:
      case EXCLUDED_SUBTREES:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Repeated({
              name: names.permittedSubtrees || EMPTY_STRING,
              value: GeneralSubtree.schema()
            })
          ]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [
            new asn1js.Repeated({
              name: names.excludedSubtrees || EMPTY_STRING,
              value: GeneralSubtree.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1g);
    const asn1 = asn1js.compareSchema(schema, schema, _NameConstraints.schema({
      names: {
        permittedSubtrees: PERMITTED_SUBTREES,
        excludedSubtrees: EXCLUDED_SUBTREES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (PERMITTED_SUBTREES in asn1.result)
      this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, (element) => new GeneralSubtree({ schema: element }));
    if (EXCLUDED_SUBTREES in asn1.result)
      this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, (element) => new GeneralSubtree({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    if (this.permittedSubtrees) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: Array.from(this.permittedSubtrees, (o) => o.toSchema())
      }));
    }
    if (this.excludedSubtrees) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: Array.from(this.excludedSubtrees, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const object2 = {};
    if (this.permittedSubtrees) {
      object2.permittedSubtrees = Array.from(this.permittedSubtrees, (o) => o.toJSON());
    }
    if (this.excludedSubtrees) {
      object2.excludedSubtrees = Array.from(this.excludedSubtrees, (o) => o.toJSON());
    }
    return object2;
  }
};
NameConstraints.CLASS_NAME = "NameConstraints";
var REQUIRE_EXPLICIT_POLICY = "requireExplicitPolicy";
var INHIBIT_POLICY_MAPPING = "inhibitPolicyMapping";
var CLEAR_PROPS$1f = [
  REQUIRE_EXPLICIT_POLICY,
  INHIBIT_POLICY_MAPPING
];
var PolicyConstraints = class _PolicyConstraints extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (REQUIRE_EXPLICIT_POLICY in parameters) {
      this.requireExplicitPolicy = getParametersValue(parameters, REQUIRE_EXPLICIT_POLICY, _PolicyConstraints.defaultValues(REQUIRE_EXPLICIT_POLICY));
    }
    if (INHIBIT_POLICY_MAPPING in parameters) {
      this.inhibitPolicyMapping = getParametersValue(parameters, INHIBIT_POLICY_MAPPING, _PolicyConstraints.defaultValues(INHIBIT_POLICY_MAPPING));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case REQUIRE_EXPLICIT_POLICY:
        return 0;
      case INHIBIT_POLICY_MAPPING:
        return 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Primitive({
          name: names.requireExplicitPolicy || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          }
        }),
        new asn1js.Primitive({
          name: names.inhibitPolicyMapping || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1f);
    const asn1 = asn1js.compareSchema(schema, schema, _PolicyConstraints.schema({
      names: {
        requireExplicitPolicy: REQUIRE_EXPLICIT_POLICY,
        inhibitPolicyMapping: INHIBIT_POLICY_MAPPING
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (REQUIRE_EXPLICIT_POLICY in asn1.result) {
      const field1 = asn1.result.requireExplicitPolicy;
      field1.idBlock.tagClass = 1;
      field1.idBlock.tagNumber = 2;
      const ber1 = field1.toBER(false);
      const int1 = asn1js.fromBER(ber1);
      AsnError.assert(int1, "Integer");
      this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
    }
    if (INHIBIT_POLICY_MAPPING in asn1.result) {
      const field2 = asn1.result.inhibitPolicyMapping;
      field2.idBlock.tagClass = 1;
      field2.idBlock.tagNumber = 2;
      const ber2 = field2.toBER(false);
      const int2 = asn1js.fromBER(ber2);
      AsnError.assert(int2, "Integer");
      this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
    }
  }
  toSchema() {
    const outputArray = [];
    if (REQUIRE_EXPLICIT_POLICY in this) {
      const int1 = new asn1js.Integer({ value: this.requireExplicitPolicy });
      int1.idBlock.tagClass = 3;
      int1.idBlock.tagNumber = 0;
      outputArray.push(int1);
    }
    if (INHIBIT_POLICY_MAPPING in this) {
      const int2 = new asn1js.Integer({ value: this.inhibitPolicyMapping });
      int2.idBlock.tagClass = 3;
      int2.idBlock.tagNumber = 1;
      outputArray.push(int2);
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {};
    if (REQUIRE_EXPLICIT_POLICY in this) {
      res.requireExplicitPolicy = this.requireExplicitPolicy;
    }
    if (INHIBIT_POLICY_MAPPING in this) {
      res.inhibitPolicyMapping = this.inhibitPolicyMapping;
    }
    return res;
  }
};
PolicyConstraints.CLASS_NAME = "PolicyConstraints";
var ISSUER_DOMAIN_POLICY = "issuerDomainPolicy";
var SUBJECT_DOMAIN_POLICY = "subjectDomainPolicy";
var CLEAR_PROPS$1e = [
  ISSUER_DOMAIN_POLICY,
  SUBJECT_DOMAIN_POLICY
];
var PolicyMapping = class _PolicyMapping extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.issuerDomainPolicy = getParametersValue(parameters, ISSUER_DOMAIN_POLICY, _PolicyMapping.defaultValues(ISSUER_DOMAIN_POLICY));
    this.subjectDomainPolicy = getParametersValue(parameters, SUBJECT_DOMAIN_POLICY, _PolicyMapping.defaultValues(SUBJECT_DOMAIN_POLICY));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ISSUER_DOMAIN_POLICY:
        return EMPTY_STRING;
      case SUBJECT_DOMAIN_POLICY:
        return EMPTY_STRING;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.issuerDomainPolicy || EMPTY_STRING }),
        new asn1js.ObjectIdentifier({ name: names.subjectDomainPolicy || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1e);
    const asn1 = asn1js.compareSchema(schema, schema, _PolicyMapping.schema({
      names: {
        issuerDomainPolicy: ISSUER_DOMAIN_POLICY,
        subjectDomainPolicy: SUBJECT_DOMAIN_POLICY
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
    this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.issuerDomainPolicy }),
        new asn1js.ObjectIdentifier({ value: this.subjectDomainPolicy })
      ]
    });
  }
  toJSON() {
    return {
      issuerDomainPolicy: this.issuerDomainPolicy,
      subjectDomainPolicy: this.subjectDomainPolicy
    };
  }
};
PolicyMapping.CLASS_NAME = "PolicyMapping";
var MAPPINGS = "mappings";
var CLEAR_PROPS$1d = [
  MAPPINGS
];
var PolicyMappings = class _PolicyMappings extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.mappings = getParametersValue(parameters, MAPPINGS, _PolicyMappings.defaultValues(MAPPINGS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case MAPPINGS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.mappings || EMPTY_STRING,
          value: PolicyMapping.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1d);
    const asn1 = asn1js.compareSchema(schema, schema, _PolicyMappings.schema({
      names: {
        mappings: MAPPINGS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.mappings = Array.from(asn1.result.mappings, (element) => new PolicyMapping({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.mappings, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      mappings: Array.from(this.mappings, (o) => o.toJSON())
    };
  }
};
PolicyMappings.CLASS_NAME = "PolicyMappings";
var NOT_BEFORE$1 = "notBefore";
var NOT_AFTER$1 = "notAfter";
var CLEAR_PROPS$1c = [
  NOT_BEFORE$1,
  NOT_AFTER$1
];
var PrivateKeyUsagePeriod = class _PrivateKeyUsagePeriod extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (NOT_BEFORE$1 in parameters) {
      this.notBefore = getParametersValue(parameters, NOT_BEFORE$1, _PrivateKeyUsagePeriod.defaultValues(NOT_BEFORE$1));
    }
    if (NOT_AFTER$1 in parameters) {
      this.notAfter = getParametersValue(parameters, NOT_AFTER$1, _PrivateKeyUsagePeriod.defaultValues(NOT_AFTER$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case NOT_BEFORE$1:
        return /* @__PURE__ */ new Date();
      case NOT_AFTER$1:
        return /* @__PURE__ */ new Date();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Primitive({
          name: names.notBefore || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          }
        }),
        new asn1js.Primitive({
          name: names.notAfter || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1c);
    const asn1 = asn1js.compareSchema(schema, schema, _PrivateKeyUsagePeriod.schema({
      names: {
        notBefore: NOT_BEFORE$1,
        notAfter: NOT_AFTER$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (NOT_BEFORE$1 in asn1.result) {
      const localNotBefore = new asn1js.GeneralizedTime();
      localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
      this.notBefore = localNotBefore.toDate();
    }
    if (NOT_AFTER$1 in asn1.result) {
      const localNotAfter = new asn1js.GeneralizedTime({ valueHex: asn1.result.notAfter.valueBlock.valueHex });
      localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
      this.notAfter = localNotAfter.toDate();
    }
  }
  toSchema() {
    const outputArray = [];
    if (NOT_BEFORE$1 in this) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        valueHex: new asn1js.GeneralizedTime({ valueDate: this.notBefore }).valueBlock.valueHexView
      }));
    }
    if (NOT_AFTER$1 in this) {
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        valueHex: new asn1js.GeneralizedTime({ valueDate: this.notAfter }).valueBlock.valueHexView
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {};
    if (this.notBefore) {
      res.notBefore = this.notBefore;
    }
    if (this.notAfter) {
      res.notAfter = this.notAfter;
    }
    return res;
  }
};
PrivateKeyUsagePeriod.CLASS_NAME = "PrivateKeyUsagePeriod";
var ID = "id";
var TYPE$2 = "type";
var VALUES = "values";
var QC_STATEMENT_CLEAR_PROPS = [
  ID,
  TYPE$2
];
var QC_STATEMENTS_CLEAR_PROPS = [
  VALUES
];
var QCStatement = class _QCStatement extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.id = getParametersValue(parameters, ID, _QCStatement.defaultValues(ID));
    if (TYPE$2 in parameters) {
      this.type = getParametersValue(parameters, TYPE$2, _QCStatement.defaultValues(TYPE$2));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ID:
        return EMPTY_STRING;
      case TYPE$2:
        return new asn1js.Null();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case ID:
        return memberValue === EMPTY_STRING;
      case TYPE$2:
        return memberValue instanceof asn1js.Null;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.id || EMPTY_STRING }),
        new asn1js.Any({
          name: names.type || EMPTY_STRING,
          optional: true
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, QC_STATEMENT_CLEAR_PROPS);
    const asn1 = asn1js.compareSchema(schema, schema, _QCStatement.schema({
      names: {
        id: ID,
        type: TYPE$2
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.id = asn1.result.id.valueBlock.toString();
    if (TYPE$2 in asn1.result)
      this.type = asn1.result.type;
  }
  toSchema() {
    const value = [
      new asn1js.ObjectIdentifier({ value: this.id })
    ];
    if (TYPE$2 in this)
      value.push(this.type);
    return new asn1js.Sequence({
      value
    });
  }
  toJSON() {
    const object2 = {
      id: this.id
    };
    if (this.type) {
      object2.type = this.type.toJSON();
    }
    return object2;
  }
};
QCStatement.CLASS_NAME = "QCStatement";
var QCStatements = class _QCStatements extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.values = getParametersValue(parameters, VALUES, _QCStatements.defaultValues(VALUES));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VALUES:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VALUES:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.values || EMPTY_STRING,
          value: QCStatement.schema(names.value || {})
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, QC_STATEMENTS_CLEAR_PROPS);
    const asn1 = asn1js.compareSchema(schema, schema, _QCStatements.schema({
      names: {
        values: VALUES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.values = Array.from(asn1.result.values, (element) => new QCStatement({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.values, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      values: Array.from(this.values, (o) => o.toJSON())
    };
  }
};
QCStatements.CLASS_NAME = "QCStatements";
var _a2;
var ECNamedCurves = class {
  static register(name4, id, size2) {
    this.namedCurves[name4.toLowerCase()] = this.namedCurves[id] = { name: name4, id, size: size2 };
  }
  static find(nameOrId) {
    return this.namedCurves[nameOrId.toLowerCase()] || null;
  }
};
_a2 = ECNamedCurves;
ECNamedCurves.namedCurves = {};
(() => {
  _a2.register("P-256", "1.2.840.10045.3.1.7", 32);
  _a2.register("P-384", "1.3.132.0.34", 48);
  _a2.register("P-521", "1.3.132.0.35", 66);
  _a2.register("brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7", 32);
  _a2.register("brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11", 48);
  _a2.register("brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13", 64);
})();
var X = "x";
var Y = "y";
var NAMED_CURVE$1 = "namedCurve";
var ECPublicKey = class _ECPublicKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.x = getParametersValue(parameters, X, _ECPublicKey.defaultValues(X));
    this.y = getParametersValue(parameters, Y, _ECPublicKey.defaultValues(Y));
    this.namedCurve = getParametersValue(parameters, NAMED_CURVE$1, _ECPublicKey.defaultValues(NAMED_CURVE$1));
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case X:
      case Y:
        return EMPTY_BUFFER;
      case NAMED_CURVE$1:
        return EMPTY_STRING;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case X:
      case Y:
        return memberValue instanceof ArrayBuffer && isEqualBuffer(memberValue, _ECPublicKey.defaultValues(memberName));
      case NAMED_CURVE$1:
        return typeof memberValue === "string" && memberValue === _ECPublicKey.defaultValues(memberName);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema() {
    return new asn1js.RawData();
  }
  fromSchema(schema1) {
    const view = BufferSourceConverter.toUint8Array(schema1);
    if (view[0] !== 4) {
      throw new Error("Object's schema was not verified against input data for ECPublicKey");
    }
    const namedCurve = ECNamedCurves.find(this.namedCurve);
    if (!namedCurve) {
      throw new Error(`Incorrect curve OID: ${this.namedCurve}`);
    }
    const coordinateLength = namedCurve.size;
    if (view.byteLength !== coordinateLength * 2 + 1) {
      throw new Error("Object's schema was not verified against input data for ECPublicKey");
    }
    this.namedCurve = namedCurve.name;
    this.x = view.slice(1, coordinateLength + 1).buffer;
    this.y = view.slice(1 + coordinateLength, coordinateLength * 2 + 1).buffer;
  }
  toSchema() {
    return new asn1js.RawData({
      data: utilConcatBuf(new Uint8Array([4]).buffer, this.x, this.y)
    });
  }
  toJSON() {
    const namedCurve = ECNamedCurves.find(this.namedCurve);
    return {
      crv: namedCurve ? namedCurve.name : this.namedCurve,
      x: toBase64(arrayBufferToString(this.x), true, true, false),
      y: toBase64(arrayBufferToString(this.y), true, true, false)
    };
  }
  fromJSON(json) {
    ParameterError.assert("json", json, "crv", "x", "y");
    let coordinateLength = 0;
    const namedCurve = ECNamedCurves.find(json.crv);
    if (namedCurve) {
      this.namedCurve = namedCurve.id;
      coordinateLength = namedCurve.size;
    }
    const xConvertBuffer = stringToArrayBuffer(fromBase64(json.x, true));
    if (xConvertBuffer.byteLength < coordinateLength) {
      this.x = new ArrayBuffer(coordinateLength);
      const view = new Uint8Array(this.x);
      const convertBufferView = new Uint8Array(xConvertBuffer);
      view.set(convertBufferView, 1);
    } else {
      this.x = xConvertBuffer.slice(0, coordinateLength);
    }
    const yConvertBuffer = stringToArrayBuffer(fromBase64(json.y, true));
    if (yConvertBuffer.byteLength < coordinateLength) {
      this.y = new ArrayBuffer(coordinateLength);
      const view = new Uint8Array(this.y);
      const convertBufferView = new Uint8Array(yConvertBuffer);
      view.set(convertBufferView, 1);
    } else {
      this.y = yConvertBuffer.slice(0, coordinateLength);
    }
  }
};
ECPublicKey.CLASS_NAME = "ECPublicKey";
var MODULUS$1 = "modulus";
var PUBLIC_EXPONENT$1 = "publicExponent";
var CLEAR_PROPS$1b = [MODULUS$1, PUBLIC_EXPONENT$1];
var RSAPublicKey = class _RSAPublicKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.modulus = getParametersValue(parameters, MODULUS$1, _RSAPublicKey.defaultValues(MODULUS$1));
    this.publicExponent = getParametersValue(parameters, PUBLIC_EXPONENT$1, _RSAPublicKey.defaultValues(PUBLIC_EXPONENT$1));
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case MODULUS$1:
        return new asn1js.Integer();
      case PUBLIC_EXPONENT$1:
        return new asn1js.Integer();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.modulus || EMPTY_STRING }),
        new asn1js.Integer({ name: names.publicExponent || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1b);
    const asn1 = asn1js.compareSchema(schema, schema, _RSAPublicKey.schema({
      names: {
        modulus: MODULUS$1,
        publicExponent: PUBLIC_EXPONENT$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.modulus = asn1.result.modulus.convertFromDER(256);
    this.publicExponent = asn1.result.publicExponent;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.modulus.convertToDER(),
        this.publicExponent
      ]
    });
  }
  toJSON() {
    return {
      n: Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),
      e: Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView)
    };
  }
  fromJSON(json) {
    ParameterError.assert("json", json, "n", "e");
    const array = stringToArrayBuffer(fromBase64(json.n, true));
    this.modulus = new asn1js.Integer({ valueHex: array.slice(0, Math.pow(2, nearestPowerOf2(array.byteLength))) });
    this.publicExponent = new asn1js.Integer({ valueHex: stringToArrayBuffer(fromBase64(json.e, true)).slice(0, 3) });
  }
};
RSAPublicKey.CLASS_NAME = "RSAPublicKey";
var ALGORITHM$1 = "algorithm";
var SUBJECT_PUBLIC_KEY = "subjectPublicKey";
var CLEAR_PROPS$1a = [ALGORITHM$1, SUBJECT_PUBLIC_KEY];
var PublicKeyInfo = class _PublicKeyInfo extends PkiObject {
  get parsedKey() {
    if (this._parsedKey === void 0) {
      switch (this.algorithm.algorithmId) {
        case "1.2.840.10045.2.1":
          if ("algorithmParams" in this.algorithm) {
            if (this.algorithm.algorithmParams.constructor.blockName() === asn1js.ObjectIdentifier.blockName()) {
              try {
                this._parsedKey = new ECPublicKey({
                  namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
                  schema: this.subjectPublicKey.valueBlock.valueHexView
                });
              } catch (ex) {
              }
            }
          }
          break;
        case "1.2.840.113549.1.1.1":
          {
            const publicKeyASN1 = asn1js.fromBER(this.subjectPublicKey.valueBlock.valueHexView);
            if (publicKeyASN1.offset !== -1) {
              try {
                this._parsedKey = new RSAPublicKey({ schema: publicKeyASN1.result });
              } catch (ex) {
              }
            }
          }
          break;
      }
      this._parsedKey || (this._parsedKey = null);
    }
    return this._parsedKey || void 0;
  }
  set parsedKey(value) {
    this._parsedKey = value;
  }
  constructor(parameters = {}) {
    super();
    this.algorithm = getParametersValue(parameters, ALGORITHM$1, _PublicKeyInfo.defaultValues(ALGORITHM$1));
    this.subjectPublicKey = getParametersValue(parameters, SUBJECT_PUBLIC_KEY, _PublicKeyInfo.defaultValues(SUBJECT_PUBLIC_KEY));
    const parsedKey = getParametersValue(parameters, "parsedKey", null);
    if (parsedKey) {
      this.parsedKey = parsedKey;
    }
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ALGORITHM$1:
        return new AlgorithmIdentifier();
      case SUBJECT_PUBLIC_KEY:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.algorithm || {}),
        new asn1js.BitString({ name: names.subjectPublicKey || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1a);
    const asn1 = asn1js.compareSchema(schema, schema, _PublicKeyInfo.schema({
      names: {
        algorithm: {
          names: {
            blockName: ALGORITHM$1
          }
        },
        subjectPublicKey: SUBJECT_PUBLIC_KEY
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });
    this.subjectPublicKey = asn1.result.subjectPublicKey;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.algorithm.toSchema(),
        this.subjectPublicKey
      ]
    });
  }
  toJSON() {
    if (!this.parsedKey) {
      return {
        algorithm: this.algorithm.toJSON(),
        subjectPublicKey: this.subjectPublicKey.toJSON()
      };
    }
    const jwk = {};
    switch (this.algorithm.algorithmId) {
      case "1.2.840.10045.2.1":
        jwk.kty = "EC";
        break;
      case "1.2.840.113549.1.1.1":
        jwk.kty = "RSA";
        break;
    }
    const publicKeyJWK = this.parsedKey.toJSON();
    Object.assign(jwk, publicKeyJWK);
    return jwk;
  }
  fromJSON(json) {
    if ("kty" in json) {
      switch (json.kty.toUpperCase()) {
        case "EC":
          this.parsedKey = new ECPublicKey({ json });
          this.algorithm = new AlgorithmIdentifier({
            algorithmId: "1.2.840.10045.2.1",
            algorithmParams: new asn1js.ObjectIdentifier({ value: this.parsedKey.namedCurve })
          });
          break;
        case "RSA":
          this.parsedKey = new RSAPublicKey({ json });
          this.algorithm = new AlgorithmIdentifier({
            algorithmId: "1.2.840.113549.1.1.1",
            algorithmParams: new asn1js.Null()
          });
          break;
        default:
          throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
      }
      this.subjectPublicKey = new asn1js.BitString({ valueHex: this.parsedKey.toSchema().toBER(false) });
    }
  }
  async importKey(publicKey, crypto9 = getCrypto2(true)) {
    try {
      if (!publicKey) {
        throw new Error("Need to provide publicKey input parameter");
      }
      const exportedKey = await crypto9.exportKey("spki", publicKey);
      const asn1 = asn1js.fromBER(exportedKey);
      try {
        this.fromSchema(asn1.result);
      } catch (exception) {
        throw new Error("Error during initializing object from schema");
      }
    } catch (e) {
      const message = e instanceof Error ? e.message : `${e}`;
      throw new Error(`Error during exporting public key: ${message}`);
    }
  }
};
PublicKeyInfo.CLASS_NAME = "PublicKeyInfo";
var VERSION$l = "version";
var PRIVATE_KEY$1 = "privateKey";
var NAMED_CURVE = "namedCurve";
var PUBLIC_KEY$1 = "publicKey";
var CLEAR_PROPS$19 = [
  VERSION$l,
  PRIVATE_KEY$1,
  NAMED_CURVE,
  PUBLIC_KEY$1
];
var ECPrivateKey = class _ECPrivateKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$l, _ECPrivateKey.defaultValues(VERSION$l));
    this.privateKey = getParametersValue(parameters, PRIVATE_KEY$1, _ECPrivateKey.defaultValues(PRIVATE_KEY$1));
    if (NAMED_CURVE in parameters) {
      this.namedCurve = getParametersValue(parameters, NAMED_CURVE, _ECPrivateKey.defaultValues(NAMED_CURVE));
    }
    if (PUBLIC_KEY$1 in parameters) {
      this.publicKey = getParametersValue(parameters, PUBLIC_KEY$1, _ECPrivateKey.defaultValues(PUBLIC_KEY$1));
    }
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$l:
        return 1;
      case PRIVATE_KEY$1:
        return new asn1js.OctetString();
      case NAMED_CURVE:
        return EMPTY_STRING;
      case PUBLIC_KEY$1:
        return new ECPublicKey();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$l:
        return memberValue === _ECPrivateKey.defaultValues(memberName);
      case PRIVATE_KEY$1:
        return memberValue.isEqual(_ECPrivateKey.defaultValues(memberName));
      case NAMED_CURVE:
        return memberValue === EMPTY_STRING;
      case PUBLIC_KEY$1:
        return ECPublicKey.compareWithDefault(NAMED_CURVE, memberValue.namedCurve) && ECPublicKey.compareWithDefault("x", memberValue.x) && ECPublicKey.compareWithDefault("y", memberValue.y);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        new asn1js.OctetString({ name: names.privateKey || EMPTY_STRING }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.ObjectIdentifier({ name: names.namedCurve || EMPTY_STRING })
          ]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [
            new asn1js.BitString({ name: names.publicKey || EMPTY_STRING })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$19);
    const asn1 = asn1js.compareSchema(schema, schema, _ECPrivateKey.schema({
      names: {
        version: VERSION$l,
        privateKey: PRIVATE_KEY$1,
        namedCurve: NAMED_CURVE,
        publicKey: PUBLIC_KEY$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.privateKey = asn1.result.privateKey;
    if (NAMED_CURVE in asn1.result) {
      this.namedCurve = asn1.result.namedCurve.valueBlock.toString();
    }
    if (PUBLIC_KEY$1 in asn1.result) {
      const publicKeyData = { schema: asn1.result.publicKey.valueBlock.valueHex };
      if (NAMED_CURVE in this) {
        publicKeyData.namedCurve = this.namedCurve;
      }
      this.publicKey = new ECPublicKey(publicKeyData);
    }
  }
  toSchema() {
    const outputArray = [
      new asn1js.Integer({ value: this.version }),
      this.privateKey
    ];
    if (this.namedCurve) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.ObjectIdentifier({ value: this.namedCurve })
        ]
      }));
    }
    if (this.publicKey) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [
          new asn1js.BitString({ valueHex: this.publicKey.toSchema().toBER(false) })
        ]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    if (!this.namedCurve || _ECPrivateKey.compareWithDefault(NAMED_CURVE, this.namedCurve)) {
      throw new Error('Not enough information for making JSON: absent "namedCurve" value');
    }
    const curve = ECNamedCurves.find(this.namedCurve);
    const privateKeyJSON = {
      crv: curve ? curve.name : this.namedCurve,
      d: Convert.ToBase64Url(this.privateKey.valueBlock.valueHexView)
    };
    if (this.publicKey) {
      const publicKeyJSON = this.publicKey.toJSON();
      privateKeyJSON.x = publicKeyJSON.x;
      privateKeyJSON.y = publicKeyJSON.y;
    }
    return privateKeyJSON;
  }
  fromJSON(json) {
    ParameterError.assert("json", json, "crv", "d");
    let coordinateLength = 0;
    const curve = ECNamedCurves.find(json.crv);
    if (curve) {
      this.namedCurve = curve.id;
      coordinateLength = curve.size;
    }
    const convertBuffer = Convert.FromBase64Url(json.d);
    if (convertBuffer.byteLength < coordinateLength) {
      const buffer2 = new ArrayBuffer(coordinateLength);
      const view = new Uint8Array(buffer2);
      const convertBufferView = new Uint8Array(convertBuffer);
      view.set(convertBufferView, 1);
      this.privateKey = new asn1js.OctetString({ valueHex: buffer2 });
    } else {
      this.privateKey = new asn1js.OctetString({ valueHex: convertBuffer.slice(0, coordinateLength) });
    }
    if (json.x && json.y) {
      this.publicKey = new ECPublicKey({ json });
    }
  }
};
ECPrivateKey.CLASS_NAME = "ECPrivateKey";
var PRIME = "prime";
var EXPONENT = "exponent";
var COEFFICIENT$1 = "coefficient";
var CLEAR_PROPS$18 = [
  PRIME,
  EXPONENT,
  COEFFICIENT$1
];
var OtherPrimeInfo = class _OtherPrimeInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.prime = getParametersValue(parameters, PRIME, _OtherPrimeInfo.defaultValues(PRIME));
    this.exponent = getParametersValue(parameters, EXPONENT, _OtherPrimeInfo.defaultValues(EXPONENT));
    this.coefficient = getParametersValue(parameters, COEFFICIENT$1, _OtherPrimeInfo.defaultValues(COEFFICIENT$1));
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case PRIME:
        return new asn1js.Integer();
      case EXPONENT:
        return new asn1js.Integer();
      case COEFFICIENT$1:
        return new asn1js.Integer();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.prime || EMPTY_STRING }),
        new asn1js.Integer({ name: names.exponent || EMPTY_STRING }),
        new asn1js.Integer({ name: names.coefficient || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$18);
    const asn1 = asn1js.compareSchema(schema, schema, _OtherPrimeInfo.schema({
      names: {
        prime: PRIME,
        exponent: EXPONENT,
        coefficient: COEFFICIENT$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.prime = asn1.result.prime.convertFromDER();
    this.exponent = asn1.result.exponent.convertFromDER();
    this.coefficient = asn1.result.coefficient.convertFromDER();
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.prime.convertToDER(),
        this.exponent.convertToDER(),
        this.coefficient.convertToDER()
      ]
    });
  }
  toJSON() {
    return {
      r: Convert.ToBase64Url(this.prime.valueBlock.valueHexView),
      d: Convert.ToBase64Url(this.exponent.valueBlock.valueHexView),
      t: Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)
    };
  }
  fromJSON(json) {
    ParameterError.assert("json", json, "r", "d", "r");
    this.prime = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.r) });
    this.exponent = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.d) });
    this.coefficient = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.t) });
  }
};
OtherPrimeInfo.CLASS_NAME = "OtherPrimeInfo";
var VERSION$k = "version";
var MODULUS = "modulus";
var PUBLIC_EXPONENT = "publicExponent";
var PRIVATE_EXPONENT = "privateExponent";
var PRIME1 = "prime1";
var PRIME2 = "prime2";
var EXPONENT1 = "exponent1";
var EXPONENT2 = "exponent2";
var COEFFICIENT = "coefficient";
var OTHER_PRIME_INFOS = "otherPrimeInfos";
var CLEAR_PROPS$17 = [
  VERSION$k,
  MODULUS,
  PUBLIC_EXPONENT,
  PRIVATE_EXPONENT,
  PRIME1,
  PRIME2,
  EXPONENT1,
  EXPONENT2,
  COEFFICIENT,
  OTHER_PRIME_INFOS
];
var RSAPrivateKey = class _RSAPrivateKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$k, _RSAPrivateKey.defaultValues(VERSION$k));
    this.modulus = getParametersValue(parameters, MODULUS, _RSAPrivateKey.defaultValues(MODULUS));
    this.publicExponent = getParametersValue(parameters, PUBLIC_EXPONENT, _RSAPrivateKey.defaultValues(PUBLIC_EXPONENT));
    this.privateExponent = getParametersValue(parameters, PRIVATE_EXPONENT, _RSAPrivateKey.defaultValues(PRIVATE_EXPONENT));
    this.prime1 = getParametersValue(parameters, PRIME1, _RSAPrivateKey.defaultValues(PRIME1));
    this.prime2 = getParametersValue(parameters, PRIME2, _RSAPrivateKey.defaultValues(PRIME2));
    this.exponent1 = getParametersValue(parameters, EXPONENT1, _RSAPrivateKey.defaultValues(EXPONENT1));
    this.exponent2 = getParametersValue(parameters, EXPONENT2, _RSAPrivateKey.defaultValues(EXPONENT2));
    this.coefficient = getParametersValue(parameters, COEFFICIENT, _RSAPrivateKey.defaultValues(COEFFICIENT));
    if (OTHER_PRIME_INFOS in parameters) {
      this.otherPrimeInfos = getParametersValue(parameters, OTHER_PRIME_INFOS, _RSAPrivateKey.defaultValues(OTHER_PRIME_INFOS));
    }
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$k:
        return 0;
      case MODULUS:
        return new asn1js.Integer();
      case PUBLIC_EXPONENT:
        return new asn1js.Integer();
      case PRIVATE_EXPONENT:
        return new asn1js.Integer();
      case PRIME1:
        return new asn1js.Integer();
      case PRIME2:
        return new asn1js.Integer();
      case EXPONENT1:
        return new asn1js.Integer();
      case EXPONENT2:
        return new asn1js.Integer();
      case COEFFICIENT:
        return new asn1js.Integer();
      case OTHER_PRIME_INFOS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        new asn1js.Integer({ name: names.modulus || EMPTY_STRING }),
        new asn1js.Integer({ name: names.publicExponent || EMPTY_STRING }),
        new asn1js.Integer({ name: names.privateExponent || EMPTY_STRING }),
        new asn1js.Integer({ name: names.prime1 || EMPTY_STRING }),
        new asn1js.Integer({ name: names.prime2 || EMPTY_STRING }),
        new asn1js.Integer({ name: names.exponent1 || EMPTY_STRING }),
        new asn1js.Integer({ name: names.exponent2 || EMPTY_STRING }),
        new asn1js.Integer({ name: names.coefficient || EMPTY_STRING }),
        new asn1js.Sequence({
          optional: true,
          value: [
            new asn1js.Repeated({
              name: names.otherPrimeInfosName || EMPTY_STRING,
              value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$17);
    const asn1 = asn1js.compareSchema(schema, schema, _RSAPrivateKey.schema({
      names: {
        version: VERSION$k,
        modulus: MODULUS,
        publicExponent: PUBLIC_EXPONENT,
        privateExponent: PRIVATE_EXPONENT,
        prime1: PRIME1,
        prime2: PRIME2,
        exponent1: EXPONENT1,
        exponent2: EXPONENT2,
        coefficient: COEFFICIENT,
        otherPrimeInfo: {
          names: {
            blockName: OTHER_PRIME_INFOS
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.modulus = asn1.result.modulus.convertFromDER(256);
    this.publicExponent = asn1.result.publicExponent;
    this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
    this.prime1 = asn1.result.prime1.convertFromDER(128);
    this.prime2 = asn1.result.prime2.convertFromDER(128);
    this.exponent1 = asn1.result.exponent1.convertFromDER(128);
    this.exponent2 = asn1.result.exponent2.convertFromDER(128);
    this.coefficient = asn1.result.coefficient.convertFromDER(128);
    if (OTHER_PRIME_INFOS in asn1.result)
      this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, (element) => new OtherPrimeInfo({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    outputArray.push(this.modulus.convertToDER());
    outputArray.push(this.publicExponent);
    outputArray.push(this.privateExponent.convertToDER());
    outputArray.push(this.prime1.convertToDER());
    outputArray.push(this.prime2.convertToDER());
    outputArray.push(this.exponent1.convertToDER());
    outputArray.push(this.exponent2.convertToDER());
    outputArray.push(this.coefficient.convertToDER());
    if (this.otherPrimeInfos) {
      outputArray.push(new asn1js.Sequence({
        value: Array.from(this.otherPrimeInfos, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const jwk = {
      n: Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),
      e: Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView),
      d: Convert.ToBase64Url(this.privateExponent.valueBlock.valueHexView),
      p: Convert.ToBase64Url(this.prime1.valueBlock.valueHexView),
      q: Convert.ToBase64Url(this.prime2.valueBlock.valueHexView),
      dp: Convert.ToBase64Url(this.exponent1.valueBlock.valueHexView),
      dq: Convert.ToBase64Url(this.exponent2.valueBlock.valueHexView),
      qi: Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)
    };
    if (this.otherPrimeInfos) {
      jwk.oth = Array.from(this.otherPrimeInfos, (o) => o.toJSON());
    }
    return jwk;
  }
  fromJSON(json) {
    ParameterError.assert("json", json, "n", "e", "d", "p", "q", "dp", "dq", "qi");
    this.modulus = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.n) });
    this.publicExponent = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.e) });
    this.privateExponent = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.d) });
    this.prime1 = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.p) });
    this.prime2 = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.q) });
    this.exponent1 = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.dp) });
    this.exponent2 = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.dq) });
    this.coefficient = new asn1js.Integer({ valueHex: Convert.FromBase64Url(json.qi) });
    if (json.oth) {
      this.otherPrimeInfos = Array.from(json.oth, (element) => new OtherPrimeInfo({ json: element }));
    }
  }
};
RSAPrivateKey.CLASS_NAME = "RSAPrivateKey";
var VERSION$j = "version";
var PRIVATE_KEY_ALGORITHM = "privateKeyAlgorithm";
var PRIVATE_KEY = "privateKey";
var ATTRIBUTES$5 = "attributes";
var PARSED_KEY = "parsedKey";
var CLEAR_PROPS$16 = [
  VERSION$j,
  PRIVATE_KEY_ALGORITHM,
  PRIVATE_KEY,
  ATTRIBUTES$5
];
var PrivateKeyInfo = class _PrivateKeyInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$j, _PrivateKeyInfo.defaultValues(VERSION$j));
    this.privateKeyAlgorithm = getParametersValue(parameters, PRIVATE_KEY_ALGORITHM, _PrivateKeyInfo.defaultValues(PRIVATE_KEY_ALGORITHM));
    this.privateKey = getParametersValue(parameters, PRIVATE_KEY, _PrivateKeyInfo.defaultValues(PRIVATE_KEY));
    if (ATTRIBUTES$5 in parameters) {
      this.attributes = getParametersValue(parameters, ATTRIBUTES$5, _PrivateKeyInfo.defaultValues(ATTRIBUTES$5));
    }
    if (PARSED_KEY in parameters) {
      this.parsedKey = getParametersValue(parameters, PARSED_KEY, _PrivateKeyInfo.defaultValues(PARSED_KEY));
    }
    if (parameters.json) {
      this.fromJSON(parameters.json);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$j:
        return 0;
      case PRIVATE_KEY_ALGORITHM:
        return new AlgorithmIdentifier();
      case PRIVATE_KEY:
        return new asn1js.OctetString();
      case ATTRIBUTES$5:
        return [];
      case PARSED_KEY:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}),
        new asn1js.OctetString({ name: names.privateKey || EMPTY_STRING }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Repeated({
              name: names.attributes || EMPTY_STRING,
              value: Attribute.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$16);
    const asn1 = asn1js.compareSchema(schema, schema, _PrivateKeyInfo.schema({
      names: {
        version: VERSION$j,
        privateKeyAlgorithm: {
          names: {
            blockName: PRIVATE_KEY_ALGORITHM
          }
        },
        privateKey: PRIVATE_KEY,
        attributes: ATTRIBUTES$5
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.privateKeyAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.privateKeyAlgorithm });
    this.privateKey = asn1.result.privateKey;
    if (ATTRIBUTES$5 in asn1.result)
      this.attributes = Array.from(asn1.result.attributes, (element) => new Attribute({ schema: element }));
    switch (this.privateKeyAlgorithm.algorithmId) {
      case "1.2.840.113549.1.1.1":
        {
          const privateKeyASN1 = asn1js.fromBER(this.privateKey.valueBlock.valueHexView);
          if (privateKeyASN1.offset !== -1)
            this.parsedKey = new RSAPrivateKey({ schema: privateKeyASN1.result });
        }
        break;
      case "1.2.840.10045.2.1":
        if ("algorithmParams" in this.privateKeyAlgorithm) {
          if (this.privateKeyAlgorithm.algorithmParams instanceof asn1js.ObjectIdentifier) {
            const privateKeyASN1 = asn1js.fromBER(this.privateKey.valueBlock.valueHexView);
            if (privateKeyASN1.offset !== -1) {
              this.parsedKey = new ECPrivateKey({
                namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
                schema: privateKeyASN1.result
              });
            }
          }
        }
        break;
    }
  }
  toSchema() {
    const outputArray = [
      new asn1js.Integer({ value: this.version }),
      this.privateKeyAlgorithm.toSchema(),
      this.privateKey
    ];
    if (this.attributes) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: Array.from(this.attributes, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    if (!this.parsedKey) {
      const object2 = {
        version: this.version,
        privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
        privateKey: this.privateKey.toJSON()
      };
      if (this.attributes) {
        object2.attributes = Array.from(this.attributes, (o) => o.toJSON());
      }
      return object2;
    }
    const jwk = {};
    switch (this.privateKeyAlgorithm.algorithmId) {
      case "1.2.840.10045.2.1":
        jwk.kty = "EC";
        break;
      case "1.2.840.113549.1.1.1":
        jwk.kty = "RSA";
        break;
    }
    const publicKeyJWK = this.parsedKey.toJSON();
    Object.assign(jwk, publicKeyJWK);
    return jwk;
  }
  fromJSON(json) {
    if ("kty" in json) {
      switch (json.kty.toUpperCase()) {
        case "EC":
          this.parsedKey = new ECPrivateKey({ json });
          this.privateKeyAlgorithm = new AlgorithmIdentifier({
            algorithmId: "1.2.840.10045.2.1",
            algorithmParams: new asn1js.ObjectIdentifier({ value: this.parsedKey.namedCurve })
          });
          break;
        case "RSA":
          this.parsedKey = new RSAPrivateKey({ json });
          this.privateKeyAlgorithm = new AlgorithmIdentifier({
            algorithmId: "1.2.840.113549.1.1.1",
            algorithmParams: new asn1js.Null()
          });
          break;
        default:
          throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
      }
      this.privateKey = new asn1js.OctetString({ valueHex: this.parsedKey.toSchema().toBER(false) });
    }
  }
};
PrivateKeyInfo.CLASS_NAME = "PrivateKeyInfo";
var CONTENT_TYPE$1 = "contentType";
var CONTENT_ENCRYPTION_ALGORITHM = "contentEncryptionAlgorithm";
var ENCRYPTED_CONTENT = "encryptedContent";
var CLEAR_PROPS$15 = [
  CONTENT_TYPE$1,
  CONTENT_ENCRYPTION_ALGORITHM,
  ENCRYPTED_CONTENT
];
var PIECE_SIZE = 1024;
var EncryptedContentInfo = class _EncryptedContentInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.contentType = getParametersValue(parameters, CONTENT_TYPE$1, _EncryptedContentInfo.defaultValues(CONTENT_TYPE$1));
    this.contentEncryptionAlgorithm = getParametersValue(parameters, CONTENT_ENCRYPTION_ALGORITHM, _EncryptedContentInfo.defaultValues(CONTENT_ENCRYPTION_ALGORITHM));
    if (ENCRYPTED_CONTENT in parameters && parameters.encryptedContent) {
      this.encryptedContent = parameters.encryptedContent;
      if (this.encryptedContent.idBlock.tagClass === 1 && this.encryptedContent.idBlock.tagNumber === 4) {
        if (this.encryptedContent.idBlock.isConstructed === false && !parameters.disableSplit) {
          const constrString = new asn1js.OctetString({
            idBlock: { isConstructed: true },
            isConstructed: true
          });
          let offset = 0;
          const valueHex = this.encryptedContent.valueBlock.valueHexView.slice().buffer;
          let length3 = valueHex.byteLength;
          while (length3 > 0) {
            const pieceView = new Uint8Array(valueHex, offset, offset + PIECE_SIZE > valueHex.byteLength ? valueHex.byteLength - offset : PIECE_SIZE);
            const _array = new ArrayBuffer(pieceView.length);
            const _view = new Uint8Array(_array);
            for (let i2 = 0; i2 < _view.length; i2++)
              _view[i2] = pieceView[i2];
            constrString.valueBlock.value.push(new asn1js.OctetString({ valueHex: _array }));
            length3 -= pieceView.length;
            offset += pieceView.length;
          }
          this.encryptedContent = constrString;
        }
      }
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CONTENT_TYPE$1:
        return EMPTY_STRING;
      case CONTENT_ENCRYPTION_ALGORITHM:
        return new AlgorithmIdentifier();
      case ENCRYPTED_CONTENT:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case CONTENT_TYPE$1:
        return memberValue === EMPTY_STRING;
      case CONTENT_ENCRYPTION_ALGORITHM:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case ENCRYPTED_CONTENT:
        return memberValue.isEqual(_EncryptedContentInfo.defaultValues(ENCRYPTED_CONTENT));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.contentType || EMPTY_STRING }),
        AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}),
        new asn1js.Choice({
          value: [
            new asn1js.Constructed({
              name: names.encryptedContent || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js.Repeated({
                  value: new asn1js.OctetString()
                })
              ]
            }),
            new asn1js.Primitive({
              name: names.encryptedContent || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$15);
    const asn1 = asn1js.compareSchema(schema, schema, _EncryptedContentInfo.schema({
      names: {
        contentType: CONTENT_TYPE$1,
        contentEncryptionAlgorithm: {
          names: {
            blockName: CONTENT_ENCRYPTION_ALGORITHM
          }
        },
        encryptedContent: ENCRYPTED_CONTENT
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.contentType = asn1.result.contentType.valueBlock.toString();
    this.contentEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.contentEncryptionAlgorithm });
    if (ENCRYPTED_CONTENT in asn1.result) {
      this.encryptedContent = asn1.result.encryptedContent;
      this.encryptedContent.idBlock.tagClass = 1;
      this.encryptedContent.idBlock.tagNumber = 4;
    }
  }
  toSchema() {
    const sequenceLengthBlock = {
      isIndefiniteForm: false
    };
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.contentType }));
    outputArray.push(this.contentEncryptionAlgorithm.toSchema());
    if (this.encryptedContent) {
      sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
      const encryptedValue = this.encryptedContent;
      encryptedValue.idBlock.tagClass = 3;
      encryptedValue.idBlock.tagNumber = 0;
      encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
      outputArray.push(encryptedValue);
    }
    return new asn1js.Sequence({
      lenBlock: sequenceLengthBlock,
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      contentType: this.contentType,
      contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
    };
    if (this.encryptedContent) {
      res.encryptedContent = this.encryptedContent.toJSON();
    }
    return res;
  }
  getEncryptedContent() {
    if (!this.encryptedContent) {
      throw new Error("Parameter 'encryptedContent' is undefined");
    }
    return asn1js.OctetString.prototype.getValue.call(this.encryptedContent);
  }
};
EncryptedContentInfo.CLASS_NAME = "EncryptedContentInfo";
var HASH_ALGORITHM$4 = "hashAlgorithm";
var MASK_GEN_ALGORITHM$1 = "maskGenAlgorithm";
var SALT_LENGTH = "saltLength";
var TRAILER_FIELD = "trailerField";
var CLEAR_PROPS$14 = [
  HASH_ALGORITHM$4,
  MASK_GEN_ALGORITHM$1,
  SALT_LENGTH,
  TRAILER_FIELD
];
var RSASSAPSSParams = class _RSASSAPSSParams extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$4, _RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4));
    this.maskGenAlgorithm = getParametersValue(parameters, MASK_GEN_ALGORITHM$1, _RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1));
    this.saltLength = getParametersValue(parameters, SALT_LENGTH, _RSASSAPSSParams.defaultValues(SALT_LENGTH));
    this.trailerField = getParametersValue(parameters, TRAILER_FIELD, _RSASSAPSSParams.defaultValues(TRAILER_FIELD));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case HASH_ALGORITHM$4:
        return new AlgorithmIdentifier({
          algorithmId: "1.3.14.3.2.26",
          algorithmParams: new asn1js.Null()
        });
      case MASK_GEN_ALGORITHM$1:
        return new AlgorithmIdentifier({
          algorithmId: "1.2.840.113549.1.1.8",
          algorithmParams: new AlgorithmIdentifier({
            algorithmId: "1.3.14.3.2.26",
            algorithmParams: new asn1js.Null()
          }).toSchema()
        });
      case SALT_LENGTH:
        return 20;
      case TRAILER_FIELD:
        return 1;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          optional: true,
          value: [new asn1js.Integer({ name: names.saltLength || EMPTY_STRING })]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 3
          },
          optional: true,
          value: [new asn1js.Integer({ name: names.trailerField || EMPTY_STRING })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$14);
    const asn1 = asn1js.compareSchema(schema, schema, _RSASSAPSSParams.schema({
      names: {
        hashAlgorithm: {
          names: {
            blockName: HASH_ALGORITHM$4
          }
        },
        maskGenAlgorithm: {
          names: {
            blockName: MASK_GEN_ALGORITHM$1
          }
        },
        saltLength: SALT_LENGTH,
        trailerField: TRAILER_FIELD
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (HASH_ALGORITHM$4 in asn1.result)
      this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
    if (MASK_GEN_ALGORITHM$1 in asn1.result)
      this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });
    if (SALT_LENGTH in asn1.result)
      this.saltLength = asn1.result.saltLength.valueBlock.valueDec;
    if (TRAILER_FIELD in asn1.result)
      this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
  }
  toSchema() {
    const outputArray = [];
    if (!this.hashAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [this.hashAlgorithm.toSchema()]
      }));
    }
    if (!this.maskGenAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [this.maskGenAlgorithm.toSchema()]
      }));
    }
    if (this.saltLength !== _RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        value: [new asn1js.Integer({ value: this.saltLength })]
      }));
    }
    if (this.trailerField !== _RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        value: [new asn1js.Integer({ value: this.trailerField })]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {};
    if (!this.hashAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
      res.hashAlgorithm = this.hashAlgorithm.toJSON();
    }
    if (!this.maskGenAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
      res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
    }
    if (this.saltLength !== _RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
      res.saltLength = this.saltLength;
    }
    if (this.trailerField !== _RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
      res.trailerField = this.trailerField;
    }
    return res;
  }
};
RSASSAPSSParams.CLASS_NAME = "RSASSAPSSParams";
var SALT = "salt";
var ITERATION_COUNT = "iterationCount";
var KEY_LENGTH = "keyLength";
var PRF = "prf";
var CLEAR_PROPS$13 = [
  SALT,
  ITERATION_COUNT,
  KEY_LENGTH,
  PRF
];
var PBKDF2Params = class _PBKDF2Params extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.salt = getParametersValue(parameters, SALT, _PBKDF2Params.defaultValues(SALT));
    this.iterationCount = getParametersValue(parameters, ITERATION_COUNT, _PBKDF2Params.defaultValues(ITERATION_COUNT));
    if (KEY_LENGTH in parameters) {
      this.keyLength = getParametersValue(parameters, KEY_LENGTH, _PBKDF2Params.defaultValues(KEY_LENGTH));
    }
    if (PRF in parameters) {
      this.prf = getParametersValue(parameters, PRF, _PBKDF2Params.defaultValues(PRF));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SALT:
        return {};
      case ITERATION_COUNT:
        return -1;
      case KEY_LENGTH:
        return 0;
      case PRF:
        return new AlgorithmIdentifier({
          algorithmId: "1.3.14.3.2.26",
          algorithmParams: new asn1js.Null()
        });
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Choice({
          value: [
            new asn1js.OctetString({ name: names.saltPrimitive || EMPTY_STRING }),
            AlgorithmIdentifier.schema(names.saltConstructed || {})
          ]
        }),
        new asn1js.Integer({ name: names.iterationCount || EMPTY_STRING }),
        new asn1js.Integer({
          name: names.keyLength || EMPTY_STRING,
          optional: true
        }),
        AlgorithmIdentifier.schema(names.prf || {
          names: {
            optional: true
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$13);
    const asn1 = asn1js.compareSchema(schema, schema, _PBKDF2Params.schema({
      names: {
        saltPrimitive: SALT,
        saltConstructed: {
          names: {
            blockName: SALT
          }
        },
        iterationCount: ITERATION_COUNT,
        keyLength: KEY_LENGTH,
        prf: {
          names: {
            blockName: PRF,
            optional: true
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.salt = asn1.result.salt;
    this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;
    if (KEY_LENGTH in asn1.result)
      this.keyLength = asn1.result.keyLength.valueBlock.valueDec;
    if (PRF in asn1.result)
      this.prf = new AlgorithmIdentifier({ schema: asn1.result.prf });
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.salt);
    outputArray.push(new asn1js.Integer({ value: this.iterationCount }));
    if (KEY_LENGTH in this) {
      if (_PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength)
        outputArray.push(new asn1js.Integer({ value: this.keyLength }));
    }
    if (this.prf) {
      if (_PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false)
        outputArray.push(this.prf.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      salt: this.salt.toJSON(),
      iterationCount: this.iterationCount
    };
    if (KEY_LENGTH in this) {
      if (_PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength)
        res.keyLength = this.keyLength;
    }
    if (this.prf) {
      if (_PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false)
        res.prf = this.prf.toJSON();
    }
    return res;
  }
};
PBKDF2Params.CLASS_NAME = "PBKDF2Params";
var KEY_DERIVATION_FUNC = "keyDerivationFunc";
var ENCRYPTION_SCHEME = "encryptionScheme";
var CLEAR_PROPS$12 = [
  KEY_DERIVATION_FUNC,
  ENCRYPTION_SCHEME
];
var PBES2Params = class _PBES2Params extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.keyDerivationFunc = getParametersValue(parameters, KEY_DERIVATION_FUNC, _PBES2Params.defaultValues(KEY_DERIVATION_FUNC));
    this.encryptionScheme = getParametersValue(parameters, ENCRYPTION_SCHEME, _PBES2Params.defaultValues(ENCRYPTION_SCHEME));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case KEY_DERIVATION_FUNC:
        return new AlgorithmIdentifier();
      case ENCRYPTION_SCHEME:
        return new AlgorithmIdentifier();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.keyDerivationFunc || {}),
        AlgorithmIdentifier.schema(names.encryptionScheme || {})
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$12);
    const asn1 = asn1js.compareSchema(schema, schema, _PBES2Params.schema({
      names: {
        keyDerivationFunc: {
          names: {
            blockName: KEY_DERIVATION_FUNC
          }
        },
        encryptionScheme: {
          names: {
            blockName: ENCRYPTION_SCHEME
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.keyDerivationFunc = new AlgorithmIdentifier({ schema: asn1.result.keyDerivationFunc });
    this.encryptionScheme = new AlgorithmIdentifier({ schema: asn1.result.encryptionScheme });
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.keyDerivationFunc.toSchema(),
        this.encryptionScheme.toSchema()
      ]
    });
  }
  toJSON() {
    return {
      keyDerivationFunc: this.keyDerivationFunc.toJSON(),
      encryptionScheme: this.encryptionScheme.toJSON()
    };
  }
};
PBES2Params.CLASS_NAME = "PBES2Params";
var AbstractCryptoEngine = class {
  constructor(parameters) {
    this.crypto = parameters.crypto;
    this.subtle = "webkitSubtle" in parameters.crypto ? parameters.crypto.webkitSubtle : parameters.crypto.subtle;
    this.name = getParametersValue(parameters, "name", EMPTY_STRING);
  }
  async encrypt(...args) {
    return this.subtle.encrypt(...args);
  }
  async decrypt(...args) {
    return this.subtle.decrypt(...args);
  }
  sign(...args) {
    return this.subtle.sign(...args);
  }
  async verify(...args) {
    return this.subtle.verify(...args);
  }
  async digest(...args) {
    return this.subtle.digest(...args);
  }
  async generateKey(...args) {
    return this.subtle.generateKey(...args);
  }
  async deriveKey(...args) {
    return this.subtle.deriveKey(...args);
  }
  async deriveBits(...args) {
    return this.subtle.deriveBits(...args);
  }
  async wrapKey(...args) {
    return this.subtle.wrapKey(...args);
  }
  async unwrapKey(...args) {
    return this.subtle.unwrapKey(...args);
  }
  exportKey(...args) {
    return this.subtle.exportKey(...args);
  }
  importKey(...args) {
    return this.subtle.importKey(...args);
  }
  getRandomValues(array) {
    return this.crypto.getRandomValues(array);
  }
};
async function makePKCS12B2Key(hashAlgorithm, keyLength, password, salt, iterationCount) {
  let u;
  let v;
  let md2;
  switch (hashAlgorithm.toUpperCase()) {
    case "SHA-1":
      u = 20;
      v = 64;
      md2 = sha12;
      break;
    case "SHA-256":
      u = 32;
      v = 64;
      md2 = sha2563;
      break;
    case "SHA-384":
      u = 48;
      v = 128;
      md2 = sha3842;
      break;
    case "SHA-512":
      u = 64;
      v = 128;
      md2 = sha5124;
      break;
    default:
      throw new Error("Unsupported hashing algorithm");
  }
  const originalPassword = new Uint8Array(password);
  let decodedPassword = new TextDecoder().decode(password);
  const encodedPassword = new TextEncoder().encode(decodedPassword);
  if (encodedPassword.some((byte, i2) => byte !== originalPassword[i2])) {
    decodedPassword = String.fromCharCode(...originalPassword);
  }
  const passwordTransformed = new Uint8Array(decodedPassword.length * 2 + 2);
  const passwordView = new DataView(passwordTransformed.buffer);
  for (let i2 = 0; i2 < decodedPassword.length; i2++) {
    passwordView.setUint16(i2 * 2, decodedPassword.charCodeAt(i2), false);
  }
  passwordView.setUint16(decodedPassword.length * 2, 0, false);
  const D = new Uint8Array(v).fill(3);
  const saltView = new Uint8Array(salt);
  const S = new Uint8Array(v * Math.ceil(saltView.length / v)).map((_, i2) => saltView[i2 % saltView.length]);
  const P = new Uint8Array(v * Math.ceil(passwordTransformed.length / v)).map((_, i2) => passwordTransformed[i2 % passwordTransformed.length]);
  let I = new Uint8Array(S.length + P.length);
  I.set(S);
  I.set(P, S.length);
  const c = Math.ceil((keyLength >> 3) / u);
  const result = [];
  for (let i2 = 0; i2 < c; i2++) {
    let A = new Uint8Array(D.length + I.length);
    A.set(D);
    A.set(I, D.length);
    for (let j = 0; j < iterationCount; j++) {
      A = md2(A);
    }
    const B = new Uint8Array(v).map((_, i3) => A[i3 % A.length]);
    const k = Math.ceil(saltView.length / v) + Math.ceil(passwordTransformed.length / v);
    const iRound = [];
    for (let j = 0; j < k; j++) {
      const chunk = Array.from(I.slice(j * v, (j + 1) * v));
      let x = 511;
      for (let l = B.length - 1; l >= 0; l--) {
        x >>= 8;
        x += B[l] + (chunk[l] || 0);
        chunk[l] = x & 255;
      }
      iRound.push(...chunk);
    }
    I = new Uint8Array(iRound);
    result.push(...A);
  }
  return new Uint8Array(result.slice(0, keyLength >> 3)).buffer;
}
function prepareAlgorithm(data) {
  const res = typeof data === "string" ? { name: data } : data;
  if ("hash" in res) {
    return {
      ...res,
      hash: prepareAlgorithm(res.hash)
    };
  }
  return res;
}
var CryptoEngine = class extends AbstractCryptoEngine {
  async importKey(format2, keyData, algorithm, extractable, keyUsages) {
    var _a3, _b, _c, _d, _e, _f;
    let jwk = {};
    const alg = prepareAlgorithm(algorithm);
    switch (format2.toLowerCase()) {
      case "raw":
        return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);
      case "spki":
        {
          const asn1 = asn1js.fromBER(BufferSourceConverter.toArrayBuffer(keyData));
          AsnError.assert(asn1, "keyData");
          const publicKeyInfo = new PublicKeyInfo();
          try {
            publicKeyInfo.fromSchema(asn1.result);
          } catch {
            throw new ArgumentError("Incorrect keyData");
          }
          switch (alg.name.toUpperCase()) {
            case "RSA-PSS": {
              if (!alg.hash) {
                throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
              }
              switch (alg.hash.name.toUpperCase()) {
                case "SHA-1":
                  jwk.alg = "PS1";
                  break;
                case "SHA-256":
                  jwk.alg = "PS256";
                  break;
                case "SHA-384":
                  jwk.alg = "PS384";
                  break;
                case "SHA-512":
                  jwk.alg = "PS512";
                  break;
                default:
                  throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
              }
            }
            case "RSASSA-PKCS1-V1_5":
              {
                keyUsages = ["verify"];
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1")
                  throw new Error(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                if (!jwk.alg) {
                  if (!alg.hash) {
                    throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                  }
                  switch (alg.hash.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "RS1";
                      break;
                    case "SHA-256":
                      jwk.alg = "RS256";
                      break;
                    case "SHA-384":
                      jwk.alg = "RS384";
                      break;
                    case "SHA-512":
                      jwk.alg = "RS512";
                      break;
                    default:
                      throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                  }
                }
                const publicKeyJSON = publicKeyInfo.toJSON();
                Object.assign(jwk, publicKeyJSON);
              }
              break;
            case "ECDSA":
              keyUsages = ["verify"];
            case "ECDH":
              {
                jwk = {
                  kty: "EC",
                  ext: extractable,
                  key_ops: keyUsages
                };
                if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1") {
                  throw new Error(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                }
                const publicKeyJSON = publicKeyInfo.toJSON();
                Object.assign(jwk, publicKeyJSON);
              }
              break;
            case "RSA-OAEP":
              {
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (this.name.toLowerCase() === "safari")
                  jwk.alg = "RSA-OAEP";
                else {
                  if (!alg.hash) {
                    throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                  }
                  switch (alg.hash.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "RSA-OAEP";
                      break;
                    case "SHA-256":
                      jwk.alg = "RSA-OAEP-256";
                      break;
                    case "SHA-384":
                      jwk.alg = "RSA-OAEP-384";
                      break;
                    case "SHA-512":
                      jwk.alg = "RSA-OAEP-512";
                      break;
                    default:
                      throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                  }
                }
                const publicKeyJSON = publicKeyInfo.toJSON();
                Object.assign(jwk, publicKeyJSON);
              }
              break;
            case "RSAES-PKCS1-V1_5":
              {
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                jwk.alg = "PS1";
                const publicKeyJSON = publicKeyInfo.toJSON();
                Object.assign(jwk, publicKeyJSON);
              }
              break;
            default:
              throw new Error(`Incorrect algorithm name: ${alg.name.toUpperCase()}`);
          }
        }
        break;
      case "pkcs8":
        {
          const privateKeyInfo = new PrivateKeyInfo();
          const asn1 = asn1js.fromBER(BufferSourceConverter.toArrayBuffer(keyData));
          AsnError.assert(asn1, "keyData");
          try {
            privateKeyInfo.fromSchema(asn1.result);
          } catch (ex) {
            throw new Error("Incorrect keyData");
          }
          if (!privateKeyInfo.parsedKey)
            throw new Error("Incorrect keyData");
          switch (alg.name.toUpperCase()) {
            case "RSA-PSS": {
              switch ((_a3 = alg.hash) === null || _a3 === void 0 ? void 0 : _a3.name.toUpperCase()) {
                case "SHA-1":
                  jwk.alg = "PS1";
                  break;
                case "SHA-256":
                  jwk.alg = "PS256";
                  break;
                case "SHA-384":
                  jwk.alg = "PS384";
                  break;
                case "SHA-512":
                  jwk.alg = "PS512";
                  break;
                default:
                  throw new Error(`Incorrect hash algorithm: ${(_b = alg.hash) === null || _b === void 0 ? void 0 : _b.name.toUpperCase()}`);
              }
            }
            case "RSASSA-PKCS1-V1_5":
              {
                keyUsages = ["sign"];
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1")
                  throw new Error(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                if ("alg" in jwk === false) {
                  switch ((_c = alg.hash) === null || _c === void 0 ? void 0 : _c.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "RS1";
                      break;
                    case "SHA-256":
                      jwk.alg = "RS256";
                      break;
                    case "SHA-384":
                      jwk.alg = "RS384";
                      break;
                    case "SHA-512":
                      jwk.alg = "RS512";
                      break;
                    default:
                      throw new Error(`Incorrect hash algorithm: ${(_d = alg.hash) === null || _d === void 0 ? void 0 : _d.name.toUpperCase()}`);
                  }
                }
                const privateKeyJSON = privateKeyInfo.toJSON();
                Object.assign(jwk, privateKeyJSON);
              }
              break;
            case "ECDSA":
              keyUsages = ["sign"];
            case "ECDH":
              {
                jwk = {
                  kty: "EC",
                  ext: extractable,
                  key_ops: keyUsages
                };
                if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1")
                  throw new Error(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                const privateKeyJSON = privateKeyInfo.toJSON();
                Object.assign(jwk, privateKeyJSON);
              }
              break;
            case "RSA-OAEP":
              {
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                if (this.name.toLowerCase() === "safari")
                  jwk.alg = "RSA-OAEP";
                else {
                  switch ((_e = alg.hash) === null || _e === void 0 ? void 0 : _e.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "RSA-OAEP";
                      break;
                    case "SHA-256":
                      jwk.alg = "RSA-OAEP-256";
                      break;
                    case "SHA-384":
                      jwk.alg = "RSA-OAEP-384";
                      break;
                    case "SHA-512":
                      jwk.alg = "RSA-OAEP-512";
                      break;
                    default:
                      throw new Error(`Incorrect hash algorithm: ${(_f = alg.hash) === null || _f === void 0 ? void 0 : _f.name.toUpperCase()}`);
                  }
                }
                const privateKeyJSON = privateKeyInfo.toJSON();
                Object.assign(jwk, privateKeyJSON);
              }
              break;
            case "RSAES-PKCS1-V1_5":
              {
                keyUsages = ["decrypt"];
                jwk.kty = "RSA";
                jwk.ext = extractable;
                jwk.key_ops = keyUsages;
                jwk.alg = "PS1";
                const privateKeyJSON = privateKeyInfo.toJSON();
                Object.assign(jwk, privateKeyJSON);
              }
              break;
            default:
              throw new Error(`Incorrect algorithm name: ${alg.name.toUpperCase()}`);
          }
        }
        break;
      case "jwk":
        jwk = keyData;
        break;
      default:
        throw new Error(`Incorrect format: ${format2}`);
    }
    if (this.name.toLowerCase() === "safari") {
      try {
        return this.subtle.importKey("jwk", stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages);
      } catch {
        return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
      }
    }
    return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
  }
  async exportKey(format2, key) {
    let jwk = await this.subtle.exportKey("jwk", key);
    if (this.name.toLowerCase() === "safari") {
      if (jwk instanceof ArrayBuffer) {
        jwk = JSON.parse(arrayBufferToString(jwk));
      }
    }
    switch (format2.toLowerCase()) {
      case "raw":
        return this.subtle.exportKey("raw", key);
      case "spki": {
        const publicKeyInfo = new PublicKeyInfo();
        try {
          publicKeyInfo.fromJSON(jwk);
        } catch (ex) {
          throw new Error("Incorrect key data");
        }
        return publicKeyInfo.toSchema().toBER(false);
      }
      case "pkcs8": {
        const privateKeyInfo = new PrivateKeyInfo();
        try {
          privateKeyInfo.fromJSON(jwk);
        } catch (ex) {
          throw new Error("Incorrect key data");
        }
        return privateKeyInfo.toSchema().toBER(false);
      }
      case "jwk":
        return jwk;
      default:
        throw new Error(`Incorrect format: ${format2}`);
    }
  }
  async convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
    if (inputFormat.toLowerCase() === outputFormat.toLowerCase()) {
      return keyData;
    }
    const key = await this.importKey(inputFormat, keyData, algorithm, extractable, keyUsages);
    return this.exportKey(outputFormat, key);
  }
  getAlgorithmByOID(oid, safety = false, target) {
    switch (oid) {
      case "1.2.840.113549.1.1.1":
        return {
          name: "RSAES-PKCS1-v1_5"
        };
      case "1.2.840.113549.1.1.5":
        return {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-1"
          }
        };
      case "1.2.840.113549.1.1.11":
        return {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-256"
          }
        };
      case "1.2.840.113549.1.1.12":
        return {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-384"
          }
        };
      case "1.2.840.113549.1.1.13":
        return {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-512"
          }
        };
      case "1.2.840.113549.1.1.10":
        return {
          name: "RSA-PSS"
        };
      case "1.2.840.113549.1.1.7":
        return {
          name: "RSA-OAEP"
        };
      case "1.2.840.10045.2.1":
      case "1.2.840.10045.4.1":
        return {
          name: "ECDSA",
          hash: {
            name: "SHA-1"
          }
        };
      case "1.2.840.10045.4.3.2":
        return {
          name: "ECDSA",
          hash: {
            name: "SHA-256"
          }
        };
      case "1.2.840.10045.4.3.3":
        return {
          name: "ECDSA",
          hash: {
            name: "SHA-384"
          }
        };
      case "1.2.840.10045.4.3.4":
        return {
          name: "ECDSA",
          hash: {
            name: "SHA-512"
          }
        };
      case "1.3.133.16.840.63.0.2":
        return {
          name: "ECDH",
          kdf: "SHA-1"
        };
      case "1.3.132.1.11.1":
        return {
          name: "ECDH",
          kdf: "SHA-256"
        };
      case "1.3.132.1.11.2":
        return {
          name: "ECDH",
          kdf: "SHA-384"
        };
      case "1.3.132.1.11.3":
        return {
          name: "ECDH",
          kdf: "SHA-512"
        };
      case "2.16.840.1.101.3.4.1.2":
        return {
          name: "AES-CBC",
          length: 128
        };
      case "2.16.840.1.101.3.4.1.22":
        return {
          name: "AES-CBC",
          length: 192
        };
      case "2.16.840.1.101.3.4.1.42":
        return {
          name: "AES-CBC",
          length: 256
        };
      case "2.16.840.1.101.3.4.1.6":
        return {
          name: "AES-GCM",
          length: 128
        };
      case "2.16.840.1.101.3.4.1.26":
        return {
          name: "AES-GCM",
          length: 192
        };
      case "2.16.840.1.101.3.4.1.46":
        return {
          name: "AES-GCM",
          length: 256
        };
      case "2.16.840.1.101.3.4.1.4":
        return {
          name: "AES-CFB",
          length: 128
        };
      case "2.16.840.1.101.3.4.1.24":
        return {
          name: "AES-CFB",
          length: 192
        };
      case "2.16.840.1.101.3.4.1.44":
        return {
          name: "AES-CFB",
          length: 256
        };
      case "2.16.840.1.101.3.4.1.5":
        return {
          name: "AES-KW",
          length: 128
        };
      case "2.16.840.1.101.3.4.1.25":
        return {
          name: "AES-KW",
          length: 192
        };
      case "2.16.840.1.101.3.4.1.45":
        return {
          name: "AES-KW",
          length: 256
        };
      case "1.2.840.113549.2.7":
        return {
          name: "HMAC",
          hash: {
            name: "SHA-1"
          }
        };
      case "1.2.840.113549.2.9":
        return {
          name: "HMAC",
          hash: {
            name: "SHA-256"
          }
        };
      case "1.2.840.113549.2.10":
        return {
          name: "HMAC",
          hash: {
            name: "SHA-384"
          }
        };
      case "1.2.840.113549.2.11":
        return {
          name: "HMAC",
          hash: {
            name: "SHA-512"
          }
        };
      case "1.2.840.113549.1.9.16.3.5":
        return {
          name: "DH"
        };
      case "1.3.14.3.2.26":
        return {
          name: "SHA-1"
        };
      case "2.16.840.1.101.3.4.2.1":
        return {
          name: "SHA-256"
        };
      case "2.16.840.1.101.3.4.2.2":
        return {
          name: "SHA-384"
        };
      case "2.16.840.1.101.3.4.2.3":
        return {
          name: "SHA-512"
        };
      case "1.2.840.113549.1.5.12":
        return {
          name: "PBKDF2"
        };
      case "1.2.840.10045.3.1.7":
        return {
          name: "P-256"
        };
      case "1.3.132.0.34":
        return {
          name: "P-384"
        };
      case "1.3.132.0.35":
        return {
          name: "P-521"
        };
    }
    if (safety) {
      throw new Error(`Unsupported algorithm identifier ${target ? `for ${target} ` : EMPTY_STRING}: ${oid}`);
    }
    return {};
  }
  getOIDByAlgorithm(algorithm, safety = false, target) {
    let result = EMPTY_STRING;
    switch (algorithm.name.toUpperCase()) {
      case "RSAES-PKCS1-V1_5":
        result = "1.2.840.113549.1.1.1";
        break;
      case "RSASSA-PKCS1-V1_5":
        switch (algorithm.hash.name.toUpperCase()) {
          case "SHA-1":
            result = "1.2.840.113549.1.1.5";
            break;
          case "SHA-256":
            result = "1.2.840.113549.1.1.11";
            break;
          case "SHA-384":
            result = "1.2.840.113549.1.1.12";
            break;
          case "SHA-512":
            result = "1.2.840.113549.1.1.13";
            break;
        }
        break;
      case "RSA-PSS":
        result = "1.2.840.113549.1.1.10";
        break;
      case "RSA-OAEP":
        result = "1.2.840.113549.1.1.7";
        break;
      case "ECDSA":
        switch (algorithm.hash.name.toUpperCase()) {
          case "SHA-1":
            result = "1.2.840.10045.4.1";
            break;
          case "SHA-256":
            result = "1.2.840.10045.4.3.2";
            break;
          case "SHA-384":
            result = "1.2.840.10045.4.3.3";
            break;
          case "SHA-512":
            result = "1.2.840.10045.4.3.4";
            break;
        }
        break;
      case "ECDH":
        switch (algorithm.kdf.toUpperCase()) {
          case "SHA-1":
            result = "1.3.133.16.840.63.0.2";
            break;
          case "SHA-256":
            result = "1.3.132.1.11.1";
            break;
          case "SHA-384":
            result = "1.3.132.1.11.2";
            break;
          case "SHA-512":
            result = "1.3.132.1.11.3";
            break;
        }
        break;
      case "AES-CTR":
        break;
      case "AES-CBC":
        switch (algorithm.length) {
          case 128:
            result = "2.16.840.1.101.3.4.1.2";
            break;
          case 192:
            result = "2.16.840.1.101.3.4.1.22";
            break;
          case 256:
            result = "2.16.840.1.101.3.4.1.42";
            break;
        }
        break;
      case "AES-CMAC":
        break;
      case "AES-GCM":
        switch (algorithm.length) {
          case 128:
            result = "2.16.840.1.101.3.4.1.6";
            break;
          case 192:
            result = "2.16.840.1.101.3.4.1.26";
            break;
          case 256:
            result = "2.16.840.1.101.3.4.1.46";
            break;
        }
        break;
      case "AES-CFB":
        switch (algorithm.length) {
          case 128:
            result = "2.16.840.1.101.3.4.1.4";
            break;
          case 192:
            result = "2.16.840.1.101.3.4.1.24";
            break;
          case 256:
            result = "2.16.840.1.101.3.4.1.44";
            break;
        }
        break;
      case "AES-KW":
        switch (algorithm.length) {
          case 128:
            result = "2.16.840.1.101.3.4.1.5";
            break;
          case 192:
            result = "2.16.840.1.101.3.4.1.25";
            break;
          case 256:
            result = "2.16.840.1.101.3.4.1.45";
            break;
        }
        break;
      case "HMAC":
        switch (algorithm.hash.name.toUpperCase()) {
          case "SHA-1":
            result = "1.2.840.113549.2.7";
            break;
          case "SHA-256":
            result = "1.2.840.113549.2.9";
            break;
          case "SHA-384":
            result = "1.2.840.113549.2.10";
            break;
          case "SHA-512":
            result = "1.2.840.113549.2.11";
            break;
        }
        break;
      case "DH":
        result = "1.2.840.113549.1.9.16.3.5";
        break;
      case "SHA-1":
        result = "1.3.14.3.2.26";
        break;
      case "SHA-256":
        result = "2.16.840.1.101.3.4.2.1";
        break;
      case "SHA-384":
        result = "2.16.840.1.101.3.4.2.2";
        break;
      case "SHA-512":
        result = "2.16.840.1.101.3.4.2.3";
        break;
      case "CONCAT":
        break;
      case "HKDF":
        break;
      case "PBKDF2":
        result = "1.2.840.113549.1.5.12";
        break;
      case "P-256":
        result = "1.2.840.10045.3.1.7";
        break;
      case "P-384":
        result = "1.3.132.0.34";
        break;
      case "P-521":
        result = "1.3.132.0.35";
        break;
    }
    if (!result && safety) {
      throw new Error(`Unsupported algorithm ${target ? `for ${target} ` : EMPTY_STRING}: ${algorithm.name}`);
    }
    return result;
  }
  getAlgorithmParameters(algorithmName, operation) {
    let result = {
      algorithm: {},
      usages: []
    };
    switch (algorithmName.toUpperCase()) {
      case "RSAES-PKCS1-V1_5":
      case "RSASSA-PKCS1-V1_5":
        switch (operation.toLowerCase()) {
          case "generatekey":
            result = {
              algorithm: {
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: {
                  name: "SHA-256"
                }
              },
              usages: ["sign", "verify"]
            };
            break;
          case "verify":
          case "sign":
          case "importkey":
            result = {
              algorithm: {
                name: "RSASSA-PKCS1-v1_5",
                hash: {
                  name: "SHA-256"
                }
              },
              usages: ["verify"]
            };
            break;
          case "exportkey":
          default:
            return {
              algorithm: {
                name: "RSASSA-PKCS1-v1_5"
              },
              usages: []
            };
        }
        break;
      case "RSA-PSS":
        switch (operation.toLowerCase()) {
          case "sign":
          case "verify":
            result = {
              algorithm: {
                name: "RSA-PSS",
                hash: {
                  name: "SHA-1"
                },
                saltLength: 20
              },
              usages: ["sign", "verify"]
            };
            break;
          case "generatekey":
            result = {
              algorithm: {
                name: "RSA-PSS",
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: {
                  name: "SHA-1"
                }
              },
              usages: ["sign", "verify"]
            };
            break;
          case "importkey":
            result = {
              algorithm: {
                name: "RSA-PSS",
                hash: {
                  name: "SHA-1"
                }
              },
              usages: ["verify"]
            };
            break;
          case "exportkey":
          default:
            return {
              algorithm: {
                name: "RSA-PSS"
              },
              usages: []
            };
        }
        break;
      case "RSA-OAEP":
        switch (operation.toLowerCase()) {
          case "encrypt":
          case "decrypt":
            result = {
              algorithm: {
                name: "RSA-OAEP"
              },
              usages: ["encrypt", "decrypt"]
            };
            break;
          case "generatekey":
            result = {
              algorithm: {
                name: "RSA-OAEP",
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: {
                  name: "SHA-256"
                }
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          case "importkey":
            result = {
              algorithm: {
                name: "RSA-OAEP",
                hash: {
                  name: "SHA-256"
                }
              },
              usages: ["encrypt"]
            };
            break;
          case "exportkey":
          default:
            return {
              algorithm: {
                name: "RSA-OAEP"
              },
              usages: []
            };
        }
        break;
      case "ECDSA":
        switch (operation.toLowerCase()) {
          case "generatekey":
            result = {
              algorithm: {
                name: "ECDSA",
                namedCurve: "P-256"
              },
              usages: ["sign", "verify"]
            };
            break;
          case "importkey":
            result = {
              algorithm: {
                name: "ECDSA",
                namedCurve: "P-256"
              },
              usages: ["verify"]
            };
            break;
          case "verify":
          case "sign":
            result = {
              algorithm: {
                name: "ECDSA",
                hash: {
                  name: "SHA-256"
                }
              },
              usages: ["sign"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "ECDSA"
              },
              usages: []
            };
        }
        break;
      case "ECDH":
        switch (operation.toLowerCase()) {
          case "exportkey":
          case "importkey":
          case "generatekey":
            result = {
              algorithm: {
                name: "ECDH",
                namedCurve: "P-256"
              },
              usages: ["deriveKey", "deriveBits"]
            };
            break;
          case "derivekey":
          case "derivebits":
            result = {
              algorithm: {
                name: "ECDH",
                namedCurve: "P-256",
                public: []
              },
              usages: ["encrypt", "decrypt"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "ECDH"
              },
              usages: []
            };
        }
        break;
      case "AES-CTR":
        switch (operation.toLowerCase()) {
          case "importkey":
          case "exportkey":
          case "generatekey":
            result = {
              algorithm: {
                name: "AES-CTR",
                length: 256
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          case "decrypt":
          case "encrypt":
            result = {
              algorithm: {
                name: "AES-CTR",
                counter: new Uint8Array(16),
                length: 10
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "AES-CTR"
              },
              usages: []
            };
        }
        break;
      case "AES-CBC":
        switch (operation.toLowerCase()) {
          case "importkey":
          case "exportkey":
          case "generatekey":
            result = {
              algorithm: {
                name: "AES-CBC",
                length: 256
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          case "decrypt":
          case "encrypt":
            result = {
              algorithm: {
                name: "AES-CBC",
                iv: this.getRandomValues(new Uint8Array(16))
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "AES-CBC"
              },
              usages: []
            };
        }
        break;
      case "AES-GCM":
        switch (operation.toLowerCase()) {
          case "importkey":
          case "exportkey":
          case "generatekey":
            result = {
              algorithm: {
                name: "AES-GCM",
                length: 256
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          case "decrypt":
          case "encrypt":
            result = {
              algorithm: {
                name: "AES-GCM",
                iv: this.getRandomValues(new Uint8Array(16))
              },
              usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "AES-GCM"
              },
              usages: []
            };
        }
        break;
      case "AES-KW":
        switch (operation.toLowerCase()) {
          case "importkey":
          case "exportkey":
          case "generatekey":
          case "wrapkey":
          case "unwrapkey":
            result = {
              algorithm: {
                name: "AES-KW",
                length: 256
              },
              usages: ["wrapKey", "unwrapKey"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "AES-KW"
              },
              usages: []
            };
        }
        break;
      case "HMAC":
        switch (operation.toLowerCase()) {
          case "sign":
          case "verify":
            result = {
              algorithm: {
                name: "HMAC"
              },
              usages: ["sign", "verify"]
            };
            break;
          case "importkey":
          case "exportkey":
          case "generatekey":
            result = {
              algorithm: {
                name: "HMAC",
                length: 32,
                hash: {
                  name: "SHA-256"
                }
              },
              usages: ["sign", "verify"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "HMAC"
              },
              usages: []
            };
        }
        break;
      case "HKDF":
        switch (operation.toLowerCase()) {
          case "derivekey":
            result = {
              algorithm: {
                name: "HKDF",
                hash: "SHA-256",
                salt: new Uint8Array([]),
                info: new Uint8Array([])
              },
              usages: ["encrypt", "decrypt"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "HKDF"
              },
              usages: []
            };
        }
        break;
      case "PBKDF2":
        switch (operation.toLowerCase()) {
          case "derivekey":
            result = {
              algorithm: {
                name: "PBKDF2",
                hash: { name: "SHA-256" },
                salt: new Uint8Array([]),
                iterations: 1e4
              },
              usages: ["encrypt", "decrypt"]
            };
            break;
          default:
            return {
              algorithm: {
                name: "PBKDF2"
              },
              usages: []
            };
        }
        break;
    }
    return result;
  }
  getHashAlgorithm(signatureAlgorithm) {
    let result = EMPTY_STRING;
    switch (signatureAlgorithm.algorithmId) {
      case "1.2.840.10045.4.1":
      case "1.2.840.113549.1.1.5":
        result = "SHA-1";
        break;
      case "1.2.840.10045.4.3.2":
      case "1.2.840.113549.1.1.11":
        result = "SHA-256";
        break;
      case "1.2.840.10045.4.3.3":
      case "1.2.840.113549.1.1.12":
        result = "SHA-384";
        break;
      case "1.2.840.10045.4.3.4":
      case "1.2.840.113549.1.1.13":
        result = "SHA-512";
        break;
      case "1.2.840.113549.1.1.10":
        {
          try {
            const params = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
            if (params.hashAlgorithm) {
              const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
              if ("name" in algorithm) {
                result = algorithm.name;
              } else {
                return EMPTY_STRING;
              }
            } else
              result = "SHA-1";
          } catch {
          }
        }
        break;
    }
    return result;
  }
  async encryptEncryptedContentInfo(parameters) {
    ParameterError.assert(parameters, "password", "contentEncryptionAlgorithm", "hmacHashAlgorithm", "iterationCount", "contentToEncrypt", "contentToEncrypt", "contentType");
    const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
    const pbkdf2OID = this.getOIDByAlgorithm({
      name: "PBKDF2"
    }, true, "PBKDF2");
    const hmacOID = this.getOIDByAlgorithm({
      name: "HMAC",
      hash: {
        name: parameters.hmacHashAlgorithm
      }
    }, true, "hmacHashAlgorithm");
    const ivBuffer = new ArrayBuffer(16);
    const ivView = new Uint8Array(ivBuffer);
    this.getRandomValues(ivView);
    const saltBuffer = new ArrayBuffer(64);
    const saltView = new Uint8Array(saltBuffer);
    this.getRandomValues(saltView);
    const contentView = new Uint8Array(parameters.contentToEncrypt);
    const pbkdf2Params = new PBKDF2Params({
      salt: new asn1js.OctetString({ valueHex: saltBuffer }),
      iterationCount: parameters.iterationCount,
      prf: new AlgorithmIdentifier({
        algorithmId: hmacOID,
        algorithmParams: new asn1js.Null()
      })
    });
    const passwordView = new Uint8Array(parameters.password);
    const pbkdfKey = await this.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
    const derivedKey = await this.deriveKey({
      name: "PBKDF2",
      hash: {
        name: parameters.hmacHashAlgorithm
      },
      salt: saltView,
      iterations: parameters.iterationCount
    }, pbkdfKey, parameters.contentEncryptionAlgorithm, false, ["encrypt"]);
    const encryptedData = await this.encrypt({
      name: parameters.contentEncryptionAlgorithm.name,
      iv: ivView
    }, derivedKey, contentView);
    const pbes2Parameters = new PBES2Params({
      keyDerivationFunc: new AlgorithmIdentifier({
        algorithmId: pbkdf2OID,
        algorithmParams: pbkdf2Params.toSchema()
      }),
      encryptionScheme: new AlgorithmIdentifier({
        algorithmId: contentEncryptionOID,
        algorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })
      })
    });
    return new EncryptedContentInfo({
      contentType: parameters.contentType,
      contentEncryptionAlgorithm: new AlgorithmIdentifier({
        algorithmId: "1.2.840.113549.1.5.13",
        algorithmParams: pbes2Parameters.toSchema()
      }),
      encryptedContent: new asn1js.OctetString({ valueHex: encryptedData })
    });
  }
  async decryptEncryptedContentInfo(parameters) {
    ParameterError.assert(parameters, "password", "encryptedContentInfo");
    if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13")
      throw new Error(`Unknown "contentEncryptionAlgorithm": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
    let pbes2Parameters;
    try {
      pbes2Parameters = new PBES2Params({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
    } catch (ex) {
      throw new Error('Incorrectly encoded "pbes2Parameters"');
    }
    let pbkdf2Params;
    try {
      pbkdf2Params = new PBKDF2Params({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
    } catch (ex) {
      throw new Error('Incorrectly encoded "pbkdf2Params"');
    }
    const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId, true);
    const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
    const ivView = new Uint8Array(ivBuffer);
    const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
    const saltView = new Uint8Array(saltBuffer);
    const iterationCount = pbkdf2Params.iterationCount;
    let hmacHashAlgorithm = "SHA-1";
    if (pbkdf2Params.prf) {
      const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true);
      hmacHashAlgorithm = algorithm.hash.name;
    }
    const pbkdfKey = await this.importKey("raw", parameters.password, "PBKDF2", false, ["deriveKey"]);
    const result = await this.deriveKey({
      name: "PBKDF2",
      hash: {
        name: hmacHashAlgorithm
      },
      salt: saltView,
      iterations: iterationCount
    }, pbkdfKey, contentEncryptionAlgorithm, false, ["decrypt"]);
    const dataBuffer = parameters.encryptedContentInfo.getEncryptedContent();
    return this.decrypt({
      name: contentEncryptionAlgorithm.name,
      iv: ivView
    }, result, dataBuffer);
  }
  async stampDataWithPassword(parameters) {
    if (parameters instanceof Object === false)
      throw new Error('Parameters must have type "Object"');
    ParameterError.assert(parameters, "password", "hashAlgorithm", "iterationCount", "salt", "contentToStamp");
    let length3;
    switch (parameters.hashAlgorithm.toLowerCase()) {
      case "sha-1":
        length3 = 160;
        break;
      case "sha-256":
        length3 = 256;
        break;
      case "sha-384":
        length3 = 384;
        break;
      case "sha-512":
        length3 = 512;
        break;
      default:
        throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
    }
    const hmacAlgorithm = {
      name: "HMAC",
      length: length3,
      hash: {
        name: parameters.hashAlgorithm
      }
    };
    const pkcsKey = await makePKCS12B2Key(parameters.hashAlgorithm, length3, parameters.password, parameters.salt, parameters.iterationCount);
    const hmacKey = await this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["sign"]);
    return this.sign(hmacAlgorithm, hmacKey, new Uint8Array(parameters.contentToStamp));
  }
  async verifyDataStampedWithPassword(parameters) {
    ParameterError.assert(parameters, "password", "hashAlgorithm", "salt", "iterationCount", "contentToVerify", "signatureToVerify");
    let length3 = 0;
    switch (parameters.hashAlgorithm.toLowerCase()) {
      case "sha-1":
        length3 = 160;
        break;
      case "sha-256":
        length3 = 256;
        break;
      case "sha-384":
        length3 = 384;
        break;
      case "sha-512":
        length3 = 512;
        break;
      default:
        throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
    }
    const hmacAlgorithm = {
      name: "HMAC",
      length: length3,
      hash: {
        name: parameters.hashAlgorithm
      }
    };
    const pkcsKey = await makePKCS12B2Key(parameters.hashAlgorithm, length3, parameters.password, parameters.salt, parameters.iterationCount);
    const hmacKey = await this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["verify"]);
    return this.verify(hmacAlgorithm, hmacKey, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify));
  }
  async getSignatureParameters(privateKey, hashAlgorithm = "SHA-1") {
    this.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
    const signatureAlgorithm = new AlgorithmIdentifier();
    const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
    if (!Object.keys(parameters.algorithm).length) {
      throw new Error("Parameter 'algorithm' is empty");
    }
    const algorithm = parameters.algorithm;
    if ("hash" in privateKey.algorithm && privateKey.algorithm.hash && privateKey.algorithm.hash.name) {
      algorithm.hash.name = privateKey.algorithm.hash.name;
    } else {
      algorithm.hash.name = hashAlgorithm;
    }
    switch (privateKey.algorithm.name.toUpperCase()) {
      case "RSASSA-PKCS1-V1_5":
      case "ECDSA":
        signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(algorithm, true);
        break;
      case "RSA-PSS":
        {
          switch (algorithm.hash.name.toUpperCase()) {
            case "SHA-256":
              algorithm.saltLength = 32;
              break;
            case "SHA-384":
              algorithm.saltLength = 48;
              break;
            case "SHA-512":
              algorithm.saltLength = 64;
              break;
          }
          const paramsObject = {};
          if (algorithm.hash.name.toUpperCase() !== "SHA-1") {
            const hashAlgorithmOID = this.getOIDByAlgorithm({ name: algorithm.hash.name }, true, "hashAlgorithm");
            paramsObject.hashAlgorithm = new AlgorithmIdentifier({
              algorithmId: hashAlgorithmOID,
              algorithmParams: new asn1js.Null()
            });
            paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.8",
              algorithmParams: paramsObject.hashAlgorithm.toSchema()
            });
          }
          if (algorithm.saltLength !== 20)
            paramsObject.saltLength = algorithm.saltLength;
          const pssParameters = new RSASSAPSSParams(paramsObject);
          signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
          signatureAlgorithm.algorithmParams = pssParameters.toSchema();
        }
        break;
      default:
        throw new Error(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
    }
    return {
      signatureAlgorithm,
      parameters
    };
  }
  async signWithPrivateKey(data, privateKey, parameters) {
    const signature = await this.sign(parameters.algorithm, privateKey, data);
    if (parameters.algorithm.name === "ECDSA") {
      return createCMSECDSASignature(signature);
    }
    return signature;
  }
  fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
    const parameters = {};
    const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
    if (shaAlgorithm === EMPTY_STRING)
      throw new Error(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
    let algorithmId;
    if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
      algorithmId = signatureAlgorithm.algorithmId;
    else
      algorithmId = publicKeyInfo.algorithm.algorithmId;
    const algorithmObject = this.getAlgorithmByOID(algorithmId, true);
    parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
    if ("hash" in parameters.algorithm.algorithm)
      parameters.algorithm.algorithm.hash.name = shaAlgorithm;
    if (algorithmObject.name === "ECDSA") {
      const publicKeyAlgorithm = publicKeyInfo.algorithm;
      if (!publicKeyAlgorithm.algorithmParams) {
        throw new Error("Algorithm parameters for ECDSA public key are missed");
      }
      const publicKeyAlgorithmParams = publicKeyAlgorithm.algorithmParams;
      if ("idBlock" in publicKeyAlgorithm.algorithmParams) {
        if (!(publicKeyAlgorithmParams.idBlock.tagClass === 1 && publicKeyAlgorithmParams.idBlock.tagNumber === 6)) {
          throw new Error("Incorrect type for ECDSA public key parameters");
        }
      }
      const curveObject = this.getAlgorithmByOID(publicKeyAlgorithmParams.valueBlock.toString(), true);
      parameters.algorithm.algorithm.namedCurve = curveObject.name;
    }
    return parameters;
  }
  async getPublicKey(publicKeyInfo, signatureAlgorithm, parameters) {
    if (!parameters) {
      parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
    }
    const publicKeyInfoBuffer = publicKeyInfo.toSchema().toBER(false);
    return this.importKey("spki", publicKeyInfoBuffer, parameters.algorithm.algorithm, true, parameters.algorithm.usages);
  }
  async verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm) {
    let publicKey;
    if (!shaAlgorithm) {
      shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
      if (!shaAlgorithm)
        throw new Error(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
      publicKey = await this.getPublicKey(publicKeyInfo, signatureAlgorithm);
    } else {
      const parameters = {};
      let algorithmId;
      if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
        algorithmId = signatureAlgorithm.algorithmId;
      else
        algorithmId = publicKeyInfo.algorithm.algorithmId;
      const algorithmObject = this.getAlgorithmByOID(algorithmId, true);
      parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
      if ("hash" in parameters.algorithm.algorithm)
        parameters.algorithm.algorithm.hash.name = shaAlgorithm;
      if (algorithmObject.name === "ECDSA") {
        let algorithmParamsChecked = false;
        if ("algorithmParams" in publicKeyInfo.algorithm === true) {
          if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
            if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6)
              algorithmParamsChecked = true;
          }
        }
        if (algorithmParamsChecked === false) {
          throw new Error("Incorrect type for ECDSA public key parameters");
        }
        const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString(), true);
        parameters.algorithm.algorithm.namedCurve = curveObject.name;
      }
      publicKey = await this.getPublicKey(publicKeyInfo, null, parameters);
    }
    const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
    if ("hash" in algorithm.algorithm)
      algorithm.algorithm.hash.name = shaAlgorithm;
    let signatureValue = signature.valueBlock.valueHexView;
    if (publicKey.algorithm.name === "ECDSA") {
      const namedCurve = ECNamedCurves.find(publicKey.algorithm.namedCurve);
      if (!namedCurve) {
        throw new Error("Unsupported named curve in use");
      }
      const asn1 = asn1js.fromBER(signatureValue);
      AsnError.assert(asn1, "Signature value");
      signatureValue = createECDSASignatureFromCMS(asn1.result, namedCurve.size);
    }
    if (publicKey.algorithm.name === "RSA-PSS") {
      const pssParameters = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
      if ("saltLength" in pssParameters)
        algorithm.algorithm.saltLength = pssParameters.saltLength;
      else
        algorithm.algorithm.saltLength = 20;
      let hashAlgo = "SHA-1";
      if ("hashAlgorithm" in pssParameters) {
        const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId, true);
        hashAlgo = hashAlgorithm.name;
      }
      algorithm.algorithm.hash.name = hashAlgo;
    }
    return this.verify(algorithm.algorithm, publicKey, signatureValue, data);
  }
};
var engine = {
  name: "none",
  crypto: null
};
function isCryptoEngine(engine2) {
  return engine2 && typeof engine2 === "object" && "crypto" in engine2 ? true : false;
}
function setEngine(name4, ...args) {
  let crypto9 = null;
  if (args.length < 2) {
    if (args.length) {
      crypto9 = args[0];
    } else {
      crypto9 = typeof self !== "undefined" && self.crypto ? new CryptoEngine({ name: "browser", crypto: self.crypto }) : null;
    }
  } else {
    const cryptoArg = args[0];
    const subtleArg = args[1];
    if (isCryptoEngine(subtleArg)) {
      crypto9 = subtleArg;
    } else if (isCryptoEngine(cryptoArg)) {
      crypto9 = cryptoArg;
    } else if ("subtle" in cryptoArg && "getRandomValues" in cryptoArg) {
      crypto9 = new CryptoEngine({
        crypto: cryptoArg
      });
    }
  }
  if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
    if (typeof global[process.pid] === "undefined") {
      global[process.pid] = {};
    } else {
      if (typeof global[process.pid] !== "object") {
        throw new Error(`Name global.${process.pid} already exists and it is not an object`);
      }
    }
    if (typeof global[process.pid].pkijs === "undefined") {
      global[process.pid].pkijs = {};
    } else {
      if (typeof global[process.pid].pkijs !== "object") {
        throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);
      }
    }
    global[process.pid].pkijs.engine = {
      name: name4,
      crypto: crypto9
    };
  } else {
    engine = {
      name: name4,
      crypto: crypto9
    };
  }
}
function getEngine() {
  if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
    let _engine;
    try {
      _engine = global[process.pid].pkijs.engine;
    } catch (ex) {
      throw new Error("Please call 'setEngine' before call to 'getEngine'");
    }
    return _engine;
  }
  return engine;
}
function getCrypto2(safety = false) {
  const _engine = getEngine();
  if (!_engine.crypto && safety) {
    throw new Error("Unable to create WebCrypto object");
  }
  return _engine.crypto;
}
function createCMSECDSASignature(signatureBuffer) {
  if (signatureBuffer.byteLength % 2 !== 0)
    return EMPTY_BUFFER;
  const length3 = signatureBuffer.byteLength / 2;
  const rBuffer = new ArrayBuffer(length3);
  const rView = new Uint8Array(rBuffer);
  rView.set(new Uint8Array(signatureBuffer, 0, length3));
  const rInteger = new asn1js.Integer({ valueHex: rBuffer });
  const sBuffer = new ArrayBuffer(length3);
  const sView = new Uint8Array(sBuffer);
  sView.set(new Uint8Array(signatureBuffer, length3, length3));
  const sInteger = new asn1js.Integer({ valueHex: sBuffer });
  return new asn1js.Sequence({
    value: [
      rInteger.convertToDER(),
      sInteger.convertToDER()
    ]
  }).toBER(false);
}
function createECDSASignatureFromCMS(cmsSignature, pointSize) {
  if (!(cmsSignature instanceof asn1js.Sequence && cmsSignature.valueBlock.value.length === 2 && cmsSignature.valueBlock.value[0] instanceof asn1js.Integer && cmsSignature.valueBlock.value[1] instanceof asn1js.Integer))
    return EMPTY_BUFFER;
  const rValueView = cmsSignature.valueBlock.value[0].convertFromDER().valueBlock.valueHexView;
  const sValueView = cmsSignature.valueBlock.value[1].convertFromDER().valueBlock.valueHexView;
  const res = new Uint8Array(pointSize * 2);
  res.set(rValueView, pointSize - rValueView.byteLength);
  res.set(sValueView, 2 * pointSize - sValueView.byteLength);
  return res.buffer;
}
async function kdfWithCounter(hashFunction, zBuffer, Counter, SharedInfo, crypto9) {
  switch (hashFunction.toUpperCase()) {
    case "SHA-1":
    case "SHA-256":
    case "SHA-384":
    case "SHA-512":
      break;
    default:
      throw new ArgumentError(`Unknown hash function: ${hashFunction}`);
  }
  ArgumentError.assert(zBuffer, "zBuffer", "ArrayBuffer");
  if (zBuffer.byteLength === 0)
    throw new ArgumentError("'zBuffer' has zero length, error");
  ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
  if (Counter > 255)
    throw new ArgumentError("Please set 'Counter' argument to value less or equal to 255");
  const counterBuffer = new ArrayBuffer(4);
  const counterView = new Uint8Array(counterBuffer);
  counterView[0] = 0;
  counterView[1] = 0;
  counterView[2] = 0;
  counterView[3] = Counter;
  let combinedBuffer = EMPTY_BUFFER;
  combinedBuffer = utilConcatBuf(combinedBuffer, zBuffer);
  combinedBuffer = utilConcatBuf(combinedBuffer, counterBuffer);
  combinedBuffer = utilConcatBuf(combinedBuffer, SharedInfo);
  const result = await crypto9.digest({ name: hashFunction }, combinedBuffer);
  return {
    counter: Counter,
    result
  };
}
async function kdf(hashFunction, Zbuffer, keydatalen, SharedInfo, crypto9 = getCrypto2(true)) {
  let hashLength = 0;
  let maxCounter = 1;
  switch (hashFunction.toUpperCase()) {
    case "SHA-1":
      hashLength = 160;
      break;
    case "SHA-256":
      hashLength = 256;
      break;
    case "SHA-384":
      hashLength = 384;
      break;
    case "SHA-512":
      hashLength = 512;
      break;
    default:
      throw new ArgumentError(`Unknown hash function: ${hashFunction}`);
  }
  ArgumentError.assert(Zbuffer, "Zbuffer", "ArrayBuffer");
  if (Zbuffer.byteLength === 0)
    throw new ArgumentError("'Zbuffer' has zero length, error");
  ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
  const quotient = keydatalen / hashLength;
  if (Math.floor(quotient) > 0) {
    maxCounter = Math.floor(quotient);
    if (quotient - maxCounter > 0)
      maxCounter++;
  }
  const incomingResult = [];
  for (let i2 = 1; i2 <= maxCounter; i2++)
    incomingResult.push(await kdfWithCounter(hashFunction, Zbuffer, i2, SharedInfo, crypto9));
  let combinedBuffer = EMPTY_BUFFER;
  let currentCounter = 1;
  let found = true;
  while (found) {
    found = false;
    for (const result of incomingResult) {
      if (result.counter === currentCounter) {
        combinedBuffer = utilConcatBuf(combinedBuffer, result.result);
        found = true;
        break;
      }
    }
    currentCounter++;
  }
  keydatalen >>= 3;
  if (combinedBuffer.byteLength > keydatalen) {
    const newBuffer = new ArrayBuffer(keydatalen);
    const newView = new Uint8Array(newBuffer);
    const combinedView = new Uint8Array(combinedBuffer);
    for (let i2 = 0; i2 < keydatalen; i2++)
      newView[i2] = combinedView[i2];
    return newBuffer;
  }
  return combinedBuffer;
}
var VERSION$i = "version";
var LOG_ID = "logID";
var EXTENSIONS$6 = "extensions";
var TIMESTAMP = "timestamp";
var HASH_ALGORITHM$3 = "hashAlgorithm";
var SIGNATURE_ALGORITHM$8 = "signatureAlgorithm";
var SIGNATURE$7 = "signature";
var NONE = "none";
var MD5 = "md5";
var SHA12 = "sha1";
var SHA2242 = "sha224";
var SHA2562 = "sha256";
var SHA3842 = "sha384";
var SHA5122 = "sha512";
var ANONYMOUS = "anonymous";
var RSA = "rsa";
var DSA = "dsa";
var ECDSA = "ecdsa";
var SignedCertificateTimestamp = class _SignedCertificateTimestamp extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$i, _SignedCertificateTimestamp.defaultValues(VERSION$i));
    this.logID = getParametersValue(parameters, LOG_ID, _SignedCertificateTimestamp.defaultValues(LOG_ID));
    this.timestamp = getParametersValue(parameters, TIMESTAMP, _SignedCertificateTimestamp.defaultValues(TIMESTAMP));
    this.extensions = getParametersValue(parameters, EXTENSIONS$6, _SignedCertificateTimestamp.defaultValues(EXTENSIONS$6));
    this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$3, _SignedCertificateTimestamp.defaultValues(HASH_ALGORITHM$3));
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$8, _SignedCertificateTimestamp.defaultValues(SIGNATURE_ALGORITHM$8));
    this.signature = getParametersValue(parameters, SIGNATURE$7, _SignedCertificateTimestamp.defaultValues(SIGNATURE$7));
    if ("stream" in parameters && parameters.stream) {
      this.fromStream(parameters.stream);
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$i:
        return 0;
      case LOG_ID:
      case EXTENSIONS$6:
        return EMPTY_BUFFER;
      case TIMESTAMP:
        return /* @__PURE__ */ new Date(0);
      case HASH_ALGORITHM$3:
      case SIGNATURE_ALGORITHM$8:
        return EMPTY_STRING;
      case SIGNATURE$7:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  fromSchema(schema) {
    if (schema instanceof asn1js.RawData === false)
      throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
    const seqStream = new SeqStream({
      stream: new ByteStream({
        buffer: schema.data
      })
    });
    this.fromStream(seqStream);
  }
  fromStream(stream2) {
    const blockLength = stream2.getUint16();
    this.version = stream2.getBlock(1)[0];
    if (this.version === 0) {
      this.logID = new Uint8Array(stream2.getBlock(32)).buffer.slice(0);
      this.timestamp = new Date(utilFromBase(new Uint8Array(stream2.getBlock(8)), 8));
      const extensionsLength = stream2.getUint16();
      this.extensions = new Uint8Array(stream2.getBlock(extensionsLength)).buffer.slice(0);
      switch (stream2.getBlock(1)[0]) {
        case 0:
          this.hashAlgorithm = NONE;
          break;
        case 1:
          this.hashAlgorithm = MD5;
          break;
        case 2:
          this.hashAlgorithm = SHA12;
          break;
        case 3:
          this.hashAlgorithm = SHA2242;
          break;
        case 4:
          this.hashAlgorithm = SHA2562;
          break;
        case 5:
          this.hashAlgorithm = SHA3842;
          break;
        case 6:
          this.hashAlgorithm = SHA5122;
          break;
        default:
          throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
      }
      switch (stream2.getBlock(1)[0]) {
        case 0:
          this.signatureAlgorithm = ANONYMOUS;
          break;
        case 1:
          this.signatureAlgorithm = RSA;
          break;
        case 2:
          this.signatureAlgorithm = DSA;
          break;
        case 3:
          this.signatureAlgorithm = ECDSA;
          break;
        default:
          throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
      }
      const signatureLength = stream2.getUint16();
      const signatureData = new Uint8Array(stream2.getBlock(signatureLength)).buffer.slice(0);
      const asn1 = asn1js.fromBER(signatureData);
      AsnError.assert(asn1, "SignedCertificateTimestamp");
      this.signature = asn1.result;
      if (blockLength !== 47 + extensionsLength + signatureLength) {
        throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
      }
    }
  }
  toSchema() {
    const stream2 = this.toStream();
    return new asn1js.RawData({ data: stream2.stream.buffer });
  }
  toStream() {
    const stream2 = new SeqStream();
    stream2.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecodeView.byteLength);
    stream2.appendChar(this.version);
    stream2.appendView(new Uint8Array(this.logID));
    const timeBuffer = new ArrayBuffer(8);
    const timeView = new Uint8Array(timeBuffer);
    const baseArray = utilToBase(this.timestamp.valueOf(), 8);
    timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
    stream2.appendView(timeView);
    stream2.appendUint16(this.extensions.byteLength);
    if (this.extensions.byteLength)
      stream2.appendView(new Uint8Array(this.extensions));
    let _hashAlgorithm;
    switch (this.hashAlgorithm.toLowerCase()) {
      case NONE:
        _hashAlgorithm = 0;
        break;
      case MD5:
        _hashAlgorithm = 1;
        break;
      case SHA12:
        _hashAlgorithm = 2;
        break;
      case SHA2242:
        _hashAlgorithm = 3;
        break;
      case SHA2562:
        _hashAlgorithm = 4;
        break;
      case SHA3842:
        _hashAlgorithm = 5;
        break;
      case SHA5122:
        _hashAlgorithm = 6;
        break;
      default:
        throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
    }
    stream2.appendChar(_hashAlgorithm);
    let _signatureAlgorithm;
    switch (this.signatureAlgorithm.toLowerCase()) {
      case ANONYMOUS:
        _signatureAlgorithm = 0;
        break;
      case RSA:
        _signatureAlgorithm = 1;
        break;
      case DSA:
        _signatureAlgorithm = 2;
        break;
      case ECDSA:
        _signatureAlgorithm = 3;
        break;
      default:
        throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
    }
    stream2.appendChar(_signatureAlgorithm);
    const _signature = this.signature.toBER(false);
    stream2.appendUint16(_signature.byteLength);
    stream2.appendView(new Uint8Array(_signature));
    return stream2;
  }
  toJSON() {
    return {
      version: this.version,
      logID: bufferToHexCodes(this.logID),
      timestamp: this.timestamp,
      extensions: bufferToHexCodes(this.extensions),
      hashAlgorithm: this.hashAlgorithm,
      signatureAlgorithm: this.signatureAlgorithm,
      signature: this.signature.toJSON()
    };
  }
  async verify(logs, data, dataType = 0, crypto9 = getCrypto2(true)) {
    const logId = toBase64(arrayBufferToString(this.logID));
    let publicKeyBase64 = null;
    const stream2 = new SeqStream();
    for (const log of logs) {
      if (log.log_id === logId) {
        publicKeyBase64 = log.key;
        break;
      }
    }
    if (!publicKeyBase64) {
      throw new Error(`Public key not found for CT with logId: ${logId}`);
    }
    const pki2 = stringToArrayBuffer(fromBase64(publicKeyBase64));
    const publicKeyInfo = PublicKeyInfo.fromBER(pki2);
    stream2.appendChar(0);
    stream2.appendChar(0);
    const timeBuffer = new ArrayBuffer(8);
    const timeView = new Uint8Array(timeBuffer);
    const baseArray = utilToBase(this.timestamp.valueOf(), 8);
    timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
    stream2.appendView(timeView);
    stream2.appendUint16(dataType);
    if (dataType === 0)
      stream2.appendUint24(data.byteLength);
    stream2.appendView(new Uint8Array(data));
    stream2.appendUint16(this.extensions.byteLength);
    if (this.extensions.byteLength !== 0)
      stream2.appendView(new Uint8Array(this.extensions));
    return crypto9.verifyWithPublicKey(stream2.buffer.slice(0, stream2.length), new asn1js.OctetString({ valueHex: this.signature.toBER(false) }), publicKeyInfo, { algorithmId: EMPTY_STRING }, "SHA-256");
  }
};
SignedCertificateTimestamp.CLASS_NAME = "SignedCertificateTimestamp";
var TIMESTAMPS = "timestamps";
var SignedCertificateTimestampList = class _SignedCertificateTimestampList extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.timestamps = getParametersValue(parameters, TIMESTAMPS, _SignedCertificateTimestampList.defaultValues(TIMESTAMPS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TIMESTAMPS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TIMESTAMPS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    var _a3;
    const names = getParametersValue(parameters, "names", {});
    (_a3 = names.optional) !== null && _a3 !== void 0 ? _a3 : names.optional = false;
    return new asn1js.OctetString({
      name: names.blockName || "SignedCertificateTimestampList",
      optional: names.optional
    });
  }
  fromSchema(schema) {
    if (schema instanceof asn1js.OctetString === false) {
      throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
    }
    const seqStream = new SeqStream({
      stream: new ByteStream({
        buffer: schema.valueBlock.valueHex
      })
    });
    const dataLength = seqStream.getUint16();
    if (dataLength !== seqStream.length) {
      throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
    }
    while (seqStream.length) {
      this.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));
    }
  }
  toSchema() {
    const stream2 = new SeqStream();
    let overallLength = 0;
    const timestampsData = [];
    for (const timestamp of this.timestamps) {
      const timestampStream = timestamp.toStream();
      timestampsData.push(timestampStream);
      overallLength += timestampStream.stream.buffer.byteLength;
    }
    stream2.appendUint16(overallLength);
    for (const timestamp of timestampsData) {
      stream2.appendView(timestamp.stream.view);
    }
    return new asn1js.OctetString({ valueHex: stream2.stream.buffer.slice(0) });
  }
  toJSON() {
    return {
      timestamps: Array.from(this.timestamps, (o) => o.toJSON())
    };
  }
};
SignedCertificateTimestampList.CLASS_NAME = "SignedCertificateTimestampList";
var ATTRIBUTES$4 = "attributes";
var CLEAR_PROPS$11 = [
  ATTRIBUTES$4
];
var SubjectDirectoryAttributes = class _SubjectDirectoryAttributes extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.attributes = getParametersValue(parameters, ATTRIBUTES$4, _SubjectDirectoryAttributes.defaultValues(ATTRIBUTES$4));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ATTRIBUTES$4:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.attributes || EMPTY_STRING,
          value: Attribute.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$11);
    const asn1 = asn1js.compareSchema(schema, schema, _SubjectDirectoryAttributes.schema({
      names: {
        attributes: ATTRIBUTES$4
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.attributes = Array.from(asn1.result.attributes, (element) => new Attribute({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.attributes, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      attributes: Array.from(this.attributes, (o) => o.toJSON())
    };
  }
};
SubjectDirectoryAttributes.CLASS_NAME = "SubjectDirectoryAttributes";
var ExtensionValueFactory = class _ExtensionValueFactory {
  static getItems() {
    if (!this.types) {
      this.types = {};
      _ExtensionValueFactory.register(id_SubjectAltName, "SubjectAltName", AltName);
      _ExtensionValueFactory.register(id_IssuerAltName, "IssuerAltName", AltName);
      _ExtensionValueFactory.register(id_AuthorityKeyIdentifier, "AuthorityKeyIdentifier", AuthorityKeyIdentifier);
      _ExtensionValueFactory.register(id_BasicConstraints, "BasicConstraints", BasicConstraints);
      _ExtensionValueFactory.register(id_MicrosoftCaVersion, "MicrosoftCaVersion", CAVersion);
      _ExtensionValueFactory.register(id_CertificatePolicies, "CertificatePolicies", CertificatePolicies);
      _ExtensionValueFactory.register(id_MicrosoftAppPolicies, "CertificatePoliciesMicrosoft", CertificatePolicies);
      _ExtensionValueFactory.register(id_MicrosoftCertTemplateV2, "MicrosoftCertTemplateV2", CertificateTemplate);
      _ExtensionValueFactory.register(id_CRLDistributionPoints, "CRLDistributionPoints", CRLDistributionPoints);
      _ExtensionValueFactory.register(id_FreshestCRL, "FreshestCRL", CRLDistributionPoints);
      _ExtensionValueFactory.register(id_ExtKeyUsage, "ExtKeyUsage", ExtKeyUsage);
      _ExtensionValueFactory.register(id_CertificateIssuer, "CertificateIssuer", GeneralNames);
      _ExtensionValueFactory.register(id_AuthorityInfoAccess, "AuthorityInfoAccess", InfoAccess);
      _ExtensionValueFactory.register(id_SubjectInfoAccess, "SubjectInfoAccess", InfoAccess);
      _ExtensionValueFactory.register(id_IssuingDistributionPoint, "IssuingDistributionPoint", IssuingDistributionPoint);
      _ExtensionValueFactory.register(id_NameConstraints, "NameConstraints", NameConstraints);
      _ExtensionValueFactory.register(id_PolicyConstraints, "PolicyConstraints", PolicyConstraints);
      _ExtensionValueFactory.register(id_PolicyMappings, "PolicyMappings", PolicyMappings);
      _ExtensionValueFactory.register(id_PrivateKeyUsagePeriod, "PrivateKeyUsagePeriod", PrivateKeyUsagePeriod);
      _ExtensionValueFactory.register(id_QCStatements, "QCStatements", QCStatements);
      _ExtensionValueFactory.register(id_SignedCertificateTimestampList, "SignedCertificateTimestampList", SignedCertificateTimestampList);
      _ExtensionValueFactory.register(id_SubjectDirectoryAttributes, "SubjectDirectoryAttributes", SubjectDirectoryAttributes);
    }
    return this.types;
  }
  static fromBER(id, raw) {
    const asn1 = asn1js.fromBER(raw);
    if (asn1.offset === -1) {
      return null;
    }
    const item = this.find(id);
    if (item) {
      try {
        return new item.type({ schema: asn1.result });
      } catch (ex) {
        const res = new item.type();
        res.parsingError = `Incorrectly formatted value of extension ${item.name} (${id})`;
        return res;
      }
    }
    return asn1.result;
  }
  static find(id) {
    const types = this.getItems();
    return types[id] || null;
  }
  static register(id, name4, type) {
    this.getItems()[id] = { name: name4, type };
  }
};
var EXTN_ID = "extnID";
var CRITICAL = "critical";
var EXTN_VALUE = "extnValue";
var PARSED_VALUE$5 = "parsedValue";
var CLEAR_PROPS$10 = [
  EXTN_ID,
  CRITICAL,
  EXTN_VALUE
];
var Extension = class _Extension extends PkiObject {
  get parsedValue() {
    if (this._parsedValue === void 0) {
      const parsedValue = ExtensionValueFactory.fromBER(this.extnID, this.extnValue.valueBlock.valueHexView);
      this._parsedValue = parsedValue;
    }
    return this._parsedValue || void 0;
  }
  set parsedValue(value) {
    this._parsedValue = value;
  }
  constructor(parameters = {}) {
    super();
    this.extnID = getParametersValue(parameters, EXTN_ID, _Extension.defaultValues(EXTN_ID));
    this.critical = getParametersValue(parameters, CRITICAL, _Extension.defaultValues(CRITICAL));
    if (EXTN_VALUE in parameters) {
      this.extnValue = new asn1js.OctetString({ valueHex: parameters.extnValue });
    } else {
      this.extnValue = _Extension.defaultValues(EXTN_VALUE);
    }
    if (PARSED_VALUE$5 in parameters) {
      this.parsedValue = getParametersValue(parameters, PARSED_VALUE$5, _Extension.defaultValues(PARSED_VALUE$5));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case EXTN_ID:
        return EMPTY_STRING;
      case CRITICAL:
        return false;
      case EXTN_VALUE:
        return new asn1js.OctetString();
      case PARSED_VALUE$5:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.extnID || EMPTY_STRING }),
        new asn1js.Boolean({
          name: names.critical || EMPTY_STRING,
          optional: true
        }),
        new asn1js.OctetString({ name: names.extnValue || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$10);
    const asn1 = asn1js.compareSchema(schema, schema, _Extension.schema({
      names: {
        extnID: EXTN_ID,
        critical: CRITICAL,
        extnValue: EXTN_VALUE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.extnID = asn1.result.extnID.valueBlock.toString();
    if (CRITICAL in asn1.result) {
      this.critical = asn1.result.critical.valueBlock.value;
    }
    this.extnValue = asn1.result.extnValue;
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.extnID }));
    if (this.critical !== _Extension.defaultValues(CRITICAL)) {
      outputArray.push(new asn1js.Boolean({ value: this.critical }));
    }
    outputArray.push(this.extnValue);
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const object2 = {
      extnID: this.extnID,
      extnValue: this.extnValue.toJSON()
    };
    if (this.critical !== _Extension.defaultValues(CRITICAL)) {
      object2.critical = this.critical;
    }
    if (this.parsedValue && this.parsedValue.toJSON) {
      object2.parsedValue = this.parsedValue.toJSON();
    }
    return object2;
  }
};
Extension.CLASS_NAME = "Extension";
var EXTENSIONS$5 = "extensions";
var CLEAR_PROPS$$ = [
  EXTENSIONS$5
];
var Extensions = class _Extensions extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.extensions = getParametersValue(parameters, EXTENSIONS$5, _Extensions.defaultValues(EXTENSIONS$5));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case EXTENSIONS$5:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}, optional = false) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      optional,
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.extensions || EMPTY_STRING,
          value: Extension.schema(names.extension || {})
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$$);
    const asn1 = asn1js.compareSchema(schema, schema, _Extensions.schema({
      names: {
        extensions: EXTENSIONS$5
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.extensions = Array.from(asn1.result.extensions, (element) => new Extension({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.extensions, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      extensions: this.extensions.map((o) => o.toJSON())
    };
  }
};
Extensions.CLASS_NAME = "Extensions";
var ISSUER$5 = "issuer";
var SERIAL_NUMBER$6 = "serialNumber";
var ISSUER_UID = "issuerUID";
var CLEAR_PROPS$_ = [
  ISSUER$5,
  SERIAL_NUMBER$6,
  ISSUER_UID
];
var IssuerSerial = class _IssuerSerial extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.issuer = getParametersValue(parameters, ISSUER$5, _IssuerSerial.defaultValues(ISSUER$5));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$6, _IssuerSerial.defaultValues(SERIAL_NUMBER$6));
    if (ISSUER_UID in parameters) {
      this.issuerUID = getParametersValue(parameters, ISSUER_UID, _IssuerSerial.defaultValues(ISSUER_UID));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ISSUER$5:
        return new GeneralNames();
      case SERIAL_NUMBER$6:
        return new asn1js.Integer();
      case ISSUER_UID:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        GeneralNames.schema(names.issuer || {}),
        new asn1js.Integer({ name: names.serialNumber || EMPTY_STRING }),
        new asn1js.BitString({
          optional: true,
          name: names.issuerUID || EMPTY_STRING
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$_);
    const asn1 = asn1js.compareSchema(schema, schema, _IssuerSerial.schema({
      names: {
        issuer: {
          names: {
            blockName: ISSUER$5
          }
        },
        serialNumber: SERIAL_NUMBER$6,
        issuerUID: ISSUER_UID
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.issuer = new GeneralNames({ schema: asn1.result.issuer });
    this.serialNumber = asn1.result.serialNumber;
    if (ISSUER_UID in asn1.result)
      this.issuerUID = asn1.result.issuerUID;
  }
  toSchema() {
    const result = new asn1js.Sequence({
      value: [
        this.issuer.toSchema(),
        this.serialNumber
      ]
    });
    if (this.issuerUID) {
      result.valueBlock.value.push(this.issuerUID);
    }
    return result;
  }
  toJSON() {
    const result = {
      issuer: this.issuer.toJSON(),
      serialNumber: this.serialNumber.toJSON()
    };
    if (this.issuerUID) {
      result.issuerUID = this.issuerUID.toJSON();
    }
    return result;
  }
};
IssuerSerial.CLASS_NAME = "IssuerSerial";
var VERSION$h = "version";
var BASE_CERTIFICATE_ID$2 = "baseCertificateID";
var SUBJECT_NAME = "subjectName";
var ISSUER$4 = "issuer";
var SIGNATURE$6 = "signature";
var SERIAL_NUMBER$5 = "serialNumber";
var ATTR_CERT_VALIDITY_PERIOD$1 = "attrCertValidityPeriod";
var ATTRIBUTES$3 = "attributes";
var ISSUER_UNIQUE_ID$2 = "issuerUniqueID";
var EXTENSIONS$4 = "extensions";
var CLEAR_PROPS$Z = [
  VERSION$h,
  BASE_CERTIFICATE_ID$2,
  SUBJECT_NAME,
  ISSUER$4,
  SIGNATURE$6,
  SERIAL_NUMBER$5,
  ATTR_CERT_VALIDITY_PERIOD$1,
  ATTRIBUTES$3,
  ISSUER_UNIQUE_ID$2,
  EXTENSIONS$4
];
var AttributeCertificateInfoV1 = class _AttributeCertificateInfoV1 extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$h, _AttributeCertificateInfoV1.defaultValues(VERSION$h));
    if (BASE_CERTIFICATE_ID$2 in parameters) {
      this.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID$2, _AttributeCertificateInfoV1.defaultValues(BASE_CERTIFICATE_ID$2));
    }
    if (SUBJECT_NAME in parameters) {
      this.subjectName = getParametersValue(parameters, SUBJECT_NAME, _AttributeCertificateInfoV1.defaultValues(SUBJECT_NAME));
    }
    this.issuer = getParametersValue(parameters, ISSUER$4, _AttributeCertificateInfoV1.defaultValues(ISSUER$4));
    this.signature = getParametersValue(parameters, SIGNATURE$6, _AttributeCertificateInfoV1.defaultValues(SIGNATURE$6));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$5, _AttributeCertificateInfoV1.defaultValues(SERIAL_NUMBER$5));
    this.attrCertValidityPeriod = getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD$1, _AttributeCertificateInfoV1.defaultValues(ATTR_CERT_VALIDITY_PERIOD$1));
    this.attributes = getParametersValue(parameters, ATTRIBUTES$3, _AttributeCertificateInfoV1.defaultValues(ATTRIBUTES$3));
    if (ISSUER_UNIQUE_ID$2 in parameters)
      this.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID$2, _AttributeCertificateInfoV1.defaultValues(ISSUER_UNIQUE_ID$2));
    if (EXTENSIONS$4 in parameters) {
      this.extensions = getParametersValue(parameters, EXTENSIONS$4, _AttributeCertificateInfoV1.defaultValues(EXTENSIONS$4));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$h:
        return 0;
      case BASE_CERTIFICATE_ID$2:
        return new IssuerSerial();
      case SUBJECT_NAME:
        return new GeneralNames();
      case ISSUER$4:
        return new GeneralNames();
      case SIGNATURE$6:
        return new AlgorithmIdentifier();
      case SERIAL_NUMBER$5:
        return new asn1js.Integer();
      case ATTR_CERT_VALIDITY_PERIOD$1:
        return new AttCertValidityPeriod();
      case ATTRIBUTES$3:
        return [];
      case ISSUER_UNIQUE_ID$2:
        return new asn1js.BitString();
      case EXTENSIONS$4:
        return new Extensions();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        new asn1js.Choice({
          value: [
            new asn1js.Constructed({
              name: names.baseCertificateID || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: IssuerSerial.schema().valueBlock.value
            }),
            new asn1js.Constructed({
              name: names.subjectName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: GeneralNames.schema().valueBlock.value
            })
          ]
        }),
        GeneralNames.schema({
          names: {
            blockName: names.issuer || EMPTY_STRING
          }
        }),
        AlgorithmIdentifier.schema(names.signature || {}),
        new asn1js.Integer({ name: names.serialNumber || EMPTY_STRING }),
        AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
        new asn1js.Sequence({
          name: names.attributes || EMPTY_STRING,
          value: [
            new asn1js.Repeated({
              value: Attribute.schema()
            })
          ]
        }),
        new asn1js.BitString({
          optional: true,
          name: names.issuerUniqueID || EMPTY_STRING
        }),
        Extensions.schema(names.extensions || {}, true)
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$Z);
    const asn1 = asn1js.compareSchema(schema, schema, _AttributeCertificateInfoV1.schema({
      names: {
        version: VERSION$h,
        baseCertificateID: BASE_CERTIFICATE_ID$2,
        subjectName: SUBJECT_NAME,
        issuer: ISSUER$4,
        signature: {
          names: {
            blockName: SIGNATURE$6
          }
        },
        serialNumber: SERIAL_NUMBER$5,
        attrCertValidityPeriod: {
          names: {
            blockName: ATTR_CERT_VALIDITY_PERIOD$1
          }
        },
        attributes: ATTRIBUTES$3,
        issuerUniqueID: ISSUER_UNIQUE_ID$2,
        extensions: {
          names: {
            blockName: EXTENSIONS$4
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    if (BASE_CERTIFICATE_ID$2 in asn1.result) {
      this.baseCertificateID = new IssuerSerial({
        schema: new asn1js.Sequence({
          value: asn1.result.baseCertificateID.valueBlock.value
        })
      });
    }
    if (SUBJECT_NAME in asn1.result) {
      this.subjectName = new GeneralNames({
        schema: new asn1js.Sequence({
          value: asn1.result.subjectName.valueBlock.value
        })
      });
    }
    this.issuer = asn1.result.issuer;
    this.signature = new AlgorithmIdentifier({ schema: asn1.result.signature });
    this.serialNumber = asn1.result.serialNumber;
    this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
    this.attributes = Array.from(asn1.result.attributes.valueBlock.value, (element) => new Attribute({ schema: element }));
    if (ISSUER_UNIQUE_ID$2 in asn1.result) {
      this.issuerUniqueID = asn1.result.issuerUniqueID;
    }
    if (EXTENSIONS$4 in asn1.result) {
      this.extensions = new Extensions({ schema: asn1.result.extensions });
    }
  }
  toSchema() {
    const result = new asn1js.Sequence({
      value: [new asn1js.Integer({ value: this.version })]
    });
    if (this.baseCertificateID) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: this.baseCertificateID.toSchema().valueBlock.value
      }));
    }
    if (this.subjectName) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: this.subjectName.toSchema().valueBlock.value
      }));
    }
    result.valueBlock.value.push(this.issuer.toSchema());
    result.valueBlock.value.push(this.signature.toSchema());
    result.valueBlock.value.push(this.serialNumber);
    result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
    result.valueBlock.value.push(new asn1js.Sequence({
      value: Array.from(this.attributes, (o) => o.toSchema())
    }));
    if (this.issuerUniqueID) {
      result.valueBlock.value.push(this.issuerUniqueID);
    }
    if (this.extensions) {
      result.valueBlock.value.push(this.extensions.toSchema());
    }
    return result;
  }
  toJSON() {
    const result = {
      version: this.version
    };
    if (this.baseCertificateID) {
      result.baseCertificateID = this.baseCertificateID.toJSON();
    }
    if (this.subjectName) {
      result.subjectName = this.subjectName.toJSON();
    }
    result.issuer = this.issuer.toJSON();
    result.signature = this.signature.toJSON();
    result.serialNumber = this.serialNumber.toJSON();
    result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
    result.attributes = Array.from(this.attributes, (o) => o.toJSON());
    if (this.issuerUniqueID) {
      result.issuerUniqueID = this.issuerUniqueID.toJSON();
    }
    if (this.extensions) {
      result.extensions = this.extensions.toJSON();
    }
    return result;
  }
};
AttributeCertificateInfoV1.CLASS_NAME = "AttributeCertificateInfoV1";
var ACINFO$1 = "acinfo";
var SIGNATURE_ALGORITHM$7 = "signatureAlgorithm";
var SIGNATURE_VALUE$4 = "signatureValue";
var CLEAR_PROPS$Y = [
  ACINFO$1,
  SIGNATURE_VALUE$4,
  SIGNATURE_ALGORITHM$7
];
var AttributeCertificateV1 = class _AttributeCertificateV1 extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.acinfo = getParametersValue(parameters, ACINFO$1, _AttributeCertificateV1.defaultValues(ACINFO$1));
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$7, _AttributeCertificateV1.defaultValues(SIGNATURE_ALGORITHM$7));
    this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$4, _AttributeCertificateV1.defaultValues(SIGNATURE_VALUE$4));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ACINFO$1:
        return new AttributeCertificateInfoV1();
      case SIGNATURE_ALGORITHM$7:
        return new AlgorithmIdentifier();
      case SIGNATURE_VALUE$4:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AttributeCertificateInfoV1.schema(names.acinfo || {}),
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
        new asn1js.BitString({ name: names.signatureValue || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$Y);
    const asn1 = asn1js.compareSchema(schema, schema, _AttributeCertificateV1.schema({
      names: {
        acinfo: {
          names: {
            blockName: ACINFO$1
          }
        },
        signatureAlgorithm: {
          names: {
            blockName: SIGNATURE_ALGORITHM$7
          }
        },
        signatureValue: SIGNATURE_VALUE$4
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.acinfo = new AttributeCertificateInfoV1({ schema: asn1.result.acinfo });
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
    this.signatureValue = asn1.result.signatureValue;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.acinfo.toSchema(),
        this.signatureAlgorithm.toSchema(),
        this.signatureValue
      ]
    });
  }
  toJSON() {
    return {
      acinfo: this.acinfo.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signatureValue: this.signatureValue.toJSON()
    };
  }
};
AttributeCertificateV1.CLASS_NAME = "AttributeCertificateV1";
var DIGESTED_OBJECT_TYPE = "digestedObjectType";
var OTHER_OBJECT_TYPE_ID = "otherObjectTypeID";
var DIGEST_ALGORITHM$2 = "digestAlgorithm";
var OBJECT_DIGEST = "objectDigest";
var CLEAR_PROPS$X = [
  DIGESTED_OBJECT_TYPE,
  OTHER_OBJECT_TYPE_ID,
  DIGEST_ALGORITHM$2,
  OBJECT_DIGEST
];
var ObjectDigestInfo = class _ObjectDigestInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.digestedObjectType = getParametersValue(parameters, DIGESTED_OBJECT_TYPE, _ObjectDigestInfo.defaultValues(DIGESTED_OBJECT_TYPE));
    if (OTHER_OBJECT_TYPE_ID in parameters) {
      this.otherObjectTypeID = getParametersValue(parameters, OTHER_OBJECT_TYPE_ID, _ObjectDigestInfo.defaultValues(OTHER_OBJECT_TYPE_ID));
    }
    this.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM$2, _ObjectDigestInfo.defaultValues(DIGEST_ALGORITHM$2));
    this.objectDigest = getParametersValue(parameters, OBJECT_DIGEST, _ObjectDigestInfo.defaultValues(OBJECT_DIGEST));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case DIGESTED_OBJECT_TYPE:
        return new asn1js.Enumerated();
      case OTHER_OBJECT_TYPE_ID:
        return new asn1js.ObjectIdentifier();
      case DIGEST_ALGORITHM$2:
        return new AlgorithmIdentifier();
      case OBJECT_DIGEST:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Enumerated({ name: names.digestedObjectType || EMPTY_STRING }),
        new asn1js.ObjectIdentifier({
          optional: true,
          name: names.otherObjectTypeID || EMPTY_STRING
        }),
        AlgorithmIdentifier.schema(names.digestAlgorithm || {}),
        new asn1js.BitString({ name: names.objectDigest || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$X);
    const asn1 = asn1js.compareSchema(schema, schema, _ObjectDigestInfo.schema({
      names: {
        digestedObjectType: DIGESTED_OBJECT_TYPE,
        otherObjectTypeID: OTHER_OBJECT_TYPE_ID,
        digestAlgorithm: {
          names: {
            blockName: DIGEST_ALGORITHM$2
          }
        },
        objectDigest: OBJECT_DIGEST
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.digestedObjectType = asn1.result.digestedObjectType;
    if (OTHER_OBJECT_TYPE_ID in asn1.result) {
      this.otherObjectTypeID = asn1.result.otherObjectTypeID;
    }
    this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.digestAlgorithm });
    this.objectDigest = asn1.result.objectDigest;
  }
  toSchema() {
    const result = new asn1js.Sequence({
      value: [this.digestedObjectType]
    });
    if (this.otherObjectTypeID) {
      result.valueBlock.value.push(this.otherObjectTypeID);
    }
    result.valueBlock.value.push(this.digestAlgorithm.toSchema());
    result.valueBlock.value.push(this.objectDigest);
    return result;
  }
  toJSON() {
    const result = {
      digestedObjectType: this.digestedObjectType.toJSON(),
      digestAlgorithm: this.digestAlgorithm.toJSON(),
      objectDigest: this.objectDigest.toJSON()
    };
    if (this.otherObjectTypeID) {
      result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
    }
    return result;
  }
};
ObjectDigestInfo.CLASS_NAME = "ObjectDigestInfo";
var ISSUER_NAME = "issuerName";
var BASE_CERTIFICATE_ID$1 = "baseCertificateID";
var OBJECT_DIGEST_INFO$1 = "objectDigestInfo";
var CLEAR_PROPS$W = [
  ISSUER_NAME,
  BASE_CERTIFICATE_ID$1,
  OBJECT_DIGEST_INFO$1
];
var V2Form = class _V2Form extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (ISSUER_NAME in parameters) {
      this.issuerName = getParametersValue(parameters, ISSUER_NAME, _V2Form.defaultValues(ISSUER_NAME));
    }
    if (BASE_CERTIFICATE_ID$1 in parameters) {
      this.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID$1, _V2Form.defaultValues(BASE_CERTIFICATE_ID$1));
    }
    if (OBJECT_DIGEST_INFO$1 in parameters) {
      this.objectDigestInfo = getParametersValue(parameters, OBJECT_DIGEST_INFO$1, _V2Form.defaultValues(OBJECT_DIGEST_INFO$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ISSUER_NAME:
        return new GeneralNames();
      case BASE_CERTIFICATE_ID$1:
        return new IssuerSerial();
      case OBJECT_DIGEST_INFO$1:
        return new ObjectDigestInfo();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        GeneralNames.schema({
          names: {
            blockName: names.issuerName
          }
        }, true),
        new asn1js.Constructed({
          optional: true,
          name: names.baseCertificateID || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: IssuerSerial.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          optional: true,
          name: names.objectDigestInfo || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: ObjectDigestInfo.schema().valueBlock.value
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$W);
    const asn1 = asn1js.compareSchema(schema, schema, _V2Form.schema({
      names: {
        issuerName: ISSUER_NAME,
        baseCertificateID: BASE_CERTIFICATE_ID$1,
        objectDigestInfo: OBJECT_DIGEST_INFO$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (ISSUER_NAME in asn1.result)
      this.issuerName = new GeneralNames({ schema: asn1.result.issuerName });
    if (BASE_CERTIFICATE_ID$1 in asn1.result) {
      this.baseCertificateID = new IssuerSerial({
        schema: new asn1js.Sequence({
          value: asn1.result.baseCertificateID.valueBlock.value
        })
      });
    }
    if (OBJECT_DIGEST_INFO$1 in asn1.result) {
      this.objectDigestInfo = new ObjectDigestInfo({
        schema: new asn1js.Sequence({
          value: asn1.result.objectDigestInfo.valueBlock.value
        })
      });
    }
  }
  toSchema() {
    const result = new asn1js.Sequence();
    if (this.issuerName)
      result.valueBlock.value.push(this.issuerName.toSchema());
    if (this.baseCertificateID) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: this.baseCertificateID.toSchema().valueBlock.value
      }));
    }
    if (this.objectDigestInfo) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: this.objectDigestInfo.toSchema().valueBlock.value
      }));
    }
    return result;
  }
  toJSON() {
    const result = {};
    if (this.issuerName) {
      result.issuerName = this.issuerName.toJSON();
    }
    if (this.baseCertificateID) {
      result.baseCertificateID = this.baseCertificateID.toJSON();
    }
    if (this.objectDigestInfo) {
      result.objectDigestInfo = this.objectDigestInfo.toJSON();
    }
    return result;
  }
};
V2Form.CLASS_NAME = "V2Form";
var BASE_CERTIFICATE_ID = "baseCertificateID";
var ENTITY_NAME = "entityName";
var OBJECT_DIGEST_INFO = "objectDigestInfo";
var CLEAR_PROPS$V = [
  BASE_CERTIFICATE_ID,
  ENTITY_NAME,
  OBJECT_DIGEST_INFO
];
var Holder = class _Holder extends PkiObject {
  constructor(parameters = {}) {
    super();
    if (BASE_CERTIFICATE_ID in parameters) {
      this.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID, _Holder.defaultValues(BASE_CERTIFICATE_ID));
    }
    if (ENTITY_NAME in parameters) {
      this.entityName = getParametersValue(parameters, ENTITY_NAME, _Holder.defaultValues(ENTITY_NAME));
    }
    if (OBJECT_DIGEST_INFO in parameters) {
      this.objectDigestInfo = getParametersValue(parameters, OBJECT_DIGEST_INFO, _Holder.defaultValues(OBJECT_DIGEST_INFO));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case BASE_CERTIFICATE_ID:
        return new IssuerSerial();
      case ENTITY_NAME:
        return new GeneralNames();
      case OBJECT_DIGEST_INFO:
        return new ObjectDigestInfo();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          optional: true,
          name: names.baseCertificateID || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: IssuerSerial.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          optional: true,
          name: names.entityName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: GeneralNames.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          optional: true,
          name: names.objectDigestInfo || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: ObjectDigestInfo.schema().valueBlock.value
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$V);
    const asn1 = asn1js.compareSchema(schema, schema, _Holder.schema({
      names: {
        baseCertificateID: BASE_CERTIFICATE_ID,
        entityName: ENTITY_NAME,
        objectDigestInfo: OBJECT_DIGEST_INFO
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (BASE_CERTIFICATE_ID in asn1.result) {
      this.baseCertificateID = new IssuerSerial({
        schema: new asn1js.Sequence({
          value: asn1.result.baseCertificateID.valueBlock.value
        })
      });
    }
    if (ENTITY_NAME in asn1.result) {
      this.entityName = new GeneralNames({
        schema: new asn1js.Sequence({
          value: asn1.result.entityName.valueBlock.value
        })
      });
    }
    if (OBJECT_DIGEST_INFO in asn1.result) {
      this.objectDigestInfo = new ObjectDigestInfo({
        schema: new asn1js.Sequence({
          value: asn1.result.objectDigestInfo.valueBlock.value
        })
      });
    }
  }
  toSchema() {
    const result = new asn1js.Sequence();
    if (this.baseCertificateID) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: this.baseCertificateID.toSchema().valueBlock.value
      }));
    }
    if (this.entityName) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: this.entityName.toSchema().valueBlock.value
      }));
    }
    if (this.objectDigestInfo) {
      result.valueBlock.value.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        value: this.objectDigestInfo.toSchema().valueBlock.value
      }));
    }
    return result;
  }
  toJSON() {
    const result = {};
    if (this.baseCertificateID) {
      result.baseCertificateID = this.baseCertificateID.toJSON();
    }
    if (this.entityName) {
      result.entityName = this.entityName.toJSON();
    }
    if (this.objectDigestInfo) {
      result.objectDigestInfo = this.objectDigestInfo.toJSON();
    }
    return result;
  }
};
Holder.CLASS_NAME = "Holder";
var VERSION$g = "version";
var HOLDER = "holder";
var ISSUER$3 = "issuer";
var SIGNATURE$5 = "signature";
var SERIAL_NUMBER$4 = "serialNumber";
var ATTR_CERT_VALIDITY_PERIOD = "attrCertValidityPeriod";
var ATTRIBUTES$2 = "attributes";
var ISSUER_UNIQUE_ID$1 = "issuerUniqueID";
var EXTENSIONS$3 = "extensions";
var CLEAR_PROPS$U = [
  VERSION$g,
  HOLDER,
  ISSUER$3,
  SIGNATURE$5,
  SERIAL_NUMBER$4,
  ATTR_CERT_VALIDITY_PERIOD,
  ATTRIBUTES$2,
  ISSUER_UNIQUE_ID$1,
  EXTENSIONS$3
];
var AttributeCertificateInfoV2 = class _AttributeCertificateInfoV2 extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$g, _AttributeCertificateInfoV2.defaultValues(VERSION$g));
    this.holder = getParametersValue(parameters, HOLDER, _AttributeCertificateInfoV2.defaultValues(HOLDER));
    this.issuer = getParametersValue(parameters, ISSUER$3, _AttributeCertificateInfoV2.defaultValues(ISSUER$3));
    this.signature = getParametersValue(parameters, SIGNATURE$5, _AttributeCertificateInfoV2.defaultValues(SIGNATURE$5));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$4, _AttributeCertificateInfoV2.defaultValues(SERIAL_NUMBER$4));
    this.attrCertValidityPeriod = getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD, _AttributeCertificateInfoV2.defaultValues(ATTR_CERT_VALIDITY_PERIOD));
    this.attributes = getParametersValue(parameters, ATTRIBUTES$2, _AttributeCertificateInfoV2.defaultValues(ATTRIBUTES$2));
    if (ISSUER_UNIQUE_ID$1 in parameters) {
      this.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID$1, _AttributeCertificateInfoV2.defaultValues(ISSUER_UNIQUE_ID$1));
    }
    if (EXTENSIONS$3 in parameters) {
      this.extensions = getParametersValue(parameters, EXTENSIONS$3, _AttributeCertificateInfoV2.defaultValues(EXTENSIONS$3));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$g:
        return 1;
      case HOLDER:
        return new Holder();
      case ISSUER$3:
        return {};
      case SIGNATURE$5:
        return new AlgorithmIdentifier();
      case SERIAL_NUMBER$4:
        return new asn1js.Integer();
      case ATTR_CERT_VALIDITY_PERIOD:
        return new AttCertValidityPeriod();
      case ATTRIBUTES$2:
        return [];
      case ISSUER_UNIQUE_ID$1:
        return new asn1js.BitString();
      case EXTENSIONS$3:
        return new Extensions();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        Holder.schema(names.holder || {}),
        new asn1js.Choice({
          value: [
            GeneralNames.schema({
              names: {
                blockName: names.issuer || EMPTY_STRING
              }
            }),
            new asn1js.Constructed({
              name: names.issuer || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: V2Form.schema().valueBlock.value
            })
          ]
        }),
        AlgorithmIdentifier.schema(names.signature || {}),
        new asn1js.Integer({ name: names.serialNumber || EMPTY_STRING }),
        AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
        new asn1js.Sequence({
          name: names.attributes || EMPTY_STRING,
          value: [
            new asn1js.Repeated({
              value: Attribute.schema()
            })
          ]
        }),
        new asn1js.BitString({
          optional: true,
          name: names.issuerUniqueID || EMPTY_STRING
        }),
        Extensions.schema(names.extensions || {}, true)
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$U);
    const asn1 = asn1js.compareSchema(schema, schema, _AttributeCertificateInfoV2.schema({
      names: {
        version: VERSION$g,
        holder: {
          names: {
            blockName: HOLDER
          }
        },
        issuer: ISSUER$3,
        signature: {
          names: {
            blockName: SIGNATURE$5
          }
        },
        serialNumber: SERIAL_NUMBER$4,
        attrCertValidityPeriod: {
          names: {
            blockName: ATTR_CERT_VALIDITY_PERIOD
          }
        },
        attributes: ATTRIBUTES$2,
        issuerUniqueID: ISSUER_UNIQUE_ID$1,
        extensions: {
          names: {
            blockName: EXTENSIONS$3
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.holder = new Holder({ schema: asn1.result.holder });
    switch (asn1.result.issuer.idBlock.tagClass) {
      case 3:
        this.issuer = new V2Form({
          schema: new asn1js.Sequence({
            value: asn1.result.issuer.valueBlock.value
          })
        });
        break;
      case 1:
      default:
        throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");
    }
    this.signature = new AlgorithmIdentifier({ schema: asn1.result.signature });
    this.serialNumber = asn1.result.serialNumber;
    this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
    this.attributes = Array.from(asn1.result.attributes.valueBlock.value, (element) => new Attribute({ schema: element }));
    if (ISSUER_UNIQUE_ID$1 in asn1.result) {
      this.issuerUniqueID = asn1.result.issuerUniqueID;
    }
    if (EXTENSIONS$3 in asn1.result) {
      this.extensions = new Extensions({ schema: asn1.result.extensions });
    }
  }
  toSchema() {
    const result = new asn1js.Sequence({
      value: [
        new asn1js.Integer({ value: this.version }),
        this.holder.toSchema(),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: this.issuer.toSchema().valueBlock.value
        }),
        this.signature.toSchema(),
        this.serialNumber,
        this.attrCertValidityPeriod.toSchema(),
        new asn1js.Sequence({
          value: Array.from(this.attributes, (o) => o.toSchema())
        })
      ]
    });
    if (this.issuerUniqueID) {
      result.valueBlock.value.push(this.issuerUniqueID);
    }
    if (this.extensions) {
      result.valueBlock.value.push(this.extensions.toSchema());
    }
    return result;
  }
  toJSON() {
    const result = {
      version: this.version,
      holder: this.holder.toJSON(),
      issuer: this.issuer.toJSON(),
      signature: this.signature.toJSON(),
      serialNumber: this.serialNumber.toJSON(),
      attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
      attributes: Array.from(this.attributes, (o) => o.toJSON())
    };
    if (this.issuerUniqueID) {
      result.issuerUniqueID = this.issuerUniqueID.toJSON();
    }
    if (this.extensions) {
      result.extensions = this.extensions.toJSON();
    }
    return result;
  }
};
AttributeCertificateInfoV2.CLASS_NAME = "AttributeCertificateInfoV2";
var ACINFO = "acinfo";
var SIGNATURE_ALGORITHM$6 = "signatureAlgorithm";
var SIGNATURE_VALUE$3 = "signatureValue";
var CLEAR_PROPS$T = [
  ACINFO,
  SIGNATURE_ALGORITHM$6,
  SIGNATURE_VALUE$3
];
var AttributeCertificateV2 = class _AttributeCertificateV2 extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.acinfo = getParametersValue(parameters, ACINFO, _AttributeCertificateV2.defaultValues(ACINFO));
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$6, _AttributeCertificateV2.defaultValues(SIGNATURE_ALGORITHM$6));
    this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$3, _AttributeCertificateV2.defaultValues(SIGNATURE_VALUE$3));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ACINFO:
        return new AttributeCertificateInfoV2();
      case SIGNATURE_ALGORITHM$6:
        return new AlgorithmIdentifier();
      case SIGNATURE_VALUE$3:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AttributeCertificateInfoV2.schema(names.acinfo || {}),
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
        new asn1js.BitString({ name: names.signatureValue || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$T);
    const asn1 = asn1js.compareSchema(schema, schema, _AttributeCertificateV2.schema({
      names: {
        acinfo: {
          names: {
            blockName: ACINFO
          }
        },
        signatureAlgorithm: {
          names: {
            blockName: SIGNATURE_ALGORITHM$6
          }
        },
        signatureValue: SIGNATURE_VALUE$3
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.acinfo = new AttributeCertificateInfoV2({ schema: asn1.result.acinfo });
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
    this.signatureValue = asn1.result.signatureValue;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.acinfo.toSchema(),
        this.signatureAlgorithm.toSchema(),
        this.signatureValue
      ]
    });
  }
  toJSON() {
    return {
      acinfo: this.acinfo.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signatureValue: this.signatureValue.toJSON()
    };
  }
};
AttributeCertificateV2.CLASS_NAME = "AttributeCertificateV2";
var CONTENT_TYPE = "contentType";
var CONTENT = "content";
var CLEAR_PROPS$S = [CONTENT_TYPE, CONTENT];
var ContentInfo = class _ContentInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.contentType = getParametersValue(parameters, CONTENT_TYPE, _ContentInfo.defaultValues(CONTENT_TYPE));
    this.content = getParametersValue(parameters, CONTENT, _ContentInfo.defaultValues(CONTENT));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CONTENT_TYPE:
        return EMPTY_STRING;
      case CONTENT:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case CONTENT_TYPE:
        return typeof memberValue === "string" && memberValue === this.defaultValues(CONTENT_TYPE);
      case CONTENT:
        return memberValue instanceof asn1js.Any;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    if ("optional" in names === false) {
      names.optional = false;
    }
    return new asn1js.Sequence({
      name: names.blockName || "ContentInfo",
      optional: names.optional,
      value: [
        new asn1js.ObjectIdentifier({ name: names.contentType || CONTENT_TYPE }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Any({ name: names.content || CONTENT })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$S);
    const asn1 = asn1js.compareSchema(schema, schema, _ContentInfo.schema());
    AsnError.assertSchema(asn1, this.className);
    this.contentType = asn1.result.contentType.valueBlock.toString();
    this.content = asn1.result.content;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.contentType }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.content]
        })
      ]
    });
  }
  toJSON() {
    const object2 = {
      contentType: this.contentType
    };
    if (!(this.content instanceof asn1js.Any)) {
      object2.content = this.content.toJSON();
    }
    return object2;
  }
};
ContentInfo.CLASS_NAME = "ContentInfo";
ContentInfo.DATA = id_ContentType_Data;
ContentInfo.SIGNED_DATA = id_ContentType_SignedData;
ContentInfo.ENVELOPED_DATA = id_ContentType_EnvelopedData;
ContentInfo.ENCRYPTED_DATA = id_ContentType_EncryptedData;
var TYPE$1 = "type";
var VALUE$4 = "value";
var UTC_TIME_NAME = "utcTimeName";
var GENERAL_TIME_NAME = "generalTimeName";
var CLEAR_PROPS$R = [UTC_TIME_NAME, GENERAL_TIME_NAME];
var TimeType;
(function(TimeType2) {
  TimeType2[TimeType2["UTCTime"] = 0] = "UTCTime";
  TimeType2[TimeType2["GeneralizedTime"] = 1] = "GeneralizedTime";
  TimeType2[TimeType2["empty"] = 2] = "empty";
})(TimeType || (TimeType = {}));
var Time = class _Time extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.type = getParametersValue(parameters, TYPE$1, _Time.defaultValues(TYPE$1));
    this.value = getParametersValue(parameters, VALUE$4, _Time.defaultValues(VALUE$4));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TYPE$1:
        return 0;
      case VALUE$4:
        return new Date(0, 0, 0);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}, optional = false) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Choice({
      optional,
      value: [
        new asn1js.UTCTime({ name: names.utcTimeName || EMPTY_STRING }),
        new asn1js.GeneralizedTime({ name: names.generalTimeName || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$R);
    const asn1 = asn1js.compareSchema(schema, schema, _Time.schema({
      names: {
        utcTimeName: UTC_TIME_NAME,
        generalTimeName: GENERAL_TIME_NAME
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (UTC_TIME_NAME in asn1.result) {
      this.type = 0;
      this.value = asn1.result.utcTimeName.toDate();
    }
    if (GENERAL_TIME_NAME in asn1.result) {
      this.type = 1;
      this.value = asn1.result.generalTimeName.toDate();
    }
  }
  toSchema() {
    if (this.type === 0) {
      return new asn1js.UTCTime({ valueDate: this.value });
    } else if (this.type === 1) {
      return new asn1js.GeneralizedTime({ valueDate: this.value });
    }
    return {};
  }
  toJSON() {
    return {
      type: this.type,
      value: this.value
    };
  }
};
Time.CLASS_NAME = "Time";
var TBS$4 = "tbs";
var VERSION$f = "version";
var SERIAL_NUMBER$3 = "serialNumber";
var SIGNATURE$4 = "signature";
var ISSUER$2 = "issuer";
var NOT_BEFORE = "notBefore";
var NOT_AFTER = "notAfter";
var SUBJECT$1 = "subject";
var SUBJECT_PUBLIC_KEY_INFO = "subjectPublicKeyInfo";
var ISSUER_UNIQUE_ID = "issuerUniqueID";
var SUBJECT_UNIQUE_ID = "subjectUniqueID";
var EXTENSIONS$2 = "extensions";
var SIGNATURE_ALGORITHM$5 = "signatureAlgorithm";
var SIGNATURE_VALUE$2 = "signatureValue";
var TBS_CERTIFICATE = "tbsCertificate";
var TBS_CERTIFICATE_VERSION = `${TBS_CERTIFICATE}.${VERSION$f}`;
var TBS_CERTIFICATE_SERIAL_NUMBER = `${TBS_CERTIFICATE}.${SERIAL_NUMBER$3}`;
var TBS_CERTIFICATE_SIGNATURE = `${TBS_CERTIFICATE}.${SIGNATURE$4}`;
var TBS_CERTIFICATE_ISSUER = `${TBS_CERTIFICATE}.${ISSUER$2}`;
var TBS_CERTIFICATE_NOT_BEFORE = `${TBS_CERTIFICATE}.${NOT_BEFORE}`;
var TBS_CERTIFICATE_NOT_AFTER = `${TBS_CERTIFICATE}.${NOT_AFTER}`;
var TBS_CERTIFICATE_SUBJECT = `${TBS_CERTIFICATE}.${SUBJECT$1}`;
var TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY = `${TBS_CERTIFICATE}.${SUBJECT_PUBLIC_KEY_INFO}`;
var TBS_CERTIFICATE_ISSUER_UNIQUE_ID = `${TBS_CERTIFICATE}.${ISSUER_UNIQUE_ID}`;
var TBS_CERTIFICATE_SUBJECT_UNIQUE_ID = `${TBS_CERTIFICATE}.${SUBJECT_UNIQUE_ID}`;
var TBS_CERTIFICATE_EXTENSIONS = `${TBS_CERTIFICATE}.${EXTENSIONS$2}`;
var CLEAR_PROPS$Q = [
  TBS_CERTIFICATE,
  TBS_CERTIFICATE_VERSION,
  TBS_CERTIFICATE_SERIAL_NUMBER,
  TBS_CERTIFICATE_SIGNATURE,
  TBS_CERTIFICATE_ISSUER,
  TBS_CERTIFICATE_NOT_BEFORE,
  TBS_CERTIFICATE_NOT_AFTER,
  TBS_CERTIFICATE_SUBJECT,
  TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY,
  TBS_CERTIFICATE_ISSUER_UNIQUE_ID,
  TBS_CERTIFICATE_SUBJECT_UNIQUE_ID,
  TBS_CERTIFICATE_EXTENSIONS,
  SIGNATURE_ALGORITHM$5,
  SIGNATURE_VALUE$2
];
function tbsCertificate(parameters = {}) {
  const names = getParametersValue(parameters, "names", {});
  return new asn1js.Sequence({
    name: names.blockName || TBS_CERTIFICATE,
    value: [
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.Integer({ name: names.tbsCertificateVersion || TBS_CERTIFICATE_VERSION })
        ]
      }),
      new asn1js.Integer({ name: names.tbsCertificateSerialNumber || TBS_CERTIFICATE_SERIAL_NUMBER }),
      AlgorithmIdentifier.schema(names.signature || {
        names: {
          blockName: TBS_CERTIFICATE_SIGNATURE
        }
      }),
      RelativeDistinguishedNames.schema(names.issuer || {
        names: {
          blockName: TBS_CERTIFICATE_ISSUER
        }
      }),
      new asn1js.Sequence({
        name: names.tbsCertificateValidity || "tbsCertificate.validity",
        value: [
          Time.schema(names.notBefore || {
            names: {
              utcTimeName: TBS_CERTIFICATE_NOT_BEFORE,
              generalTimeName: TBS_CERTIFICATE_NOT_BEFORE
            }
          }),
          Time.schema(names.notAfter || {
            names: {
              utcTimeName: TBS_CERTIFICATE_NOT_AFTER,
              generalTimeName: TBS_CERTIFICATE_NOT_AFTER
            }
          })
        ]
      }),
      RelativeDistinguishedNames.schema(names.subject || {
        names: {
          blockName: TBS_CERTIFICATE_SUBJECT
        }
      }),
      PublicKeyInfo.schema(names.subjectPublicKeyInfo || {
        names: {
          blockName: TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY
        }
      }),
      new asn1js.Primitive({
        name: names.tbsCertificateIssuerUniqueID || TBS_CERTIFICATE_ISSUER_UNIQUE_ID,
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        }
      }),
      new asn1js.Primitive({
        name: names.tbsCertificateSubjectUniqueID || TBS_CERTIFICATE_SUBJECT_UNIQUE_ID,
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        }
      }),
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        value: [Extensions.schema(names.extensions || {
          names: {
            blockName: TBS_CERTIFICATE_EXTENSIONS
          }
        })]
      })
    ]
  });
}
var Certificate = class _Certificate extends PkiObject {
  get tbs() {
    return BufferSourceConverter.toArrayBuffer(this.tbsView);
  }
  set tbs(value) {
    this.tbsView = new Uint8Array(value);
  }
  constructor(parameters = {}) {
    super();
    this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$4, _Certificate.defaultValues(TBS$4)));
    this.version = getParametersValue(parameters, VERSION$f, _Certificate.defaultValues(VERSION$f));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$3, _Certificate.defaultValues(SERIAL_NUMBER$3));
    this.signature = getParametersValue(parameters, SIGNATURE$4, _Certificate.defaultValues(SIGNATURE$4));
    this.issuer = getParametersValue(parameters, ISSUER$2, _Certificate.defaultValues(ISSUER$2));
    this.notBefore = getParametersValue(parameters, NOT_BEFORE, _Certificate.defaultValues(NOT_BEFORE));
    this.notAfter = getParametersValue(parameters, NOT_AFTER, _Certificate.defaultValues(NOT_AFTER));
    this.subject = getParametersValue(parameters, SUBJECT$1, _Certificate.defaultValues(SUBJECT$1));
    this.subjectPublicKeyInfo = getParametersValue(parameters, SUBJECT_PUBLIC_KEY_INFO, _Certificate.defaultValues(SUBJECT_PUBLIC_KEY_INFO));
    if (ISSUER_UNIQUE_ID in parameters) {
      this.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID, _Certificate.defaultValues(ISSUER_UNIQUE_ID));
    }
    if (SUBJECT_UNIQUE_ID in parameters) {
      this.subjectUniqueID = getParametersValue(parameters, SUBJECT_UNIQUE_ID, _Certificate.defaultValues(SUBJECT_UNIQUE_ID));
    }
    if (EXTENSIONS$2 in parameters) {
      this.extensions = getParametersValue(parameters, EXTENSIONS$2, _Certificate.defaultValues(EXTENSIONS$2));
    }
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$5, _Certificate.defaultValues(SIGNATURE_ALGORITHM$5));
    this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$2, _Certificate.defaultValues(SIGNATURE_VALUE$2));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TBS$4:
        return EMPTY_BUFFER;
      case VERSION$f:
        return 0;
      case SERIAL_NUMBER$3:
        return new asn1js.Integer();
      case SIGNATURE$4:
        return new AlgorithmIdentifier();
      case ISSUER$2:
        return new RelativeDistinguishedNames();
      case NOT_BEFORE:
        return new Time();
      case NOT_AFTER:
        return new Time();
      case SUBJECT$1:
        return new RelativeDistinguishedNames();
      case SUBJECT_PUBLIC_KEY_INFO:
        return new PublicKeyInfo();
      case ISSUER_UNIQUE_ID:
        return EMPTY_BUFFER;
      case SUBJECT_UNIQUE_ID:
        return EMPTY_BUFFER;
      case EXTENSIONS$2:
        return [];
      case SIGNATURE_ALGORITHM$5:
        return new AlgorithmIdentifier();
      case SIGNATURE_VALUE$2:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        tbsCertificate(names.tbsCertificate),
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: SIGNATURE_ALGORITHM$5
          }
        }),
        new asn1js.BitString({ name: names.signatureValue || SIGNATURE_VALUE$2 })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$Q);
    const asn1 = asn1js.compareSchema(schema, schema, _Certificate.schema({
      names: {
        tbsCertificate: {
          names: {
            extensions: {
              names: {
                extensions: TBS_CERTIFICATE_EXTENSIONS
              }
            }
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.tbsView = asn1.result.tbsCertificate.valueBeforeDecodeView;
    if (TBS_CERTIFICATE_VERSION in asn1.result)
      this.version = asn1.result[TBS_CERTIFICATE_VERSION].valueBlock.valueDec;
    this.serialNumber = asn1.result[TBS_CERTIFICATE_SERIAL_NUMBER];
    this.signature = new AlgorithmIdentifier({ schema: asn1.result[TBS_CERTIFICATE_SIGNATURE] });
    this.issuer = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERTIFICATE_ISSUER] });
    this.notBefore = new Time({ schema: asn1.result[TBS_CERTIFICATE_NOT_BEFORE] });
    this.notAfter = new Time({ schema: asn1.result[TBS_CERTIFICATE_NOT_AFTER] });
    this.subject = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERTIFICATE_SUBJECT] });
    this.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY] });
    if (TBS_CERTIFICATE_ISSUER_UNIQUE_ID in asn1.result)
      this.issuerUniqueID = asn1.result[TBS_CERTIFICATE_ISSUER_UNIQUE_ID].valueBlock.valueHex;
    if (TBS_CERTIFICATE_SUBJECT_UNIQUE_ID in asn1.result)
      this.subjectUniqueID = asn1.result[TBS_CERTIFICATE_SUBJECT_UNIQUE_ID].valueBlock.valueHex;
    if (TBS_CERTIFICATE_EXTENSIONS in asn1.result)
      this.extensions = Array.from(asn1.result[TBS_CERTIFICATE_EXTENSIONS], (element) => new Extension({ schema: element }));
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
    this.signatureValue = asn1.result.signatureValue;
  }
  encodeTBS() {
    const outputArray = [];
    if (VERSION$f in this && this.version !== _Certificate.defaultValues(VERSION$f)) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.Integer({ value: this.version })
        ]
      }));
    }
    outputArray.push(this.serialNumber);
    outputArray.push(this.signature.toSchema());
    outputArray.push(this.issuer.toSchema());
    outputArray.push(new asn1js.Sequence({
      value: [
        this.notBefore.toSchema(),
        this.notAfter.toSchema()
      ]
    }));
    outputArray.push(this.subject.toSchema());
    outputArray.push(this.subjectPublicKeyInfo.toSchema());
    if (this.issuerUniqueID) {
      outputArray.push(new asn1js.Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        valueHex: this.issuerUniqueID
      }));
    }
    if (this.subjectUniqueID) {
      outputArray.push(new asn1js.Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        valueHex: this.subjectUniqueID
      }));
    }
    if (this.extensions) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 3
        },
        value: [new asn1js.Sequence({
          value: Array.from(this.extensions, (o) => o.toSchema())
        })]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toSchema(encodeFlag = false) {
    let tbsSchema;
    if (encodeFlag === false) {
      if (!this.tbsView.byteLength) {
        return _Certificate.schema().value[0];
      }
      const asn1 = asn1js.fromBER(this.tbsView);
      AsnError.assert(asn1, "TBS Certificate");
      tbsSchema = asn1.result;
    } else {
      tbsSchema = this.encodeTBS();
    }
    return new asn1js.Sequence({
      value: [
        tbsSchema,
        this.signatureAlgorithm.toSchema(),
        this.signatureValue
      ]
    });
  }
  toJSON() {
    const res = {
      tbs: Convert.ToHex(this.tbsView),
      version: this.version,
      serialNumber: this.serialNumber.toJSON(),
      signature: this.signature.toJSON(),
      issuer: this.issuer.toJSON(),
      notBefore: this.notBefore.toJSON(),
      notAfter: this.notAfter.toJSON(),
      subject: this.subject.toJSON(),
      subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signatureValue: this.signatureValue.toJSON()
    };
    if (VERSION$f in this && this.version !== _Certificate.defaultValues(VERSION$f)) {
      res.version = this.version;
    }
    if (this.issuerUniqueID) {
      res.issuerUniqueID = Convert.ToHex(this.issuerUniqueID);
    }
    if (this.subjectUniqueID) {
      res.subjectUniqueID = Convert.ToHex(this.subjectUniqueID);
    }
    if (this.extensions) {
      res.extensions = Array.from(this.extensions, (o) => o.toJSON());
    }
    return res;
  }
  async getPublicKey(parameters, crypto9 = getCrypto2(true)) {
    return crypto9.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
  }
  async getKeyHash(hashAlgorithm = "SHA-1", crypto9 = getCrypto2(true)) {
    return crypto9.digest({ name: hashAlgorithm }, this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
  }
  async sign(privateKey, hashAlgorithm = "SHA-1", crypto9 = getCrypto2(true)) {
    if (!privateKey) {
      throw new Error("Need to provide a private key for signing");
    }
    const signatureParameters = await crypto9.getSignatureParameters(privateKey, hashAlgorithm);
    const parameters = signatureParameters.parameters;
    this.signature = signatureParameters.signatureAlgorithm;
    this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
    this.tbsView = new Uint8Array(this.encodeTBS().toBER());
    const signature = await crypto9.signWithPrivateKey(this.tbsView, privateKey, parameters);
    this.signatureValue = new asn1js.BitString({ valueHex: signature });
  }
  async verify(issuerCertificate, crypto9 = getCrypto2(true)) {
    let subjectPublicKeyInfo;
    if (issuerCertificate) {
      subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
    } else if (this.issuer.isEqual(this.subject)) {
      subjectPublicKeyInfo = this.subjectPublicKeyInfo;
    }
    if (!(subjectPublicKeyInfo instanceof PublicKeyInfo)) {
      throw new Error("Please provide issuer certificate as a parameter");
    }
    return crypto9.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
  }
};
Certificate.CLASS_NAME = "Certificate";
function checkCA(cert, signerCert = null) {
  if (signerCert && cert.issuer.isEqual(signerCert.issuer) && cert.serialNumber.isEqual(signerCert.serialNumber)) {
    return null;
  }
  let isCA = false;
  if (cert.extensions) {
    for (const extension of cert.extensions) {
      if (extension.extnID === id_BasicConstraints && extension.parsedValue instanceof BasicConstraints) {
        if (extension.parsedValue.cA) {
          isCA = true;
          break;
        }
      }
    }
  }
  if (isCA) {
    return cert;
  }
  return null;
}
var CERT_ID$1 = "certId";
var CERT_VALUE = "certValue";
var PARSED_VALUE$4 = "parsedValue";
var CLEAR_PROPS$P = [
  CERT_ID$1,
  CERT_VALUE
];
var CertBag = class _CertBag extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.certId = getParametersValue(parameters, CERT_ID$1, _CertBag.defaultValues(CERT_ID$1));
    this.certValue = getParametersValue(parameters, CERT_VALUE, _CertBag.defaultValues(CERT_VALUE));
    if (PARSED_VALUE$4 in parameters) {
      this.parsedValue = getParametersValue(parameters, PARSED_VALUE$4, _CertBag.defaultValues(PARSED_VALUE$4));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CERT_ID$1:
        return EMPTY_STRING;
      case CERT_VALUE:
        return new asn1js.Any();
      case PARSED_VALUE$4:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case CERT_ID$1:
        return memberValue === EMPTY_STRING;
      case CERT_VALUE:
        return memberValue instanceof asn1js.Any;
      case PARSED_VALUE$4:
        return memberValue instanceof Object && Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.id || "id" }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Any({ name: names.value || "value" })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$P);
    const asn1 = asn1js.compareSchema(schema, schema, _CertBag.schema({
      names: {
        id: CERT_ID$1,
        value: CERT_VALUE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.certId = asn1.result.certId.valueBlock.toString();
    this.certValue = asn1.result.certValue;
    const certValueHex = this.certValue.valueBlock.valueHexView;
    switch (this.certId) {
      case id_CertBag_X509Certificate:
        {
          try {
            this.parsedValue = Certificate.fromBER(certValueHex);
          } catch (ex) {
            AttributeCertificateV2.fromBER(certValueHex);
          }
        }
        break;
      case id_CertBag_AttributeCertificate:
        {
          this.parsedValue = AttributeCertificateV2.fromBER(certValueHex);
        }
        break;
      case id_CertBag_SDSICertificate:
      default:
        throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`);
    }
  }
  toSchema() {
    if (PARSED_VALUE$4 in this) {
      if ("acinfo" in this.parsedValue) {
        this.certId = id_CertBag_AttributeCertificate;
      } else {
        this.certId = id_CertBag_X509Certificate;
      }
      this.certValue = new asn1js.OctetString({ valueHex: this.parsedValue.toSchema().toBER(false) });
    }
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.certId }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: ["toSchema" in this.certValue ? this.certValue.toSchema() : this.certValue]
        })
      ]
    });
  }
  toJSON() {
    return {
      certId: this.certId,
      certValue: this.certValue.toJSON()
    };
  }
};
CertBag.CLASS_NAME = "CertBag";
var USER_CERTIFICATE = "userCertificate";
var REVOCATION_DATE = "revocationDate";
var CRL_ENTRY_EXTENSIONS = "crlEntryExtensions";
var CLEAR_PROPS$O = [
  USER_CERTIFICATE,
  REVOCATION_DATE,
  CRL_ENTRY_EXTENSIONS
];
var RevokedCertificate = class _RevokedCertificate extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.userCertificate = getParametersValue(parameters, USER_CERTIFICATE, _RevokedCertificate.defaultValues(USER_CERTIFICATE));
    this.revocationDate = getParametersValue(parameters, REVOCATION_DATE, _RevokedCertificate.defaultValues(REVOCATION_DATE));
    if (CRL_ENTRY_EXTENSIONS in parameters) {
      this.crlEntryExtensions = getParametersValue(parameters, CRL_ENTRY_EXTENSIONS, _RevokedCertificate.defaultValues(CRL_ENTRY_EXTENSIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case USER_CERTIFICATE:
        return new asn1js.Integer();
      case REVOCATION_DATE:
        return new Time();
      case CRL_ENTRY_EXTENSIONS:
        return new Extensions();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.userCertificate || USER_CERTIFICATE }),
        Time.schema({
          names: {
            utcTimeName: names.revocationDate || REVOCATION_DATE,
            generalTimeName: names.revocationDate || REVOCATION_DATE
          }
        }),
        Extensions.schema({
          names: {
            blockName: names.crlEntryExtensions || CRL_ENTRY_EXTENSIONS
          }
        }, true)
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$O);
    const asn1 = asn1js.compareSchema(schema, schema, _RevokedCertificate.schema());
    AsnError.assertSchema(asn1, this.className);
    this.userCertificate = asn1.result.userCertificate;
    this.revocationDate = new Time({ schema: asn1.result.revocationDate });
    if (CRL_ENTRY_EXTENSIONS in asn1.result) {
      this.crlEntryExtensions = new Extensions({ schema: asn1.result.crlEntryExtensions });
    }
  }
  toSchema() {
    const outputArray = [
      this.userCertificate,
      this.revocationDate.toSchema()
    ];
    if (this.crlEntryExtensions) {
      outputArray.push(this.crlEntryExtensions.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      userCertificate: this.userCertificate.toJSON(),
      revocationDate: this.revocationDate.toJSON()
    };
    if (this.crlEntryExtensions) {
      res.crlEntryExtensions = this.crlEntryExtensions.toJSON();
    }
    return res;
  }
};
RevokedCertificate.CLASS_NAME = "RevokedCertificate";
var TBS$3 = "tbs";
var VERSION$e = "version";
var SIGNATURE$3 = "signature";
var ISSUER$1 = "issuer";
var THIS_UPDATE$1 = "thisUpdate";
var NEXT_UPDATE$1 = "nextUpdate";
var REVOKED_CERTIFICATES = "revokedCertificates";
var CRL_EXTENSIONS = "crlExtensions";
var SIGNATURE_ALGORITHM$4 = "signatureAlgorithm";
var SIGNATURE_VALUE$1 = "signatureValue";
var TBS_CERT_LIST = "tbsCertList";
var TBS_CERT_LIST_VERSION = `${TBS_CERT_LIST}.version`;
var TBS_CERT_LIST_SIGNATURE = `${TBS_CERT_LIST}.signature`;
var TBS_CERT_LIST_ISSUER = `${TBS_CERT_LIST}.issuer`;
var TBS_CERT_LIST_THIS_UPDATE = `${TBS_CERT_LIST}.thisUpdate`;
var TBS_CERT_LIST_NEXT_UPDATE = `${TBS_CERT_LIST}.nextUpdate`;
var TBS_CERT_LIST_REVOKED_CERTIFICATES = `${TBS_CERT_LIST}.revokedCertificates`;
var TBS_CERT_LIST_EXTENSIONS = `${TBS_CERT_LIST}.extensions`;
var CLEAR_PROPS$N = [
  TBS_CERT_LIST,
  TBS_CERT_LIST_VERSION,
  TBS_CERT_LIST_SIGNATURE,
  TBS_CERT_LIST_ISSUER,
  TBS_CERT_LIST_THIS_UPDATE,
  TBS_CERT_LIST_NEXT_UPDATE,
  TBS_CERT_LIST_REVOKED_CERTIFICATES,
  TBS_CERT_LIST_EXTENSIONS,
  SIGNATURE_ALGORITHM$4,
  SIGNATURE_VALUE$1
];
function tbsCertList(parameters = {}) {
  const names = getParametersValue(parameters, "names", {});
  return new asn1js.Sequence({
    name: names.blockName || TBS_CERT_LIST,
    value: [
      new asn1js.Integer({
        optional: true,
        name: names.tbsCertListVersion || TBS_CERT_LIST_VERSION,
        value: 2
      }),
      AlgorithmIdentifier.schema(names.signature || {
        names: {
          blockName: TBS_CERT_LIST_SIGNATURE
        }
      }),
      RelativeDistinguishedNames.schema(names.issuer || {
        names: {
          blockName: TBS_CERT_LIST_ISSUER
        }
      }),
      Time.schema(names.tbsCertListThisUpdate || {
        names: {
          utcTimeName: TBS_CERT_LIST_THIS_UPDATE,
          generalTimeName: TBS_CERT_LIST_THIS_UPDATE
        }
      }),
      Time.schema(names.tbsCertListNextUpdate || {
        names: {
          utcTimeName: TBS_CERT_LIST_NEXT_UPDATE,
          generalTimeName: TBS_CERT_LIST_NEXT_UPDATE
        }
      }, true),
      new asn1js.Sequence({
        optional: true,
        value: [
          new asn1js.Repeated({
            name: names.tbsCertListRevokedCertificates || TBS_CERT_LIST_REVOKED_CERTIFICATES,
            value: new asn1js.Sequence({
              value: [
                new asn1js.Integer(),
                Time.schema(),
                Extensions.schema({}, true)
              ]
            })
          })
        ]
      }),
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [Extensions.schema(names.crlExtensions || {
          names: {
            blockName: TBS_CERT_LIST_EXTENSIONS
          }
        })]
      })
    ]
  });
}
var WELL_KNOWN_EXTENSIONS = [
  id_AuthorityKeyIdentifier,
  id_IssuerAltName,
  id_CRLNumber,
  id_BaseCRLNumber,
  id_IssuingDistributionPoint,
  id_FreshestCRL,
  id_AuthorityInfoAccess,
  id_CRLReason,
  id_InvalidityDate,
  id_CertificateIssuer
];
var CertificateRevocationList = class _CertificateRevocationList extends PkiObject {
  get tbs() {
    return BufferSourceConverter.toArrayBuffer(this.tbsView);
  }
  set tbs(value) {
    this.tbsView = new Uint8Array(value);
  }
  constructor(parameters = {}) {
    super();
    this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$3, _CertificateRevocationList.defaultValues(TBS$3)));
    this.version = getParametersValue(parameters, VERSION$e, _CertificateRevocationList.defaultValues(VERSION$e));
    this.signature = getParametersValue(parameters, SIGNATURE$3, _CertificateRevocationList.defaultValues(SIGNATURE$3));
    this.issuer = getParametersValue(parameters, ISSUER$1, _CertificateRevocationList.defaultValues(ISSUER$1));
    this.thisUpdate = getParametersValue(parameters, THIS_UPDATE$1, _CertificateRevocationList.defaultValues(THIS_UPDATE$1));
    if (NEXT_UPDATE$1 in parameters) {
      this.nextUpdate = getParametersValue(parameters, NEXT_UPDATE$1, _CertificateRevocationList.defaultValues(NEXT_UPDATE$1));
    }
    if (REVOKED_CERTIFICATES in parameters) {
      this.revokedCertificates = getParametersValue(parameters, REVOKED_CERTIFICATES, _CertificateRevocationList.defaultValues(REVOKED_CERTIFICATES));
    }
    if (CRL_EXTENSIONS in parameters) {
      this.crlExtensions = getParametersValue(parameters, CRL_EXTENSIONS, _CertificateRevocationList.defaultValues(CRL_EXTENSIONS));
    }
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$4, _CertificateRevocationList.defaultValues(SIGNATURE_ALGORITHM$4));
    this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$1, _CertificateRevocationList.defaultValues(SIGNATURE_VALUE$1));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TBS$3:
        return EMPTY_BUFFER;
      case VERSION$e:
        return 0;
      case SIGNATURE$3:
        return new AlgorithmIdentifier();
      case ISSUER$1:
        return new RelativeDistinguishedNames();
      case THIS_UPDATE$1:
        return new Time();
      case NEXT_UPDATE$1:
        return new Time();
      case REVOKED_CERTIFICATES:
        return [];
      case CRL_EXTENSIONS:
        return new Extensions();
      case SIGNATURE_ALGORITHM$4:
        return new AlgorithmIdentifier();
      case SIGNATURE_VALUE$1:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || "CertificateList",
      value: [
        tbsCertList(parameters),
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: SIGNATURE_ALGORITHM$4
          }
        }),
        new asn1js.BitString({ name: names.signatureValue || SIGNATURE_VALUE$1 })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$N);
    const asn1 = asn1js.compareSchema(schema, schema, _CertificateRevocationList.schema());
    AsnError.assertSchema(asn1, this.className);
    this.tbsView = asn1.result.tbsCertList.valueBeforeDecodeView;
    if (TBS_CERT_LIST_VERSION in asn1.result) {
      this.version = asn1.result[TBS_CERT_LIST_VERSION].valueBlock.valueDec;
    }
    this.signature = new AlgorithmIdentifier({ schema: asn1.result[TBS_CERT_LIST_SIGNATURE] });
    this.issuer = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERT_LIST_ISSUER] });
    this.thisUpdate = new Time({ schema: asn1.result[TBS_CERT_LIST_THIS_UPDATE] });
    if (TBS_CERT_LIST_NEXT_UPDATE in asn1.result) {
      this.nextUpdate = new Time({ schema: asn1.result[TBS_CERT_LIST_NEXT_UPDATE] });
    }
    if (TBS_CERT_LIST_REVOKED_CERTIFICATES in asn1.result) {
      this.revokedCertificates = Array.from(asn1.result[TBS_CERT_LIST_REVOKED_CERTIFICATES], (element) => new RevokedCertificate({ schema: element }));
    }
    if (TBS_CERT_LIST_EXTENSIONS in asn1.result) {
      this.crlExtensions = new Extensions({ schema: asn1.result[TBS_CERT_LIST_EXTENSIONS] });
    }
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
    this.signatureValue = asn1.result.signatureValue;
  }
  encodeTBS() {
    const outputArray = [];
    if (this.version !== _CertificateRevocationList.defaultValues(VERSION$e)) {
      outputArray.push(new asn1js.Integer({ value: this.version }));
    }
    outputArray.push(this.signature.toSchema());
    outputArray.push(this.issuer.toSchema());
    outputArray.push(this.thisUpdate.toSchema());
    if (this.nextUpdate) {
      outputArray.push(this.nextUpdate.toSchema());
    }
    if (this.revokedCertificates) {
      outputArray.push(new asn1js.Sequence({
        value: Array.from(this.revokedCertificates, (o) => o.toSchema())
      }));
    }
    if (this.crlExtensions) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          this.crlExtensions.toSchema()
        ]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toSchema(encodeFlag = false) {
    let tbsSchema;
    if (!encodeFlag) {
      if (!this.tbsView.byteLength) {
        return _CertificateRevocationList.schema();
      }
      const asn1 = asn1js.fromBER(this.tbsView);
      AsnError.assert(asn1, "TBS Certificate Revocation List");
      tbsSchema = asn1.result;
    } else {
      tbsSchema = this.encodeTBS();
    }
    return new asn1js.Sequence({
      value: [
        tbsSchema,
        this.signatureAlgorithm.toSchema(),
        this.signatureValue
      ]
    });
  }
  toJSON() {
    const res = {
      tbs: Convert.ToHex(this.tbsView),
      version: this.version,
      signature: this.signature.toJSON(),
      issuer: this.issuer.toJSON(),
      thisUpdate: this.thisUpdate.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signatureValue: this.signatureValue.toJSON()
    };
    if (this.version !== _CertificateRevocationList.defaultValues(VERSION$e))
      res.version = this.version;
    if (this.nextUpdate) {
      res.nextUpdate = this.nextUpdate.toJSON();
    }
    if (this.revokedCertificates) {
      res.revokedCertificates = Array.from(this.revokedCertificates, (o) => o.toJSON());
    }
    if (this.crlExtensions) {
      res.crlExtensions = this.crlExtensions.toJSON();
    }
    return res;
  }
  isCertificateRevoked(certificate) {
    if (!this.issuer.isEqual(certificate.issuer)) {
      return false;
    }
    if (!this.revokedCertificates) {
      return false;
    }
    for (const revokedCertificate of this.revokedCertificates) {
      if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) {
        return true;
      }
    }
    return false;
  }
  async sign(privateKey, hashAlgorithm = "SHA-1", crypto9 = getCrypto2(true)) {
    if (!privateKey) {
      throw new Error("Need to provide a private key for signing");
    }
    const signatureParameters = await crypto9.getSignatureParameters(privateKey, hashAlgorithm);
    const { parameters } = signatureParameters;
    this.signature = signatureParameters.signatureAlgorithm;
    this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
    this.tbsView = new Uint8Array(this.encodeTBS().toBER());
    const signature = await crypto9.signWithPrivateKey(this.tbsView, privateKey, parameters);
    this.signatureValue = new asn1js.BitString({ valueHex: signature });
  }
  async verify(parameters = {}, crypto9 = getCrypto2(true)) {
    let subjectPublicKeyInfo;
    if (parameters.issuerCertificate) {
      subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
      if (!this.issuer.isEqual(parameters.issuerCertificate.subject)) {
        return false;
      }
    }
    if (parameters.publicKeyInfo) {
      subjectPublicKeyInfo = parameters.publicKeyInfo;
    }
    if (!subjectPublicKeyInfo) {
      throw new Error("Issuer's certificate must be provided as an input parameter");
    }
    if (this.crlExtensions) {
      for (const extension of this.crlExtensions.extensions) {
        if (extension.critical) {
          if (!WELL_KNOWN_EXTENSIONS.includes(extension.extnID))
            return false;
        }
      }
    }
    return crypto9.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
  }
};
CertificateRevocationList.CLASS_NAME = "CertificateRevocationList";
var CRL_ID = "crlId";
var CRL_VALUE = "crlValue";
var PARSED_VALUE$3 = "parsedValue";
var CLEAR_PROPS$M = [
  CRL_ID,
  CRL_VALUE
];
var CRLBag = class _CRLBag extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.crlId = getParametersValue(parameters, CRL_ID, _CRLBag.defaultValues(CRL_ID));
    this.crlValue = getParametersValue(parameters, CRL_VALUE, _CRLBag.defaultValues(CRL_VALUE));
    if (PARSED_VALUE$3 in parameters) {
      this.parsedValue = getParametersValue(parameters, PARSED_VALUE$3, _CRLBag.defaultValues(PARSED_VALUE$3));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CRL_ID:
        return EMPTY_STRING;
      case CRL_VALUE:
        return new asn1js.Any();
      case PARSED_VALUE$3:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case CRL_ID:
        return memberValue === EMPTY_STRING;
      case CRL_VALUE:
        return memberValue instanceof asn1js.Any;
      case PARSED_VALUE$3:
        return memberValue instanceof Object && Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.id || "id" }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Any({ name: names.value || "value" })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$M);
    const asn1 = asn1js.compareSchema(schema, schema, _CRLBag.schema({
      names: {
        id: CRL_ID,
        value: CRL_VALUE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.crlId = asn1.result.crlId.valueBlock.toString();
    this.crlValue = asn1.result.crlValue;
    switch (this.crlId) {
      case id_CRLBag_X509CRL:
        {
          this.parsedValue = CertificateRevocationList.fromBER(this.certValue.valueBlock.valueHex);
        }
        break;
      default:
        throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`);
    }
  }
  toSchema() {
    if (this.parsedValue) {
      this.crlId = id_CRLBag_X509CRL;
      this.crlValue = new asn1js.OctetString({ valueHex: this.parsedValue.toSchema().toBER(false) });
    }
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.crlId }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.crlValue.toSchema()]
        })
      ]
    });
  }
  toJSON() {
    return {
      crlId: this.crlId,
      crlValue: this.crlValue.toJSON()
    };
  }
};
CRLBag.CLASS_NAME = "CRLBag";
var VERSION$d = "version";
var ENCRYPTED_CONTENT_INFO$1 = "encryptedContentInfo";
var UNPROTECTED_ATTRS$1 = "unprotectedAttrs";
var CLEAR_PROPS$L = [
  VERSION$d,
  ENCRYPTED_CONTENT_INFO$1,
  UNPROTECTED_ATTRS$1
];
var EncryptedData = class _EncryptedData extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$d, _EncryptedData.defaultValues(VERSION$d));
    this.encryptedContentInfo = getParametersValue(parameters, ENCRYPTED_CONTENT_INFO$1, _EncryptedData.defaultValues(ENCRYPTED_CONTENT_INFO$1));
    if (UNPROTECTED_ATTRS$1 in parameters) {
      this.unprotectedAttrs = getParametersValue(parameters, UNPROTECTED_ATTRS$1, _EncryptedData.defaultValues(UNPROTECTED_ATTRS$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$d:
        return 0;
      case ENCRYPTED_CONTENT_INFO$1:
        return new EncryptedContentInfo();
      case UNPROTECTED_ATTRS$1:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$d:
        return memberValue === 0;
      case ENCRYPTED_CONTENT_INFO$1:
        return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent);
      case UNPROTECTED_ATTRS$1:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [
            new asn1js.Repeated({
              name: names.unprotectedAttrs || EMPTY_STRING,
              value: Attribute.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$L);
    const asn1 = asn1js.compareSchema(schema, schema, _EncryptedData.schema({
      names: {
        version: VERSION$d,
        encryptedContentInfo: {
          names: {
            blockName: ENCRYPTED_CONTENT_INFO$1
          }
        },
        unprotectedAttrs: UNPROTECTED_ATTRS$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
    if (UNPROTECTED_ATTRS$1 in asn1.result)
      this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, (element) => new Attribute({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    outputArray.push(this.encryptedContentInfo.toSchema());
    if (this.unprotectedAttrs) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: Array.from(this.unprotectedAttrs, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      encryptedContentInfo: this.encryptedContentInfo.toJSON()
    };
    if (this.unprotectedAttrs)
      res.unprotectedAttrs = Array.from(this.unprotectedAttrs, (o) => o.toJSON());
    return res;
  }
  async encrypt(parameters, crypto9 = getCrypto2(true)) {
    ArgumentError.assert(parameters, "parameters", "object");
    const encryptParams = {
      ...parameters,
      contentType: "1.2.840.113549.1.7.1"
    };
    this.encryptedContentInfo = await crypto9.encryptEncryptedContentInfo(encryptParams);
  }
  async decrypt(parameters, crypto9 = getCrypto2(true)) {
    ArgumentError.assert(parameters, "parameters", "object");
    const decryptParams = {
      ...parameters,
      encryptedContentInfo: this.encryptedContentInfo
    };
    return crypto9.decryptEncryptedContentInfo(decryptParams);
  }
};
EncryptedData.CLASS_NAME = "EncryptedData";
var ENCRYPTION_ALGORITHM = "encryptionAlgorithm";
var ENCRYPTED_DATA = "encryptedData";
var PARSED_VALUE$2 = "parsedValue";
var CLEAR_PROPS$K = [
  ENCRYPTION_ALGORITHM,
  ENCRYPTED_DATA
];
var PKCS8ShroudedKeyBag = class _PKCS8ShroudedKeyBag extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.encryptionAlgorithm = getParametersValue(parameters, ENCRYPTION_ALGORITHM, _PKCS8ShroudedKeyBag.defaultValues(ENCRYPTION_ALGORITHM));
    this.encryptedData = getParametersValue(parameters, ENCRYPTED_DATA, _PKCS8ShroudedKeyBag.defaultValues(ENCRYPTED_DATA));
    if (PARSED_VALUE$2 in parameters) {
      this.parsedValue = getParametersValue(parameters, PARSED_VALUE$2, _PKCS8ShroudedKeyBag.defaultValues(PARSED_VALUE$2));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ENCRYPTION_ALGORITHM:
        return new AlgorithmIdentifier();
      case ENCRYPTED_DATA:
        return new asn1js.OctetString();
      case PARSED_VALUE$2:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case ENCRYPTION_ALGORITHM:
        return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
      case ENCRYPTED_DATA:
        return memberValue.isEqual(_PKCS8ShroudedKeyBag.defaultValues(memberName));
      case PARSED_VALUE$2:
        return memberValue instanceof Object && Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.encryptionAlgorithm || {
          names: {
            blockName: ENCRYPTION_ALGORITHM
          }
        }),
        new asn1js.Choice({
          value: [
            new asn1js.OctetString({ name: names.encryptedData || ENCRYPTED_DATA }),
            new asn1js.OctetString({
              idBlock: {
                isConstructed: true
              },
              name: names.encryptedData || ENCRYPTED_DATA
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$K);
    const asn1 = asn1js.compareSchema(schema, schema, _PKCS8ShroudedKeyBag.schema({
      names: {
        encryptionAlgorithm: {
          names: {
            blockName: ENCRYPTION_ALGORITHM
          }
        },
        encryptedData: ENCRYPTED_DATA
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.encryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.encryptionAlgorithm });
    this.encryptedData = asn1.result.encryptedData;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.encryptionAlgorithm.toSchema(),
        this.encryptedData
      ]
    });
  }
  toJSON() {
    return {
      encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),
      encryptedData: this.encryptedData.toJSON()
    };
  }
  async parseInternalValues(parameters, crypto9 = getCrypto2(true)) {
    const cmsEncrypted = new EncryptedData({
      encryptedContentInfo: new EncryptedContentInfo({
        contentEncryptionAlgorithm: this.encryptionAlgorithm,
        encryptedContent: this.encryptedData
      })
    });
    const decryptedData = await cmsEncrypted.decrypt(parameters, crypto9);
    this.parsedValue = PrivateKeyInfo.fromBER(decryptedData);
  }
  async makeInternalValues(parameters, crypto9 = getCrypto2(true)) {
    if (!this.parsedValue) {
      throw new Error('Please initialize "parsedValue" first');
    }
    const cmsEncrypted = new EncryptedData();
    const encryptParams = {
      ...parameters,
      contentToEncrypt: this.parsedValue.toSchema().toBER(false)
    };
    await cmsEncrypted.encrypt(encryptParams, crypto9);
    if (!cmsEncrypted.encryptedContentInfo.encryptedContent) {
      throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");
    }
    this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;
    this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;
  }
};
PKCS8ShroudedKeyBag.CLASS_NAME = "PKCS8ShroudedKeyBag";
var SECRET_TYPE_ID = "secretTypeId";
var SECRET_VALUE = "secretValue";
var CLEAR_PROPS$J = [
  SECRET_TYPE_ID,
  SECRET_VALUE
];
var SecretBag = class _SecretBag extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.secretTypeId = getParametersValue(parameters, SECRET_TYPE_ID, _SecretBag.defaultValues(SECRET_TYPE_ID));
    this.secretValue = getParametersValue(parameters, SECRET_VALUE, _SecretBag.defaultValues(SECRET_VALUE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SECRET_TYPE_ID:
        return EMPTY_STRING;
      case SECRET_VALUE:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case SECRET_TYPE_ID:
        return memberValue === EMPTY_STRING;
      case SECRET_VALUE:
        return memberValue instanceof asn1js.Any;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.id || "id" }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Any({ name: names.value || "value" })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$J);
    const asn1 = asn1js.compareSchema(schema, schema, _SecretBag.schema({
      names: {
        id: SECRET_TYPE_ID,
        value: SECRET_VALUE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();
    this.secretValue = asn1.result.secretValue;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.secretTypeId }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.secretValue.toSchema()]
        })
      ]
    });
  }
  toJSON() {
    return {
      secretTypeId: this.secretTypeId,
      secretValue: this.secretValue.toJSON()
    };
  }
};
SecretBag.CLASS_NAME = "SecretBag";
var SafeBagValueFactory = class _SafeBagValueFactory {
  static getItems() {
    if (!this.items) {
      this.items = {};
      _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.1", PrivateKeyInfo);
      _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.2", PKCS8ShroudedKeyBag);
      _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.3", CertBag);
      _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.4", CRLBag);
      _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.5", SecretBag);
      _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.6", SafeContents);
    }
    return this.items;
  }
  static register(id, type) {
    this.getItems()[id] = type;
  }
  static find(id) {
    return this.getItems()[id] || null;
  }
};
var BAG_ID = "bagId";
var BAG_VALUE = "bagValue";
var BAG_ATTRIBUTES = "bagAttributes";
var CLEAR_PROPS$I = [
  BAG_ID,
  BAG_VALUE,
  BAG_ATTRIBUTES
];
var SafeBag = class _SafeBag extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.bagId = getParametersValue(parameters, BAG_ID, _SafeBag.defaultValues(BAG_ID));
    this.bagValue = getParametersValue(parameters, BAG_VALUE, _SafeBag.defaultValues(BAG_VALUE));
    if (BAG_ATTRIBUTES in parameters) {
      this.bagAttributes = getParametersValue(parameters, BAG_ATTRIBUTES, _SafeBag.defaultValues(BAG_ATTRIBUTES));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case BAG_ID:
        return EMPTY_STRING;
      case BAG_VALUE:
        return new asn1js.Any();
      case BAG_ATTRIBUTES:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case BAG_ID:
        return memberValue === EMPTY_STRING;
      case BAG_VALUE:
        return memberValue instanceof asn1js.Any;
      case BAG_ATTRIBUTES:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.bagId || BAG_ID }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Any({ name: names.bagValue || BAG_VALUE })]
        }),
        new asn1js.Set({
          optional: true,
          value: [
            new asn1js.Repeated({
              name: names.bagAttributes || BAG_ATTRIBUTES,
              value: Attribute.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$I);
    const asn1 = asn1js.compareSchema(schema, schema, _SafeBag.schema({
      names: {
        bagId: BAG_ID,
        bagValue: BAG_VALUE,
        bagAttributes: BAG_ATTRIBUTES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.bagId = asn1.result.bagId.valueBlock.toString();
    const bagType = SafeBagValueFactory.find(this.bagId);
    if (!bagType) {
      throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);
    }
    this.bagValue = new bagType({ schema: asn1.result.bagValue });
    if (BAG_ATTRIBUTES in asn1.result) {
      this.bagAttributes = Array.from(asn1.result.bagAttributes, (element) => new Attribute({ schema: element }));
    }
  }
  toSchema() {
    const outputArray = [
      new asn1js.ObjectIdentifier({ value: this.bagId }),
      new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [this.bagValue.toSchema()]
      })
    ];
    if (this.bagAttributes) {
      outputArray.push(new asn1js.Set({
        value: Array.from(this.bagAttributes, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const output6 = {
      bagId: this.bagId,
      bagValue: this.bagValue.toJSON()
    };
    if (this.bagAttributes) {
      output6.bagAttributes = Array.from(this.bagAttributes, (o) => o.toJSON());
    }
    return output6;
  }
};
SafeBag.CLASS_NAME = "SafeBag";
var SAFE_BUGS = "safeBags";
var SafeContents = class _SafeContents extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.safeBags = getParametersValue(parameters, SAFE_BUGS, _SafeContents.defaultValues(SAFE_BUGS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SAFE_BUGS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case SAFE_BUGS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.safeBags || EMPTY_STRING,
          value: SafeBag.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      SAFE_BUGS
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _SafeContents.schema({
      names: {
        safeBags: SAFE_BUGS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.safeBags = Array.from(asn1.result.safeBags, (element) => new SafeBag({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.safeBags, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      safeBags: Array.from(this.safeBags, (o) => o.toJSON())
    };
  }
};
SafeContents.CLASS_NAME = "SafeContents";
var OTHER_CERT_FORMAT = "otherCertFormat";
var OTHER_CERT = "otherCert";
var CLEAR_PROPS$H = [
  OTHER_CERT_FORMAT,
  OTHER_CERT
];
var OtherCertificateFormat = class _OtherCertificateFormat extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.otherCertFormat = getParametersValue(parameters, OTHER_CERT_FORMAT, _OtherCertificateFormat.defaultValues(OTHER_CERT_FORMAT));
    this.otherCert = getParametersValue(parameters, OTHER_CERT, _OtherCertificateFormat.defaultValues(OTHER_CERT));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case OTHER_CERT_FORMAT:
        return EMPTY_STRING;
      case OTHER_CERT:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.otherCertFormat || OTHER_CERT_FORMAT }),
        new asn1js.Any({ name: names.otherCert || OTHER_CERT })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$H);
    const asn1 = asn1js.compareSchema(schema, schema, _OtherCertificateFormat.schema());
    AsnError.assertSchema(asn1, this.className);
    this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
    this.otherCert = asn1.result.otherCert;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.otherCertFormat }),
        this.otherCert
      ]
    });
  }
  toJSON() {
    const res = {
      otherCertFormat: this.otherCertFormat
    };
    if (!(this.otherCert instanceof asn1js.Any)) {
      res.otherCert = this.otherCert.toJSON();
    }
    return res;
  }
};
var CERTIFICATES$1 = "certificates";
var CLEAR_PROPS$G = [
  CERTIFICATES$1
];
var CertificateSet = class _CertificateSet extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.certificates = getParametersValue(parameters, CERTIFICATES$1, _CertificateSet.defaultValues(CERTIFICATES$1));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CERTIFICATES$1:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Set({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.certificates || CERTIFICATES$1,
          value: new asn1js.Choice({
            value: [
              Certificate.schema(),
              new asn1js.Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                value: [
                  new asn1js.Any()
                ]
              }),
              new asn1js.Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                value: [
                  new asn1js.Sequence()
                ]
              }),
              new asn1js.Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 2
                },
                value: AttributeCertificateV2.schema().valueBlock.value
              }),
              new asn1js.Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 3
                },
                value: OtherCertificateFormat.schema().valueBlock.value
              })
            ]
          })
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$G);
    const asn1 = asn1js.compareSchema(schema, schema, _CertificateSet.schema());
    AsnError.assertSchema(asn1, this.className);
    this.certificates = Array.from(asn1.result.certificates || [], (element) => {
      const initialTagNumber = element.idBlock.tagNumber;
      if (element.idBlock.tagClass === 1)
        return new Certificate({ schema: element });
      const elementSequence = new asn1js.Sequence({
        value: element.valueBlock.value
      });
      switch (initialTagNumber) {
        case 1:
          if (elementSequence.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec === 1) {
            return new AttributeCertificateV2({ schema: elementSequence });
          } else {
            return new AttributeCertificateV1({ schema: elementSequence });
          }
        case 2:
          return new AttributeCertificateV2({ schema: elementSequence });
        case 3:
          return new OtherCertificateFormat({ schema: elementSequence });
      }
      return element;
    });
  }
  toSchema() {
    return new asn1js.Set({
      value: Array.from(this.certificates, (element) => {
        switch (true) {
          case element instanceof Certificate:
            return element.toSchema();
          case element instanceof AttributeCertificateV1:
            return new asn1js.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: element.toSchema().valueBlock.value
            });
          case element instanceof AttributeCertificateV2:
            return new asn1js.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: element.toSchema().valueBlock.value
            });
          case element instanceof OtherCertificateFormat:
            return new asn1js.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 3
              },
              value: element.toSchema().valueBlock.value
            });
        }
        return element.toSchema();
      })
    });
  }
  toJSON() {
    return {
      certificates: Array.from(this.certificates, (o) => o.toJSON())
    };
  }
};
CertificateSet.CLASS_NAME = "CertificateSet";
var OTHER_REV_INFO_FORMAT = "otherRevInfoFormat";
var OTHER_REV_INFO = "otherRevInfo";
var CLEAR_PROPS$F = [
  OTHER_REV_INFO_FORMAT,
  OTHER_REV_INFO
];
var OtherRevocationInfoFormat = class _OtherRevocationInfoFormat extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.otherRevInfoFormat = getParametersValue(parameters, OTHER_REV_INFO_FORMAT, _OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO_FORMAT));
    this.otherRevInfo = getParametersValue(parameters, OTHER_REV_INFO, _OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case OTHER_REV_INFO_FORMAT:
        return EMPTY_STRING;
      case OTHER_REV_INFO:
        return new asn1js.Any();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.otherRevInfoFormat || OTHER_REV_INFO_FORMAT }),
        new asn1js.Any({ name: names.otherRevInfo || OTHER_REV_INFO })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$F);
    const asn1 = asn1js.compareSchema(schema, schema, _OtherRevocationInfoFormat.schema());
    AsnError.assertSchema(asn1, this.className);
    this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
    this.otherRevInfo = asn1.result.otherRevInfo;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.otherRevInfoFormat }),
        this.otherRevInfo
      ]
    });
  }
  toJSON() {
    const res = {
      otherRevInfoFormat: this.otherRevInfoFormat
    };
    if (!(this.otherRevInfo instanceof asn1js.Any)) {
      res.otherRevInfo = this.otherRevInfo.toJSON();
    }
    return res;
  }
};
OtherRevocationInfoFormat.CLASS_NAME = "OtherRevocationInfoFormat";
var CRLS$3 = "crls";
var OTHER_REVOCATION_INFOS = "otherRevocationInfos";
var CLEAR_PROPS$E = [
  CRLS$3
];
var RevocationInfoChoices = class _RevocationInfoChoices extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.crls = getParametersValue(parameters, CRLS$3, _RevocationInfoChoices.defaultValues(CRLS$3));
    this.otherRevocationInfos = getParametersValue(parameters, OTHER_REVOCATION_INFOS, _RevocationInfoChoices.defaultValues(OTHER_REVOCATION_INFOS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CRLS$3:
        return [];
      case OTHER_REVOCATION_INFOS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Set({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.crls || EMPTY_STRING,
          value: new asn1js.Choice({
            value: [
              CertificateRevocationList.schema(),
              new asn1js.Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                value: [
                  new asn1js.ObjectIdentifier(),
                  new asn1js.Any()
                ]
              })
            ]
          })
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$E);
    const asn1 = asn1js.compareSchema(schema, schema, _RevocationInfoChoices.schema({
      names: {
        crls: CRLS$3
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (asn1.result.crls) {
      for (const element of asn1.result.crls) {
        if (element.idBlock.tagClass === 1)
          this.crls.push(new CertificateRevocationList({ schema: element }));
        else
          this.otherRevocationInfos.push(new OtherRevocationInfoFormat({ schema: element }));
      }
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(...Array.from(this.crls, (o) => o.toSchema()));
    outputArray.push(...Array.from(this.otherRevocationInfos, (element) => {
      const schema = element.toSchema();
      schema.idBlock.tagClass = 3;
      schema.idBlock.tagNumber = 1;
      return schema;
    }));
    return new asn1js.Set({
      value: outputArray
    });
  }
  toJSON() {
    return {
      crls: Array.from(this.crls, (o) => o.toJSON()),
      otherRevocationInfos: Array.from(this.otherRevocationInfos, (o) => o.toJSON())
    };
  }
};
RevocationInfoChoices.CLASS_NAME = "RevocationInfoChoices";
var CERTS$3 = "certs";
var CRLS$2 = "crls";
var CLEAR_PROPS$D = [
  CERTS$3,
  CRLS$2
];
var OriginatorInfo = class _OriginatorInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.crls = getParametersValue(parameters, CRLS$2, _OriginatorInfo.defaultValues(CRLS$2));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CERTS$3:
        return new CertificateSet();
      case CRLS$2:
        return new RevocationInfoChoices();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case CERTS$3:
        return memberValue.certificates.length === 0;
      case CRLS$2:
        return memberValue.crls.length === 0 && memberValue.otherRevocationInfos.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          name: names.certs || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: CertificateSet.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          name: names.crls || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: RevocationInfoChoices.schema().valueBlock.value
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$D);
    const asn1 = asn1js.compareSchema(schema, schema, _OriginatorInfo.schema({
      names: {
        certs: CERTS$3,
        crls: CRLS$2
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (CERTS$3 in asn1.result) {
      this.certs = new CertificateSet({
        schema: new asn1js.Set({
          value: asn1.result.certs.valueBlock.value
        })
      });
    }
    if (CRLS$2 in asn1.result) {
      this.crls = new RevocationInfoChoices({
        schema: new asn1js.Set({
          value: asn1.result.crls.valueBlock.value
        })
      });
    }
  }
  toSchema() {
    const sequenceValue = [];
    if (this.certs) {
      sequenceValue.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: this.certs.toSchema().valueBlock.value
      }));
    }
    if (this.crls) {
      sequenceValue.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: this.crls.toSchema().valueBlock.value
      }));
    }
    return new asn1js.Sequence({
      value: sequenceValue
    });
  }
  toJSON() {
    const res = {};
    if (this.certs) {
      res.certs = this.certs.toJSON();
    }
    if (this.crls) {
      res.crls = this.crls.toJSON();
    }
    return res;
  }
};
OriginatorInfo.CLASS_NAME = "OriginatorInfo";
var ISSUER = "issuer";
var SERIAL_NUMBER$2 = "serialNumber";
var CLEAR_PROPS$C = [
  ISSUER,
  SERIAL_NUMBER$2
];
var IssuerAndSerialNumber = class _IssuerAndSerialNumber extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.issuer = getParametersValue(parameters, ISSUER, _IssuerAndSerialNumber.defaultValues(ISSUER));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$2, _IssuerAndSerialNumber.defaultValues(SERIAL_NUMBER$2));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ISSUER:
        return new RelativeDistinguishedNames();
      case SERIAL_NUMBER$2:
        return new asn1js.Integer();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        RelativeDistinguishedNames.schema(names.issuer || {}),
        new asn1js.Integer({ name: names.serialNumber || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$C);
    const asn1 = asn1js.compareSchema(schema, schema, _IssuerAndSerialNumber.schema({
      names: {
        issuer: {
          names: {
            blockName: ISSUER
          }
        },
        serialNumber: SERIAL_NUMBER$2
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.issuer = new RelativeDistinguishedNames({ schema: asn1.result.issuer });
    this.serialNumber = asn1.result.serialNumber;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.issuer.toSchema(),
        this.serialNumber
      ]
    });
  }
  toJSON() {
    return {
      issuer: this.issuer.toJSON(),
      serialNumber: this.serialNumber.toJSON()
    };
  }
};
IssuerAndSerialNumber.CLASS_NAME = "IssuerAndSerialNumber";
var VARIANT$3 = "variant";
var VALUE$3 = "value";
var CLEAR_PROPS$B = [
  "blockName"
];
var RecipientIdentifier = class _RecipientIdentifier extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.variant = getParametersValue(parameters, VARIANT$3, _RecipientIdentifier.defaultValues(VARIANT$3));
    if (VALUE$3 in parameters) {
      this.value = getParametersValue(parameters, VALUE$3, _RecipientIdentifier.defaultValues(VALUE$3));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VARIANT$3:
        return -1;
      case VALUE$3:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VARIANT$3:
        return memberValue === -1;
      case VALUE$3:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Choice({
      value: [
        IssuerAndSerialNumber.schema({
          names: {
            blockName: names.blockName || EMPTY_STRING
          }
        }),
        new asn1js.Primitive({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$B);
    const asn1 = asn1js.compareSchema(schema, schema, _RecipientIdentifier.schema({
      names: {
        blockName: "blockName"
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (asn1.result.blockName.idBlock.tagClass === 1) {
      this.variant = 1;
      this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
    } else {
      this.variant = 2;
      this.value = new asn1js.OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });
    }
  }
  toSchema() {
    switch (this.variant) {
      case 1:
        if (!(this.value instanceof IssuerAndSerialNumber)) {
          throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");
        }
        return this.value.toSchema();
      case 2:
        if (!(this.value instanceof asn1js.OctetString)) {
          throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");
        }
        return new asn1js.Primitive({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          valueHex: this.value.valueBlock.valueHexView
        });
      default:
        return new asn1js.Any();
    }
  }
  toJSON() {
    const res = {
      variant: this.variant
    };
    if ((this.variant === 1 || this.variant === 2) && this.value) {
      res.value = this.value.toJSON();
    }
    return res;
  }
};
RecipientIdentifier.CLASS_NAME = "RecipientIdentifier";
var VERSION$c = "version";
var RID$1 = "rid";
var KEY_ENCRYPTION_ALGORITHM$3 = "keyEncryptionAlgorithm";
var ENCRYPTED_KEY$3 = "encryptedKey";
var RECIPIENT_CERTIFICATE$1 = "recipientCertificate";
var CLEAR_PROPS$A = [
  VERSION$c,
  RID$1,
  KEY_ENCRYPTION_ALGORITHM$3,
  ENCRYPTED_KEY$3
];
var KeyTransRecipientInfo = class _KeyTransRecipientInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$c, _KeyTransRecipientInfo.defaultValues(VERSION$c));
    this.rid = getParametersValue(parameters, RID$1, _KeyTransRecipientInfo.defaultValues(RID$1));
    this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$3, _KeyTransRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$3));
    this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$3, _KeyTransRecipientInfo.defaultValues(ENCRYPTED_KEY$3));
    this.recipientCertificate = getParametersValue(parameters, RECIPIENT_CERTIFICATE$1, _KeyTransRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE$1));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$c:
        return -1;
      case RID$1:
        return {};
      case KEY_ENCRYPTION_ALGORITHM$3:
        return new AlgorithmIdentifier();
      case ENCRYPTED_KEY$3:
        return new asn1js.OctetString();
      case RECIPIENT_CERTIFICATE$1:
        return new Certificate();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$c:
        return memberValue === _KeyTransRecipientInfo.defaultValues(VERSION$c);
      case RID$1:
        return Object.keys(memberValue).length === 0;
      case KEY_ENCRYPTION_ALGORITHM$3:
      case ENCRYPTED_KEY$3:
        return memberValue.isEqual(_KeyTransRecipientInfo.defaultValues(memberName));
      case RECIPIENT_CERTIFICATE$1:
        return false;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        RecipientIdentifier.schema(names.rid || {}),
        AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
        new asn1js.OctetString({ name: names.encryptedKey || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$A);
    const asn1 = asn1js.compareSchema(schema, schema, _KeyTransRecipientInfo.schema({
      names: {
        version: VERSION$c,
        rid: {
          names: {
            blockName: RID$1
          }
        },
        keyEncryptionAlgorithm: {
          names: {
            blockName: KEY_ENCRYPTION_ALGORITHM$3
          }
        },
        encryptedKey: ENCRYPTED_KEY$3
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    if (asn1.result.rid.idBlock.tagClass === 3) {
      this.rid = new asn1js.OctetString({ valueHex: asn1.result.rid.valueBlock.valueHex });
    } else {
      this.rid = new IssuerAndSerialNumber({ schema: asn1.result.rid });
    }
    this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
    this.encryptedKey = asn1.result.encryptedKey;
  }
  toSchema() {
    const outputArray = [];
    if (this.rid instanceof IssuerAndSerialNumber) {
      this.version = 0;
      outputArray.push(new asn1js.Integer({ value: this.version }));
      outputArray.push(this.rid.toSchema());
    } else {
      this.version = 2;
      outputArray.push(new asn1js.Integer({ value: this.version }));
      outputArray.push(new asn1js.Primitive({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        valueHex: this.rid.valueBlock.valueHexView
      }));
    }
    outputArray.push(this.keyEncryptionAlgorithm.toSchema());
    outputArray.push(this.encryptedKey);
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    return {
      version: this.version,
      rid: this.rid.toJSON(),
      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
      encryptedKey: this.encryptedKey.toJSON()
    };
  }
};
KeyTransRecipientInfo.CLASS_NAME = "KeyTransRecipientInfo";
var ALGORITHM = "algorithm";
var PUBLIC_KEY = "publicKey";
var CLEAR_PROPS$z = [
  ALGORITHM,
  PUBLIC_KEY
];
var OriginatorPublicKey = class _OriginatorPublicKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.algorithm = getParametersValue(parameters, ALGORITHM, _OriginatorPublicKey.defaultValues(ALGORITHM));
    this.publicKey = getParametersValue(parameters, PUBLIC_KEY, _OriginatorPublicKey.defaultValues(PUBLIC_KEY));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ALGORITHM:
        return new AlgorithmIdentifier();
      case PUBLIC_KEY:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case ALGORITHM:
      case PUBLIC_KEY:
        return memberValue.isEqual(_OriginatorPublicKey.defaultValues(memberName));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.algorithm || {}),
        new asn1js.BitString({ name: names.publicKey || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$z);
    const asn1 = asn1js.compareSchema(schema, schema, _OriginatorPublicKey.schema({
      names: {
        algorithm: {
          names: {
            blockName: ALGORITHM
          }
        },
        publicKey: PUBLIC_KEY
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });
    this.publicKey = asn1.result.publicKey;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.algorithm.toSchema(),
        this.publicKey
      ]
    });
  }
  toJSON() {
    return {
      algorithm: this.algorithm.toJSON(),
      publicKey: this.publicKey.toJSON()
    };
  }
};
OriginatorPublicKey.CLASS_NAME = "OriginatorPublicKey";
var VARIANT$2 = "variant";
var VALUE$2 = "value";
var CLEAR_PROPS$y = [
  "blockName"
];
var OriginatorIdentifierOrKey = class _OriginatorIdentifierOrKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.variant = getParametersValue(parameters, VARIANT$2, _OriginatorIdentifierOrKey.defaultValues(VARIANT$2));
    if (VALUE$2 in parameters) {
      this.value = getParametersValue(parameters, VALUE$2, _OriginatorIdentifierOrKey.defaultValues(VALUE$2));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VARIANT$2:
        return -1;
      case VALUE$2:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VARIANT$2:
        return memberValue === -1;
      case VALUE$2:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Choice({
      value: [
        IssuerAndSerialNumber.schema({
          names: {
            blockName: names.blockName || EMPTY_STRING
          }
        }),
        new asn1js.Primitive({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          name: names.blockName || EMPTY_STRING
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          name: names.blockName || EMPTY_STRING,
          value: OriginatorPublicKey.schema().valueBlock.value
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$y);
    const asn1 = asn1js.compareSchema(schema, schema, _OriginatorIdentifierOrKey.schema({
      names: {
        blockName: "blockName"
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (asn1.result.blockName.idBlock.tagClass === 1) {
      this.variant = 1;
      this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
    } else {
      if (asn1.result.blockName.idBlock.tagNumber === 0) {
        asn1.result.blockName.idBlock.tagClass = 1;
        asn1.result.blockName.idBlock.tagNumber = 4;
        this.variant = 2;
        this.value = asn1.result.blockName;
      } else {
        this.variant = 3;
        this.value = new OriginatorPublicKey({
          schema: new asn1js.Sequence({
            value: asn1.result.blockName.valueBlock.value
          })
        });
      }
    }
  }
  toSchema() {
    switch (this.variant) {
      case 1:
        return this.value.toSchema();
      case 2:
        this.value.idBlock.tagClass = 3;
        this.value.idBlock.tagNumber = 0;
        return this.value;
      case 3: {
        const _schema = this.value.toSchema();
        _schema.idBlock.tagClass = 3;
        _schema.idBlock.tagNumber = 1;
        return _schema;
      }
      default:
        return new asn1js.Any();
    }
  }
  toJSON() {
    const res = {
      variant: this.variant
    };
    if (this.variant === 1 || this.variant === 2 || this.variant === 3) {
      res.value = this.value.toJSON();
    }
    return res;
  }
};
OriginatorIdentifierOrKey.CLASS_NAME = "OriginatorIdentifierOrKey";
var KEY_ATTR_ID = "keyAttrId";
var KEY_ATTR = "keyAttr";
var CLEAR_PROPS$x = [
  KEY_ATTR_ID,
  KEY_ATTR
];
var OtherKeyAttribute = class _OtherKeyAttribute extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.keyAttrId = getParametersValue(parameters, KEY_ATTR_ID, _OtherKeyAttribute.defaultValues(KEY_ATTR_ID));
    if (KEY_ATTR in parameters) {
      this.keyAttr = getParametersValue(parameters, KEY_ATTR, _OtherKeyAttribute.defaultValues(KEY_ATTR));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case KEY_ATTR_ID:
        return EMPTY_STRING;
      case KEY_ATTR:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case KEY_ATTR_ID:
        return typeof memberValue === "string" && memberValue === EMPTY_STRING;
      case KEY_ATTR:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      optional: names.optional || true,
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.keyAttrId || EMPTY_STRING }),
        new asn1js.Any({
          optional: true,
          name: names.keyAttr || EMPTY_STRING
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$x);
    const asn1 = asn1js.compareSchema(schema, schema, _OtherKeyAttribute.schema({
      names: {
        keyAttrId: KEY_ATTR_ID,
        keyAttr: KEY_ATTR
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();
    if (KEY_ATTR in asn1.result) {
      this.keyAttr = asn1.result.keyAttr;
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.keyAttrId }));
    if (KEY_ATTR in this) {
      outputArray.push(this.keyAttr);
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      keyAttrId: this.keyAttrId
    };
    if (KEY_ATTR in this) {
      res.keyAttr = this.keyAttr.toJSON();
    }
    return res;
  }
};
OtherKeyAttribute.CLASS_NAME = "OtherKeyAttribute";
var SUBJECT_KEY_IDENTIFIER = "subjectKeyIdentifier";
var DATE$1 = "date";
var OTHER$1 = "other";
var CLEAR_PROPS$w = [
  SUBJECT_KEY_IDENTIFIER,
  DATE$1,
  OTHER$1
];
var RecipientKeyIdentifier = class _RecipientKeyIdentifier extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.subjectKeyIdentifier = getParametersValue(parameters, SUBJECT_KEY_IDENTIFIER, _RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
    if (DATE$1 in parameters) {
      this.date = getParametersValue(parameters, DATE$1, _RecipientKeyIdentifier.defaultValues(DATE$1));
    }
    if (OTHER$1 in parameters) {
      this.other = getParametersValue(parameters, OTHER$1, _RecipientKeyIdentifier.defaultValues(OTHER$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SUBJECT_KEY_IDENTIFIER:
        return new asn1js.OctetString();
      case DATE$1:
        return new asn1js.GeneralizedTime();
      case OTHER$1:
        return new OtherKeyAttribute();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case SUBJECT_KEY_IDENTIFIER:
        return memberValue.isEqual(_RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
      case DATE$1:
        return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
      case OTHER$1:
        return memberValue.keyAttrId === EMPTY_STRING && "keyAttr" in memberValue === false;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.OctetString({ name: names.subjectKeyIdentifier || EMPTY_STRING }),
        new asn1js.GeneralizedTime({
          optional: true,
          name: names.date || EMPTY_STRING
        }),
        OtherKeyAttribute.schema(names.other || {})
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$w);
    const asn1 = asn1js.compareSchema(schema, schema, _RecipientKeyIdentifier.schema({
      names: {
        subjectKeyIdentifier: SUBJECT_KEY_IDENTIFIER,
        date: DATE$1,
        other: {
          names: {
            blockName: OTHER$1
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;
    if (DATE$1 in asn1.result)
      this.date = asn1.result.date;
    if (OTHER$1 in asn1.result)
      this.other = new OtherKeyAttribute({ schema: asn1.result.other });
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.subjectKeyIdentifier);
    if (this.date) {
      outputArray.push(this.date);
    }
    if (this.other) {
      outputArray.push(this.other.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()
    };
    if (this.date) {
      res.date = this.date.toJSON();
    }
    if (this.other) {
      res.other = this.other.toJSON();
    }
    return res;
  }
};
RecipientKeyIdentifier.CLASS_NAME = "RecipientKeyIdentifier";
var VARIANT$1 = "variant";
var VALUE$1 = "value";
var CLEAR_PROPS$v = [
  "blockName"
];
var KeyAgreeRecipientIdentifier = class _KeyAgreeRecipientIdentifier extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.variant = getParametersValue(parameters, VARIANT$1, _KeyAgreeRecipientIdentifier.defaultValues(VARIANT$1));
    this.value = getParametersValue(parameters, VALUE$1, _KeyAgreeRecipientIdentifier.defaultValues(VALUE$1));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VARIANT$1:
        return -1;
      case VALUE$1:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VARIANT$1:
        return memberValue === -1;
      case VALUE$1:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Choice({
      value: [
        IssuerAndSerialNumber.schema(names.issuerAndSerialNumber || {
          names: {
            blockName: names.blockName || EMPTY_STRING
          }
        }),
        new asn1js.Constructed({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: RecipientKeyIdentifier.schema(names.rKeyId || {
            names: {
              blockName: names.blockName || EMPTY_STRING
            }
          }).valueBlock.value
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$v);
    const asn1 = asn1js.compareSchema(schema, schema, _KeyAgreeRecipientIdentifier.schema({
      names: {
        blockName: "blockName"
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (asn1.result.blockName.idBlock.tagClass === 1) {
      this.variant = 1;
      this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
    } else {
      this.variant = 2;
      this.value = new RecipientKeyIdentifier({
        schema: new asn1js.Sequence({
          value: asn1.result.blockName.valueBlock.value
        })
      });
    }
  }
  toSchema() {
    switch (this.variant) {
      case 1:
        return this.value.toSchema();
      case 2:
        return new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: this.value.toSchema().valueBlock.value
        });
      default:
        return new asn1js.Any();
    }
  }
  toJSON() {
    const res = {
      variant: this.variant
    };
    if (this.variant === 1 || this.variant === 2) {
      res.value = this.value.toJSON();
    }
    return res;
  }
};
KeyAgreeRecipientIdentifier.CLASS_NAME = "KeyAgreeRecipientIdentifier";
var RID = "rid";
var ENCRYPTED_KEY$2 = "encryptedKey";
var CLEAR_PROPS$u = [
  RID,
  ENCRYPTED_KEY$2
];
var RecipientEncryptedKey = class _RecipientEncryptedKey extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.rid = getParametersValue(parameters, RID, _RecipientEncryptedKey.defaultValues(RID));
    this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$2, _RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case RID:
        return new KeyAgreeRecipientIdentifier();
      case ENCRYPTED_KEY$2:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case RID:
        return memberValue.variant === -1 && "value" in memberValue === false;
      case ENCRYPTED_KEY$2:
        return memberValue.isEqual(_RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        KeyAgreeRecipientIdentifier.schema(names.rid || {}),
        new asn1js.OctetString({ name: names.encryptedKey || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$u);
    const asn1 = asn1js.compareSchema(schema, schema, _RecipientEncryptedKey.schema({
      names: {
        rid: {
          names: {
            blockName: RID
          }
        },
        encryptedKey: ENCRYPTED_KEY$2
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.rid = new KeyAgreeRecipientIdentifier({ schema: asn1.result.rid });
    this.encryptedKey = asn1.result.encryptedKey;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.rid.toSchema(),
        this.encryptedKey
      ]
    });
  }
  toJSON() {
    return {
      rid: this.rid.toJSON(),
      encryptedKey: this.encryptedKey.toJSON()
    };
  }
};
RecipientEncryptedKey.CLASS_NAME = "RecipientEncryptedKey";
var ENCRYPTED_KEYS = "encryptedKeys";
var RECIPIENT_ENCRYPTED_KEYS = "RecipientEncryptedKeys";
var CLEAR_PROPS$t = [
  RECIPIENT_ENCRYPTED_KEYS
];
var RecipientEncryptedKeys = class _RecipientEncryptedKeys extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.encryptedKeys = getParametersValue(parameters, ENCRYPTED_KEYS, _RecipientEncryptedKeys.defaultValues(ENCRYPTED_KEYS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ENCRYPTED_KEYS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case ENCRYPTED_KEYS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.RecipientEncryptedKeys || EMPTY_STRING,
          value: RecipientEncryptedKey.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$t);
    const asn1 = asn1js.compareSchema(schema, schema, _RecipientEncryptedKeys.schema({
      names: {
        RecipientEncryptedKeys: RECIPIENT_ENCRYPTED_KEYS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, (element) => new RecipientEncryptedKey({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.encryptedKeys, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      encryptedKeys: Array.from(this.encryptedKeys, (o) => o.toJSON())
    };
  }
};
RecipientEncryptedKeys.CLASS_NAME = "RecipientEncryptedKeys";
var VERSION$b = "version";
var ORIGINATOR = "originator";
var UKM = "ukm";
var KEY_ENCRYPTION_ALGORITHM$2 = "keyEncryptionAlgorithm";
var RECIPIENT_ENCRYPTED_KEY = "recipientEncryptedKeys";
var RECIPIENT_CERTIFICATE = "recipientCertificate";
var RECIPIENT_PUBLIC_KEY = "recipientPublicKey";
var CLEAR_PROPS$s = [
  VERSION$b,
  ORIGINATOR,
  UKM,
  KEY_ENCRYPTION_ALGORITHM$2,
  RECIPIENT_ENCRYPTED_KEY
];
var KeyAgreeRecipientInfo = class _KeyAgreeRecipientInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$b, _KeyAgreeRecipientInfo.defaultValues(VERSION$b));
    this.originator = getParametersValue(parameters, ORIGINATOR, _KeyAgreeRecipientInfo.defaultValues(ORIGINATOR));
    if (UKM in parameters) {
      this.ukm = getParametersValue(parameters, UKM, _KeyAgreeRecipientInfo.defaultValues(UKM));
    }
    this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$2, _KeyAgreeRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$2));
    this.recipientEncryptedKeys = getParametersValue(parameters, RECIPIENT_ENCRYPTED_KEY, _KeyAgreeRecipientInfo.defaultValues(RECIPIENT_ENCRYPTED_KEY));
    this.recipientCertificate = getParametersValue(parameters, RECIPIENT_CERTIFICATE, _KeyAgreeRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE));
    this.recipientPublicKey = getParametersValue(parameters, RECIPIENT_PUBLIC_KEY, _KeyAgreeRecipientInfo.defaultValues(RECIPIENT_PUBLIC_KEY));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$b:
        return 0;
      case ORIGINATOR:
        return new OriginatorIdentifierOrKey();
      case UKM:
        return new asn1js.OctetString();
      case KEY_ENCRYPTION_ALGORITHM$2:
        return new AlgorithmIdentifier();
      case RECIPIENT_ENCRYPTED_KEY:
        return new RecipientEncryptedKeys();
      case RECIPIENT_CERTIFICATE:
        return new Certificate();
      case RECIPIENT_PUBLIC_KEY:
        return null;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$b:
        return memberValue === 0;
      case ORIGINATOR:
        return memberValue.variant === -1 && "value" in memberValue === false;
      case UKM:
        return memberValue.isEqual(_KeyAgreeRecipientInfo.defaultValues(UKM));
      case KEY_ENCRYPTION_ALGORITHM$2:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case RECIPIENT_ENCRYPTED_KEY:
        return memberValue.encryptedKeys.length === 0;
      case RECIPIENT_CERTIFICATE:
        return false;
      case RECIPIENT_PUBLIC_KEY:
        return false;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            OriginatorIdentifierOrKey.schema(names.originator || {})
          ]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [new asn1js.OctetString({ name: names.ukm || EMPTY_STRING })]
        }),
        AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
        RecipientEncryptedKeys.schema(names.recipientEncryptedKeys || {})
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$s);
    const asn1 = asn1js.compareSchema(schema, schema, _KeyAgreeRecipientInfo.schema({
      names: {
        version: VERSION$b,
        originator: {
          names: {
            blockName: ORIGINATOR
          }
        },
        ukm: UKM,
        keyEncryptionAlgorithm: {
          names: {
            blockName: KEY_ENCRYPTION_ALGORITHM$2
          }
        },
        recipientEncryptedKeys: {
          names: {
            blockName: RECIPIENT_ENCRYPTED_KEY
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.originator = new OriginatorIdentifierOrKey({ schema: asn1.result.originator });
    if (UKM in asn1.result)
      this.ukm = asn1.result.ukm;
    this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
    this.recipientEncryptedKeys = new RecipientEncryptedKeys({ schema: asn1.result.recipientEncryptedKeys });
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    outputArray.push(new asn1js.Constructed({
      idBlock: {
        tagClass: 3,
        tagNumber: 0
      },
      value: [this.originator.toSchema()]
    }));
    if (this.ukm) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [this.ukm]
      }));
    }
    outputArray.push(this.keyEncryptionAlgorithm.toSchema());
    outputArray.push(this.recipientEncryptedKeys.toSchema());
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      originator: this.originator.toJSON(),
      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
      recipientEncryptedKeys: this.recipientEncryptedKeys.toJSON()
    };
    if (this.ukm) {
      res.ukm = this.ukm.toJSON();
    }
    return res;
  }
};
KeyAgreeRecipientInfo.CLASS_NAME = "KeyAgreeRecipientInfo";
var KEY_IDENTIFIER = "keyIdentifier";
var DATE = "date";
var OTHER = "other";
var CLEAR_PROPS$r = [
  KEY_IDENTIFIER,
  DATE,
  OTHER
];
var KEKIdentifier = class _KEKIdentifier extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.keyIdentifier = getParametersValue(parameters, KEY_IDENTIFIER, _KEKIdentifier.defaultValues(KEY_IDENTIFIER));
    if (DATE in parameters) {
      this.date = getParametersValue(parameters, DATE, _KEKIdentifier.defaultValues(DATE));
    }
    if (OTHER in parameters) {
      this.other = getParametersValue(parameters, OTHER, _KEKIdentifier.defaultValues(OTHER));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case KEY_IDENTIFIER:
        return new asn1js.OctetString();
      case DATE:
        return new asn1js.GeneralizedTime();
      case OTHER:
        return new OtherKeyAttribute();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case KEY_IDENTIFIER:
        return memberValue.isEqual(_KEKIdentifier.defaultValues(KEY_IDENTIFIER));
      case DATE:
        return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
      case OTHER:
        return memberValue.compareWithDefault("keyAttrId", memberValue.keyAttrId) && "keyAttr" in memberValue === false;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.OctetString({ name: names.keyIdentifier || EMPTY_STRING }),
        new asn1js.GeneralizedTime({
          optional: true,
          name: names.date || EMPTY_STRING
        }),
        OtherKeyAttribute.schema(names.other || {})
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$r);
    const asn1 = asn1js.compareSchema(schema, schema, _KEKIdentifier.schema({
      names: {
        keyIdentifier: KEY_IDENTIFIER,
        date: DATE,
        other: {
          names: {
            blockName: OTHER
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.keyIdentifier = asn1.result.keyIdentifier;
    if (DATE in asn1.result)
      this.date = asn1.result.date;
    if (OTHER in asn1.result)
      this.other = new OtherKeyAttribute({ schema: asn1.result.other });
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.keyIdentifier);
    if (this.date) {
      outputArray.push(this.date);
    }
    if (this.other) {
      outputArray.push(this.other.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      keyIdentifier: this.keyIdentifier.toJSON()
    };
    if (this.date) {
      res.date = this.date;
    }
    if (this.other) {
      res.other = this.other.toJSON();
    }
    return res;
  }
};
KEKIdentifier.CLASS_NAME = "KEKIdentifier";
var VERSION$a = "version";
var KEK_ID = "kekid";
var KEY_ENCRYPTION_ALGORITHM$1 = "keyEncryptionAlgorithm";
var ENCRYPTED_KEY$1 = "encryptedKey";
var PER_DEFINED_KEK = "preDefinedKEK";
var CLEAR_PROPS$q = [
  VERSION$a,
  KEK_ID,
  KEY_ENCRYPTION_ALGORITHM$1,
  ENCRYPTED_KEY$1
];
var KEKRecipientInfo = class _KEKRecipientInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$a, _KEKRecipientInfo.defaultValues(VERSION$a));
    this.kekid = getParametersValue(parameters, KEK_ID, _KEKRecipientInfo.defaultValues(KEK_ID));
    this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$1, _KEKRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$1));
    this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$1, _KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
    this.preDefinedKEK = getParametersValue(parameters, PER_DEFINED_KEK, _KEKRecipientInfo.defaultValues(PER_DEFINED_KEK));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$a:
        return 0;
      case KEK_ID:
        return new KEKIdentifier();
      case KEY_ENCRYPTION_ALGORITHM$1:
        return new AlgorithmIdentifier();
      case ENCRYPTED_KEY$1:
        return new asn1js.OctetString();
      case PER_DEFINED_KEK:
        return EMPTY_BUFFER;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case "KEKRecipientInfo":
        return memberValue === _KEKRecipientInfo.defaultValues(VERSION$a);
      case KEK_ID:
        return memberValue.compareWithDefault("keyIdentifier", memberValue.keyIdentifier) && "date" in memberValue === false && "other" in memberValue === false;
      case KEY_ENCRYPTION_ALGORITHM$1:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case ENCRYPTED_KEY$1:
        return memberValue.isEqual(_KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
      case PER_DEFINED_KEK:
        return memberValue.byteLength === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        KEKIdentifier.schema(names.kekid || {}),
        AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
        new asn1js.OctetString({ name: names.encryptedKey || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$q);
    const asn1 = asn1js.compareSchema(schema, schema, _KEKRecipientInfo.schema({
      names: {
        version: VERSION$a,
        kekid: {
          names: {
            blockName: KEK_ID
          }
        },
        keyEncryptionAlgorithm: {
          names: {
            blockName: KEY_ENCRYPTION_ALGORITHM$1
          }
        },
        encryptedKey: ENCRYPTED_KEY$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.kekid = new KEKIdentifier({ schema: asn1.result.kekid });
    this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
    this.encryptedKey = asn1.result.encryptedKey;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.Integer({ value: this.version }),
        this.kekid.toSchema(),
        this.keyEncryptionAlgorithm.toSchema(),
        this.encryptedKey
      ]
    });
  }
  toJSON() {
    return {
      version: this.version,
      kekid: this.kekid.toJSON(),
      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
      encryptedKey: this.encryptedKey.toJSON()
    };
  }
};
KEKRecipientInfo.CLASS_NAME = "KEKRecipientInfo";
var VERSION$9 = "version";
var KEY_DERIVATION_ALGORITHM = "keyDerivationAlgorithm";
var KEY_ENCRYPTION_ALGORITHM = "keyEncryptionAlgorithm";
var ENCRYPTED_KEY = "encryptedKey";
var PASSWORD = "password";
var CLEAR_PROPS$p = [
  VERSION$9,
  KEY_DERIVATION_ALGORITHM,
  KEY_ENCRYPTION_ALGORITHM,
  ENCRYPTED_KEY
];
var PasswordRecipientinfo = class _PasswordRecipientinfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$9, _PasswordRecipientinfo.defaultValues(VERSION$9));
    if (KEY_DERIVATION_ALGORITHM in parameters) {
      this.keyDerivationAlgorithm = getParametersValue(parameters, KEY_DERIVATION_ALGORITHM, _PasswordRecipientinfo.defaultValues(KEY_DERIVATION_ALGORITHM));
    }
    this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM, _PasswordRecipientinfo.defaultValues(KEY_ENCRYPTION_ALGORITHM));
    this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY, _PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
    this.password = getParametersValue(parameters, PASSWORD, _PasswordRecipientinfo.defaultValues(PASSWORD));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$9:
        return -1;
      case KEY_DERIVATION_ALGORITHM:
        return new AlgorithmIdentifier();
      case KEY_ENCRYPTION_ALGORITHM:
        return new AlgorithmIdentifier();
      case ENCRYPTED_KEY:
        return new asn1js.OctetString();
      case PASSWORD:
        return EMPTY_BUFFER;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$9:
        return memberValue === -1;
      case KEY_DERIVATION_ALGORITHM:
      case KEY_ENCRYPTION_ALGORITHM:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case ENCRYPTED_KEY:
        return memberValue.isEqual(_PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
      case PASSWORD:
        return memberValue.byteLength === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        new asn1js.Constructed({
          name: names.keyDerivationAlgorithm || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: AlgorithmIdentifier.schema().valueBlock.value
        }),
        AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
        new asn1js.OctetString({ name: names.encryptedKey || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$p);
    const asn1 = asn1js.compareSchema(schema, schema, _PasswordRecipientinfo.schema({
      names: {
        version: VERSION$9,
        keyDerivationAlgorithm: KEY_DERIVATION_ALGORITHM,
        keyEncryptionAlgorithm: {
          names: {
            blockName: KEY_ENCRYPTION_ALGORITHM
          }
        },
        encryptedKey: ENCRYPTED_KEY
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    if (KEY_DERIVATION_ALGORITHM in asn1.result) {
      this.keyDerivationAlgorithm = new AlgorithmIdentifier({
        schema: new asn1js.Sequence({
          value: asn1.result.keyDerivationAlgorithm.valueBlock.value
        })
      });
    }
    this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
    this.encryptedKey = asn1.result.encryptedKey;
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    if (this.keyDerivationAlgorithm) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: this.keyDerivationAlgorithm.toSchema().valueBlock.value
      }));
    }
    outputArray.push(this.keyEncryptionAlgorithm.toSchema());
    outputArray.push(this.encryptedKey);
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
      encryptedKey: this.encryptedKey.toJSON()
    };
    if (this.keyDerivationAlgorithm) {
      res.keyDerivationAlgorithm = this.keyDerivationAlgorithm.toJSON();
    }
    return res;
  }
};
PasswordRecipientinfo.CLASS_NAME = "PasswordRecipientInfo";
var ORI_TYPE = "oriType";
var ORI_VALUE = "oriValue";
var CLEAR_PROPS$o = [
  ORI_TYPE,
  ORI_VALUE
];
var OtherRecipientInfo = class _OtherRecipientInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.oriType = getParametersValue(parameters, ORI_TYPE, _OtherRecipientInfo.defaultValues(ORI_TYPE));
    this.oriValue = getParametersValue(parameters, ORI_VALUE, _OtherRecipientInfo.defaultValues(ORI_VALUE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case ORI_TYPE:
        return EMPTY_STRING;
      case ORI_VALUE:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case ORI_TYPE:
        return memberValue === EMPTY_STRING;
      case ORI_VALUE:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.oriType || EMPTY_STRING }),
        new asn1js.Any({ name: names.oriValue || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$o);
    const asn1 = asn1js.compareSchema(schema, schema, _OtherRecipientInfo.schema({
      names: {
        oriType: ORI_TYPE,
        oriValue: ORI_VALUE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.oriType = asn1.result.oriType.valueBlock.toString();
    this.oriValue = asn1.result.oriValue;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.oriType }),
        this.oriValue
      ]
    });
  }
  toJSON() {
    const res = {
      oriType: this.oriType
    };
    if (!_OtherRecipientInfo.compareWithDefault(ORI_VALUE, this.oriValue)) {
      res.oriValue = this.oriValue.toJSON();
    }
    return res;
  }
};
OtherRecipientInfo.CLASS_NAME = "OtherRecipientInfo";
var VARIANT = "variant";
var VALUE = "value";
var CLEAR_PROPS$n = [
  "blockName"
];
var RecipientInfo = class _RecipientInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.variant = getParametersValue(parameters, VARIANT, _RecipientInfo.defaultValues(VARIANT));
    if (VALUE in parameters) {
      this.value = getParametersValue(parameters, VALUE, _RecipientInfo.defaultValues(VALUE));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VARIANT:
        return -1;
      case VALUE:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VARIANT:
        return memberValue === _RecipientInfo.defaultValues(memberName);
      case VALUE:
        return Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Choice({
      value: [
        KeyTransRecipientInfo.schema({
          names: {
            blockName: names.blockName || EMPTY_STRING
          }
        }),
        new asn1js.Constructed({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: KeyAgreeRecipientInfo.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: KEKRecipientInfo.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 3
          },
          value: PasswordRecipientinfo.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          name: names.blockName || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 4
          },
          value: OtherRecipientInfo.schema().valueBlock.value
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$n);
    const asn1 = asn1js.compareSchema(schema, schema, _RecipientInfo.schema({
      names: {
        blockName: "blockName"
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (asn1.result.blockName.idBlock.tagClass === 1) {
      this.variant = 1;
      this.value = new KeyTransRecipientInfo({ schema: asn1.result.blockName });
    } else {
      const blockSequence = new asn1js.Sequence({
        value: asn1.result.blockName.valueBlock.value
      });
      switch (asn1.result.blockName.idBlock.tagNumber) {
        case 1:
          this.variant = 2;
          this.value = new KeyAgreeRecipientInfo({ schema: blockSequence });
          break;
        case 2:
          this.variant = 3;
          this.value = new KEKRecipientInfo({ schema: blockSequence });
          break;
        case 3:
          this.variant = 4;
          this.value = new PasswordRecipientinfo({ schema: blockSequence });
          break;
        case 4:
          this.variant = 5;
          this.value = new OtherRecipientInfo({ schema: blockSequence });
          break;
        default:
          throw new Error("Incorrect structure of RecipientInfo block");
      }
    }
  }
  toSchema() {
    ParameterError.assertEmpty(this.value, "value", "RecipientInfo");
    const _schema = this.value.toSchema();
    switch (this.variant) {
      case 1:
        return _schema;
      case 2:
      case 3:
      case 4:
        _schema.idBlock.tagClass = 3;
        _schema.idBlock.tagNumber = this.variant - 1;
        return _schema;
      default:
        return new asn1js.Any();
    }
  }
  toJSON() {
    const res = {
      variant: this.variant
    };
    if (this.value && this.variant >= 1 && this.variant <= 4) {
      res.value = this.value.toJSON();
    }
    return res;
  }
};
RecipientInfo.CLASS_NAME = "RecipientInfo";
var HASH_ALGORITHM$2 = "hashAlgorithm";
var MASK_GEN_ALGORITHM = "maskGenAlgorithm";
var P_SOURCE_ALGORITHM = "pSourceAlgorithm";
var CLEAR_PROPS$m = [
  HASH_ALGORITHM$2,
  MASK_GEN_ALGORITHM,
  P_SOURCE_ALGORITHM
];
var RSAESOAEPParams = class _RSAESOAEPParams extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$2, _RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2));
    this.maskGenAlgorithm = getParametersValue(parameters, MASK_GEN_ALGORITHM, _RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM));
    this.pSourceAlgorithm = getParametersValue(parameters, P_SOURCE_ALGORITHM, _RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case HASH_ALGORITHM$2:
        return new AlgorithmIdentifier({
          algorithmId: "1.3.14.3.2.26",
          algorithmParams: new asn1js.Null()
        });
      case MASK_GEN_ALGORITHM:
        return new AlgorithmIdentifier({
          algorithmId: "1.2.840.113549.1.1.8",
          algorithmParams: new AlgorithmIdentifier({
            algorithmId: "1.3.14.3.2.26",
            algorithmParams: new asn1js.Null()
          }).toSchema()
        });
      case P_SOURCE_ALGORITHM:
        return new AlgorithmIdentifier({
          algorithmId: "1.2.840.113549.1.1.9",
          algorithmParams: new asn1js.OctetString({ valueHex: new Uint8Array([218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24, 144, 175, 216, 7, 9]).buffer })
        });
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
        }),
        new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.pSourceAlgorithm || {})]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$m);
    const asn1 = asn1js.compareSchema(schema, schema, _RSAESOAEPParams.schema({
      names: {
        hashAlgorithm: {
          names: {
            blockName: HASH_ALGORITHM$2
          }
        },
        maskGenAlgorithm: {
          names: {
            blockName: MASK_GEN_ALGORITHM
          }
        },
        pSourceAlgorithm: {
          names: {
            blockName: P_SOURCE_ALGORITHM
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    if (HASH_ALGORITHM$2 in asn1.result)
      this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
    if (MASK_GEN_ALGORITHM in asn1.result)
      this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });
    if (P_SOURCE_ALGORITHM in asn1.result)
      this.pSourceAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.pSourceAlgorithm });
  }
  toSchema() {
    const outputArray = [];
    if (!this.hashAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [this.hashAlgorithm.toSchema()]
      }));
    }
    if (!this.maskGenAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: [this.maskGenAlgorithm.toSchema()]
      }));
    }
    if (!this.pSourceAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 2
        },
        value: [this.pSourceAlgorithm.toSchema()]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {};
    if (!this.hashAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
      res.hashAlgorithm = this.hashAlgorithm.toJSON();
    }
    if (!this.maskGenAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
      res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
    }
    if (!this.pSourceAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
      res.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();
    }
    return res;
  }
};
RSAESOAEPParams.CLASS_NAME = "RSAESOAEPParams";
var KEY_INFO = "keyInfo";
var ENTITY_U_INFO = "entityUInfo";
var SUPP_PUB_INFO = "suppPubInfo";
var CLEAR_PROPS$l = [
  KEY_INFO,
  ENTITY_U_INFO,
  SUPP_PUB_INFO
];
var ECCCMSSharedInfo = class _ECCCMSSharedInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.keyInfo = getParametersValue(parameters, KEY_INFO, _ECCCMSSharedInfo.defaultValues(KEY_INFO));
    if (ENTITY_U_INFO in parameters) {
      this.entityUInfo = getParametersValue(parameters, ENTITY_U_INFO, _ECCCMSSharedInfo.defaultValues(ENTITY_U_INFO));
    }
    this.suppPubInfo = getParametersValue(parameters, SUPP_PUB_INFO, _ECCCMSSharedInfo.defaultValues(SUPP_PUB_INFO));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case KEY_INFO:
        return new AlgorithmIdentifier();
      case ENTITY_U_INFO:
        return new asn1js.OctetString();
      case SUPP_PUB_INFO:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case KEY_INFO:
      case ENTITY_U_INFO:
      case SUPP_PUB_INFO:
        return memberValue.isEqual(_ECCCMSSharedInfo.defaultValues(memberName));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.keyInfo || {}),
        new asn1js.Constructed({
          name: names.entityUInfo || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          optional: true,
          value: [new asn1js.OctetString()]
        }),
        new asn1js.Constructed({
          name: names.suppPubInfo || EMPTY_STRING,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [new asn1js.OctetString()]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$l);
    const asn1 = asn1js.compareSchema(schema, schema, _ECCCMSSharedInfo.schema({
      names: {
        keyInfo: {
          names: {
            blockName: KEY_INFO
          }
        },
        entityUInfo: ENTITY_U_INFO,
        suppPubInfo: SUPP_PUB_INFO
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.keyInfo = new AlgorithmIdentifier({ schema: asn1.result.keyInfo });
    if (ENTITY_U_INFO in asn1.result)
      this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];
    this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0];
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.keyInfo.toSchema());
    if (this.entityUInfo) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [this.entityUInfo]
      }));
    }
    outputArray.push(new asn1js.Constructed({
      idBlock: {
        tagClass: 3,
        tagNumber: 2
      },
      value: [this.suppPubInfo]
    }));
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      keyInfo: this.keyInfo.toJSON(),
      suppPubInfo: this.suppPubInfo.toJSON()
    };
    if (this.entityUInfo) {
      res.entityUInfo = this.entityUInfo.toJSON();
    }
    return res;
  }
};
ECCCMSSharedInfo.CLASS_NAME = "ECCCMSSharedInfo";
var VERSION$8 = "version";
var ORIGINATOR_INFO = "originatorInfo";
var RECIPIENT_INFOS = "recipientInfos";
var ENCRYPTED_CONTENT_INFO = "encryptedContentInfo";
var UNPROTECTED_ATTRS = "unprotectedAttrs";
var CLEAR_PROPS$k = [
  VERSION$8,
  ORIGINATOR_INFO,
  RECIPIENT_INFOS,
  ENCRYPTED_CONTENT_INFO,
  UNPROTECTED_ATTRS
];
var defaultEncryptionParams = {
  kdfAlgorithm: "SHA-512",
  kekEncryptionLength: 256
};
var curveLengthByName = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 528
};
var EnvelopedData = class _EnvelopedData extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$8, _EnvelopedData.defaultValues(VERSION$8));
    if (ORIGINATOR_INFO in parameters) {
      this.originatorInfo = getParametersValue(parameters, ORIGINATOR_INFO, _EnvelopedData.defaultValues(ORIGINATOR_INFO));
    }
    this.recipientInfos = getParametersValue(parameters, RECIPIENT_INFOS, _EnvelopedData.defaultValues(RECIPIENT_INFOS));
    this.encryptedContentInfo = getParametersValue(parameters, ENCRYPTED_CONTENT_INFO, _EnvelopedData.defaultValues(ENCRYPTED_CONTENT_INFO));
    if (UNPROTECTED_ATTRS in parameters) {
      this.unprotectedAttrs = getParametersValue(parameters, UNPROTECTED_ATTRS, _EnvelopedData.defaultValues(UNPROTECTED_ATTRS));
    }
    this.policy = {
      disableSplit: !!parameters.disableSplit
    };
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$8:
        return 0;
      case ORIGINATOR_INFO:
        return new OriginatorInfo();
      case RECIPIENT_INFOS:
        return [];
      case ENCRYPTED_CONTENT_INFO:
        return new EncryptedContentInfo();
      case UNPROTECTED_ATTRS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$8:
        return memberValue === _EnvelopedData.defaultValues(memberName);
      case ORIGINATOR_INFO:
        return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;
      case RECIPIENT_INFOS:
      case UNPROTECTED_ATTRS:
        return memberValue.length === 0;
      case ENCRYPTED_CONTENT_INFO:
        return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && (EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || EMPTY_STRING }),
        new asn1js.Constructed({
          name: names.originatorInfo || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: OriginatorInfo.schema().valueBlock.value
        }),
        new asn1js.Set({
          value: [
            new asn1js.Repeated({
              name: names.recipientInfos || EMPTY_STRING,
              value: RecipientInfo.schema()
            })
          ]
        }),
        EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [
            new asn1js.Repeated({
              name: names.unprotectedAttrs || EMPTY_STRING,
              value: Attribute.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$k);
    const asn1 = asn1js.compareSchema(schema, schema, _EnvelopedData.schema({
      names: {
        version: VERSION$8,
        originatorInfo: ORIGINATOR_INFO,
        recipientInfos: RECIPIENT_INFOS,
        encryptedContentInfo: {
          names: {
            blockName: ENCRYPTED_CONTENT_INFO
          }
        },
        unprotectedAttrs: UNPROTECTED_ATTRS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    if (ORIGINATOR_INFO in asn1.result) {
      this.originatorInfo = new OriginatorInfo({
        schema: new asn1js.Sequence({
          value: asn1.result.originatorInfo.valueBlock.value
        })
      });
    }
    this.recipientInfos = Array.from(asn1.result.recipientInfos, (o) => new RecipientInfo({ schema: o }));
    this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
    if (UNPROTECTED_ATTRS in asn1.result)
      this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, (o) => new Attribute({ schema: o }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    if (this.originatorInfo) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: this.originatorInfo.toSchema().valueBlock.value
      }));
    }
    outputArray.push(new asn1js.Set({
      value: Array.from(this.recipientInfos, (o) => o.toSchema())
    }));
    outputArray.push(this.encryptedContentInfo.toSchema());
    if (this.unprotectedAttrs) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: Array.from(this.unprotectedAttrs, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      recipientInfos: Array.from(this.recipientInfos, (o) => o.toJSON()),
      encryptedContentInfo: this.encryptedContentInfo.toJSON()
    };
    if (this.originatorInfo)
      res.originatorInfo = this.originatorInfo.toJSON();
    if (this.unprotectedAttrs)
      res.unprotectedAttrs = Array.from(this.unprotectedAttrs, (o) => o.toJSON());
    return res;
  }
  addRecipientByCertificate(certificate, parameters, variant, crypto9 = getCrypto2(true)) {
    const encryptionParameters = Object.assign({ useOAEP: true, oaepHashAlgorithm: "SHA-512" }, defaultEncryptionParams, parameters || {});
    if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== -1)
      variant = 1;
    else {
      if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045") !== -1)
        variant = 2;
      else
        throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
    }
    switch (variant) {
      case 1:
        {
          let algorithmId;
          let algorithmParams;
          if (encryptionParameters.useOAEP === true) {
            algorithmId = crypto9.getOIDByAlgorithm({
              name: "RSA-OAEP"
            }, true, "keyEncryptionAlgorithm");
            const hashOID = crypto9.getOIDByAlgorithm({
              name: encryptionParameters.oaepHashAlgorithm
            }, true, "RSAES-OAEP-params");
            const hashAlgorithm = new AlgorithmIdentifier({
              algorithmId: hashOID,
              algorithmParams: new asn1js.Null()
            });
            const rsaOAEPParams = new RSAESOAEPParams({
              hashAlgorithm,
              maskGenAlgorithm: new AlgorithmIdentifier({
                algorithmId: "1.2.840.113549.1.1.8",
                algorithmParams: hashAlgorithm.toSchema()
              })
            });
            algorithmParams = rsaOAEPParams.toSchema();
          } else {
            algorithmId = crypto9.getOIDByAlgorithm({
              name: "RSAES-PKCS1-v1_5"
            });
            if (algorithmId === EMPTY_STRING)
              throw new Error("Can not find OID for RSAES-PKCS1-v1_5");
            algorithmParams = new asn1js.Null();
          }
          const keyInfo = new KeyTransRecipientInfo({
            version: 0,
            rid: new IssuerAndSerialNumber({
              issuer: certificate.issuer,
              serialNumber: certificate.serialNumber
            }),
            keyEncryptionAlgorithm: new AlgorithmIdentifier({
              algorithmId,
              algorithmParams
            }),
            recipientCertificate: certificate
          });
          this.recipientInfos.push(new RecipientInfo({
            variant: 1,
            value: keyInfo
          }));
        }
        break;
      case 2:
        {
          const recipientIdentifier = new KeyAgreeRecipientIdentifier({
            variant: 1,
            value: new IssuerAndSerialNumber({
              issuer: certificate.issuer,
              serialNumber: certificate.serialNumber
            })
          });
          this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, { recipientCertificate: certificate }, crypto9);
        }
        break;
      default:
        throw new Error(`Unknown "variant" value: ${variant}`);
    }
    return true;
  }
  addRecipientByPreDefinedData(preDefinedData, parameters = {}, variant, crypto9 = getCrypto2(true)) {
    ArgumentError.assert(preDefinedData, "preDefinedData", "ArrayBuffer");
    if (!preDefinedData.byteLength) {
      throw new Error("Pre-defined data could have zero length");
    }
    if (!parameters.keyIdentifier) {
      const keyIdentifierBuffer = new ArrayBuffer(16);
      const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
      crypto9.getRandomValues(keyIdentifierView);
      parameters.keyIdentifier = keyIdentifierBuffer;
    }
    if (!parameters.hmacHashAlgorithm)
      parameters.hmacHashAlgorithm = "SHA-512";
    if (parameters.iterationCount === void 0) {
      parameters.iterationCount = 2048;
    }
    if (!parameters.keyEncryptionAlgorithm) {
      parameters.keyEncryptionAlgorithm = {
        name: "AES-KW",
        length: 256
      };
    }
    if (!parameters.keyEncryptionAlgorithmParams)
      parameters.keyEncryptionAlgorithmParams = new asn1js.Null();
    switch (variant) {
      case 1:
        {
          const kekOID = crypto9.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
          const keyInfo = new KEKRecipientInfo({
            version: 4,
            kekid: new KEKIdentifier({
              keyIdentifier: new asn1js.OctetString({ valueHex: parameters.keyIdentifier })
            }),
            keyEncryptionAlgorithm: new AlgorithmIdentifier({
              algorithmId: kekOID,
              algorithmParams: parameters.keyEncryptionAlgorithmParams
            }),
            preDefinedKEK: preDefinedData
          });
          this.recipientInfos.push(new RecipientInfo({
            variant: 3,
            value: keyInfo
          }));
        }
        break;
      case 2:
        {
          const pbkdf2OID = crypto9.getOIDByAlgorithm({ name: "PBKDF2" }, true, "keyDerivationAlgorithm");
          const saltBuffer = new ArrayBuffer(64);
          const saltView = new Uint8Array(saltBuffer);
          crypto9.getRandomValues(saltView);
          const hmacOID = crypto9.getOIDByAlgorithm({
            name: "HMAC",
            hash: {
              name: parameters.hmacHashAlgorithm
            }
          }, true, "hmacHashAlgorithm");
          const pbkdf2Params = new PBKDF2Params({
            salt: new asn1js.OctetString({ valueHex: saltBuffer }),
            iterationCount: parameters.iterationCount,
            prf: new AlgorithmIdentifier({
              algorithmId: hmacOID,
              algorithmParams: new asn1js.Null()
            })
          });
          const kekOID = crypto9.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
          const keyInfo = new PasswordRecipientinfo({
            version: 0,
            keyDerivationAlgorithm: new AlgorithmIdentifier({
              algorithmId: pbkdf2OID,
              algorithmParams: pbkdf2Params.toSchema()
            }),
            keyEncryptionAlgorithm: new AlgorithmIdentifier({
              algorithmId: kekOID,
              algorithmParams: parameters.keyEncryptionAlgorithmParams
            }),
            password: preDefinedData
          });
          this.recipientInfos.push(new RecipientInfo({
            variant: 4,
            value: keyInfo
          }));
        }
        break;
      default:
        throw new Error(`Unknown value for "variant": ${variant}`);
    }
  }
  addRecipientByKeyIdentifier(key, keyId, parameters, crypto9 = getCrypto2(true)) {
    const encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});
    const recipientIdentifier = new KeyAgreeRecipientIdentifier({
      variant: 2,
      value: new RecipientKeyIdentifier({
        subjectKeyIdentifier: new asn1js.OctetString({ valueHex: keyId })
      })
    });
    this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, { recipientPublicKey: key }, crypto9);
  }
  _addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams, crypto9 = getCrypto2(true)) {
    const encryptedKey = new RecipientEncryptedKey({
      rid: recipientIdentifier
    });
    const aesKWoid = crypto9.getOIDByAlgorithm({
      name: "AES-KW",
      length: encryptionParameters.kekEncryptionLength
    }, true, "keyEncryptionAlgorithm");
    const aesKW = new AlgorithmIdentifier({
      algorithmId: aesKWoid
    });
    const ecdhOID = crypto9.getOIDByAlgorithm({
      name: "ECDH",
      kdf: encryptionParameters.kdfAlgorithm
    }, true, "KeyAgreeRecipientInfo");
    const ukmBuffer = new ArrayBuffer(64);
    const ukmView = new Uint8Array(ukmBuffer);
    crypto9.getRandomValues(ukmView);
    const recipientInfoParams = {
      version: 3,
      ukm: new asn1js.OctetString({ valueHex: ukmBuffer }),
      keyEncryptionAlgorithm: new AlgorithmIdentifier({
        algorithmId: ecdhOID,
        algorithmParams: aesKW.toSchema()
      }),
      recipientEncryptedKeys: new RecipientEncryptedKeys({
        encryptedKeys: [encryptedKey]
      })
    };
    const keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams));
    this.recipientInfos.push(new RecipientInfo({
      variant: 2,
      value: keyInfo
    }));
  }
  async encrypt(contentEncryptionAlgorithm, contentToEncrypt, crypto9 = getCrypto2(true)) {
    const ivBuffer = new ArrayBuffer(16);
    const ivView = new Uint8Array(ivBuffer);
    crypto9.getRandomValues(ivView);
    const contentView = new Uint8Array(contentToEncrypt);
    const contentEncryptionOID = crypto9.getOIDByAlgorithm(contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
    const sessionKey = await crypto9.generateKey(contentEncryptionAlgorithm, true, ["encrypt"]);
    const encryptedContent = await crypto9.encrypt({
      name: contentEncryptionAlgorithm.name,
      iv: ivView
    }, sessionKey, contentView);
    const exportedSessionKey = await crypto9.exportKey("raw", sessionKey);
    this.version = 2;
    this.encryptedContentInfo = new EncryptedContentInfo({
      disableSplit: this.policy.disableSplit,
      contentType: "1.2.840.113549.1.7.1",
      contentEncryptionAlgorithm: new AlgorithmIdentifier({
        algorithmId: contentEncryptionOID,
        algorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })
      }),
      encryptedContent: new asn1js.OctetString({ valueHex: encryptedContent })
    });
    const SubKeyAgreeRecipientInfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      let recipientCurve;
      let recipientPublicKey;
      if (recipientInfo.recipientPublicKey) {
        recipientCurve = recipientInfo.recipientPublicKey.algorithm.namedCurve;
        recipientPublicKey = recipientInfo.recipientPublicKey;
      } else if (recipientInfo.recipientCertificate) {
        const curveObject = recipientInfo.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
        if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName())
          throw new Error(`Incorrect "recipientCertificate" for index ${index}`);
        const curveOID = curveObject.valueBlock.toString();
        switch (curveOID) {
          case "1.2.840.10045.3.1.7":
            recipientCurve = "P-256";
            break;
          case "1.3.132.0.34":
            recipientCurve = "P-384";
            break;
          case "1.3.132.0.35":
            recipientCurve = "P-521";
            break;
          default:
            throw new Error(`Incorrect curve OID for index ${index}`);
        }
        recipientPublicKey = await recipientInfo.recipientCertificate.getPublicKey({
          algorithm: {
            algorithm: {
              name: "ECDH",
              namedCurve: recipientCurve
            },
            usages: []
          }
        }, crypto9);
      } else {
        throw new Error("Unsupported RecipientInfo");
      }
      const recipientCurveLength = curveLengthByName[recipientCurve];
      const ecdhKeys = await crypto9.generateKey({ name: "ECDH", namedCurve: recipientCurve }, true, ["deriveBits"]);
      const exportedECDHPublicKey = await crypto9.exportKey("spki", ecdhKeys.publicKey);
      const derivedBits = await crypto9.deriveBits({
        name: "ECDH",
        public: recipientPublicKey
      }, ecdhKeys.privateKey, recipientCurveLength);
      const aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams });
      const kwAlgorithm = crypto9.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "aesKWAlgorithm");
      let kwLength = kwAlgorithm.length;
      const kwLengthBuffer = new ArrayBuffer(4);
      const kwLengthView = new Uint8Array(kwLengthBuffer);
      for (let j = 3; j >= 0; j--) {
        kwLengthView[j] = kwLength;
        kwLength >>= 8;
      }
      const eccInfo = new ECCCMSSharedInfo({
        keyInfo: new AlgorithmIdentifier({
          algorithmId: aesKWAlgorithm.algorithmId
        }),
        entityUInfo: recipientInfo.ukm,
        suppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })
      });
      const encodedInfo = eccInfo.toSchema().toBER(false);
      const ecdhAlgorithm = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
      const derivedKeyRaw = await kdf(ecdhAlgorithm.kdf, derivedBits, kwAlgorithm.length, encodedInfo, crypto9);
      const awsKW = await crypto9.importKey("raw", derivedKeyRaw, { name: "AES-KW" }, true, ["wrapKey"]);
      const wrappedKey = await crypto9.wrapKey("raw", sessionKey, awsKW, { name: "AES-KW" });
      const originator = new OriginatorIdentifierOrKey();
      originator.variant = 3;
      originator.value = OriginatorPublicKey.fromBER(exportedECDHPublicKey);
      recipientInfo.originator = originator;
      recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({ valueHex: wrappedKey });
      return { ecdhPrivateKey: ecdhKeys.privateKey };
    };
    const SubKeyTransRecipientInfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      const algorithmParameters = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
      if (algorithmParameters.name === "RSA-OAEP") {
        const schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
        const rsaOAEPParams = new RSAESOAEPParams({ schema });
        algorithmParameters.hash = crypto9.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
        if ("name" in algorithmParameters.hash === false)
          throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
      }
      try {
        const publicKey = await recipientInfo.recipientCertificate.getPublicKey({
          algorithm: {
            algorithm: algorithmParameters,
            usages: ["encrypt", "wrapKey"]
          }
        }, crypto9);
        const encryptedKey = await crypto9.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);
        recipientInfo.encryptedKey = new asn1js.OctetString({ valueHex: encryptedKey });
      } catch {
      }
    };
    const SubKEKRecipientInfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      const kekAlgorithm = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
      const kekKey = await crypto9.importKey("raw", new Uint8Array(recipientInfo.preDefinedKEK), kekAlgorithm, true, ["wrapKey"]);
      const wrappedKey = await crypto9.wrapKey("raw", sessionKey, kekKey, kekAlgorithm);
      recipientInfo.encryptedKey = new asn1js.OctetString({ valueHex: wrappedKey });
    };
    const SubPasswordRecipientinfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      let pbkdf2Params;
      if (!recipientInfo.keyDerivationAlgorithm)
        throw new Error('Please append encoded "keyDerivationAlgorithm"');
      if (!recipientInfo.keyDerivationAlgorithm.algorithmParams)
        throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
      try {
        pbkdf2Params = new PBKDF2Params({ schema: recipientInfo.keyDerivationAlgorithm.algorithmParams });
      } catch (ex) {
        throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
      }
      const passwordView = new Uint8Array(recipientInfo.password);
      const derivationKey = await crypto9.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
      const kekAlgorithm = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
      let hmacHashAlgorithm = "SHA-1";
      if (pbkdf2Params.prf) {
        const prfAlgorithm = crypto9.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm");
        hmacHashAlgorithm = prfAlgorithm.hash.name;
      }
      const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
      const iterations = pbkdf2Params.iterationCount;
      const derivedKey = await crypto9.deriveKey({
        name: "PBKDF2",
        hash: {
          name: hmacHashAlgorithm
        },
        salt: saltView,
        iterations
      }, derivationKey, kekAlgorithm, true, ["wrapKey"]);
      const wrappedKey = await crypto9.wrapKey("raw", sessionKey, derivedKey, kekAlgorithm);
      recipientInfo.encryptedKey = new asn1js.OctetString({ valueHex: wrappedKey });
    };
    const res = [];
    for (let i2 = 0; i2 < this.recipientInfos.length; i2++) {
      switch (this.recipientInfos[i2].variant) {
        case 1:
          res.push(await SubKeyTransRecipientInfo(i2));
          break;
        case 2:
          res.push(await SubKeyAgreeRecipientInfo(i2));
          break;
        case 3:
          res.push(await SubKEKRecipientInfo(i2));
          break;
        case 4:
          res.push(await SubPasswordRecipientinfo(i2));
          break;
        default:
          throw new Error(`Unknown recipient type in array with index ${i2}`);
      }
    }
    return res;
  }
  async decrypt(recipientIndex, parameters, crypto9 = getCrypto2(true)) {
    const decryptionParameters = parameters || {};
    if (recipientIndex + 1 > this.recipientInfos.length) {
      throw new Error(`Maximum value for "index" is: ${this.recipientInfos.length - 1}`);
    }
    const SubKeyAgreeRecipientInfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      let curveOID;
      let recipientCurve;
      let recipientCurveLength;
      const originator = recipientInfo.originator;
      if (decryptionParameters.recipientCertificate) {
        const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
        if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {
          throw new Error(`Incorrect "recipientCertificate" for index ${index}`);
        }
        curveOID = curveObject.valueBlock.toString();
      } else if (originator.value.algorithm.algorithmParams) {
        const curveObject = originator.value.algorithm.algorithmParams;
        if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {
          throw new Error(`Incorrect originator for index ${index}`);
        }
        curveOID = curveObject.valueBlock.toString();
      } else {
        throw new Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');
      }
      if (!decryptionParameters.recipientPrivateKey)
        throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');
      switch (curveOID) {
        case "1.2.840.10045.3.1.7":
          recipientCurve = "P-256";
          recipientCurveLength = 256;
          break;
        case "1.3.132.0.34":
          recipientCurve = "P-384";
          recipientCurveLength = 384;
          break;
        case "1.3.132.0.35":
          recipientCurve = "P-521";
          recipientCurveLength = 528;
          break;
        default:
          throw new Error(`Incorrect curve OID for index ${index}`);
      }
      let ecdhPrivateKey;
      let keyCrypto = crypto9;
      if (BufferSourceConverter.isBufferSource(decryptionParameters.recipientPrivateKey)) {
        ecdhPrivateKey = await crypto9.importKey("pkcs8", decryptionParameters.recipientPrivateKey, {
          name: "ECDH",
          namedCurve: recipientCurve
        }, true, ["deriveBits"]);
      } else {
        ecdhPrivateKey = decryptionParameters.recipientPrivateKey;
        if ("crypto" in decryptionParameters && decryptionParameters.crypto) {
          keyCrypto = decryptionParameters.crypto.subtle;
        }
      }
      if ("algorithmParams" in originator.value.algorithm === false)
        originator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({ value: curveOID });
      const buffer2 = originator.value.toSchema().toBER(false);
      const ecdhPublicKey = await crypto9.importKey("spki", buffer2, {
        name: "ECDH",
        namedCurve: recipientCurve
      }, true, []);
      const sharedSecret = await keyCrypto.deriveBits({
        name: "ECDH",
        public: ecdhPublicKey
      }, ecdhPrivateKey, recipientCurveLength);
      async function applyKDF(includeAlgorithmParams) {
        includeAlgorithmParams = includeAlgorithmParams || false;
        const aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams });
        const kwAlgorithm = crypto9.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "kwAlgorithm");
        let kwLength = kwAlgorithm.length;
        const kwLengthBuffer = new ArrayBuffer(4);
        const kwLengthView = new Uint8Array(kwLengthBuffer);
        for (let j = 3; j >= 0; j--) {
          kwLengthView[j] = kwLength;
          kwLength >>= 8;
        }
        const keyInfoAlgorithm = {
          algorithmId: aesKWAlgorithm.algorithmId
        };
        if (includeAlgorithmParams) {
          keyInfoAlgorithm.algorithmParams = new asn1js.Null();
        }
        const eccInfo = new ECCCMSSharedInfo({
          keyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),
          entityUInfo: recipientInfo.ukm,
          suppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })
        });
        const encodedInfo = eccInfo.toSchema().toBER(false);
        const ecdhAlgorithm = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
        if (!ecdhAlgorithm.name) {
          throw new Error(`Incorrect OID for key encryption algorithm: ${recipientInfo.keyEncryptionAlgorithm.algorithmId}`);
        }
        return kdf(ecdhAlgorithm.kdf, sharedSecret, kwAlgorithm.length, encodedInfo, crypto9);
      }
      const kdfResult = await applyKDF();
      const importAesKwKey = async (kdfResult2) => {
        return crypto9.importKey("raw", kdfResult2, { name: "AES-KW" }, true, ["unwrapKey"]);
      };
      const aesKwKey = await importAesKwKey(kdfResult);
      const unwrapSessionKey = async (aesKwKey2) => {
        const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
        const contentEncryptionAlgorithm2 = crypto9.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
        return crypto9.unwrapKey("raw", recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView, aesKwKey2, { name: "AES-KW" }, contentEncryptionAlgorithm2, true, ["decrypt"]);
      };
      try {
        return await unwrapSessionKey(aesKwKey);
      } catch {
        const kdfResult2 = await applyKDF(true);
        const aesKwKey2 = await importAesKwKey(kdfResult2);
        return unwrapSessionKey(aesKwKey2);
      }
    };
    const SubKeyTransRecipientInfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      if (!decryptionParameters.recipientPrivateKey) {
        throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');
      }
      const algorithmParameters = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
      if (algorithmParameters.name === "RSA-OAEP") {
        const schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
        const rsaOAEPParams = new RSAESOAEPParams({ schema });
        algorithmParameters.hash = crypto9.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
        if ("name" in algorithmParameters.hash === false)
          throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
      }
      let privateKey;
      let keyCrypto = crypto9;
      if (BufferSourceConverter.isBufferSource(decryptionParameters.recipientPrivateKey)) {
        privateKey = await crypto9.importKey("pkcs8", decryptionParameters.recipientPrivateKey, algorithmParameters, true, ["decrypt"]);
      } else {
        privateKey = decryptionParameters.recipientPrivateKey;
        if ("crypto" in decryptionParameters && decryptionParameters.crypto) {
          keyCrypto = decryptionParameters.crypto.subtle;
        }
      }
      const sessionKey = await keyCrypto.decrypt(privateKey.algorithm, privateKey, recipientInfo.encryptedKey.valueBlock.valueHexView);
      const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
      const contentEncryptionAlgorithm2 = crypto9.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
      if ("name" in contentEncryptionAlgorithm2 === false)
        throw new Error(`Incorrect "contentEncryptionAlgorithm": ${algorithmId2}`);
      return crypto9.importKey("raw", sessionKey, contentEncryptionAlgorithm2, true, ["decrypt"]);
    };
    const SubKEKRecipientInfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      if (!decryptionParameters.preDefinedData)
        throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');
      const kekAlgorithm = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
      const importedKey = await crypto9.importKey("raw", decryptionParameters.preDefinedData, kekAlgorithm, true, ["unwrapKey"]);
      const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
      const contentEncryptionAlgorithm2 = crypto9.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
      if (!contentEncryptionAlgorithm2.name) {
        throw new Error(`Incorrect "contentEncryptionAlgorithm": ${algorithmId2}`);
      }
      return crypto9.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, importedKey, kekAlgorithm, contentEncryptionAlgorithm2, true, ["decrypt"]);
    };
    const SubPasswordRecipientinfo = async (index) => {
      const recipientInfo = this.recipientInfos[index].value;
      let pbkdf2Params;
      if (!decryptionParameters.preDefinedData) {
        throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');
      }
      if (!recipientInfo.keyDerivationAlgorithm) {
        throw new Error('Please append encoded "keyDerivationAlgorithm"');
      }
      if (!recipientInfo.keyDerivationAlgorithm.algorithmParams) {
        throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
      }
      try {
        pbkdf2Params = new PBKDF2Params({ schema: recipientInfo.keyDerivationAlgorithm.algorithmParams });
      } catch (ex) {
        throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
      }
      const pbkdf2Key = await crypto9.importKey("raw", decryptionParameters.preDefinedData, "PBKDF2", false, ["deriveKey"]);
      const kekAlgorithm = crypto9.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
      const hmacHashAlgorithm = pbkdf2Params.prf ? crypto9.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm").hash.name : "SHA-1";
      const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
      const iterations = pbkdf2Params.iterationCount;
      const kekKey = await crypto9.deriveKey({
        name: "PBKDF2",
        hash: {
          name: hmacHashAlgorithm
        },
        salt: saltView,
        iterations
      }, pbkdf2Key, kekAlgorithm, true, ["unwrapKey"]);
      const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
      const contentEncryptionAlgorithm2 = crypto9.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
      return crypto9.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, kekKey, kekAlgorithm, contentEncryptionAlgorithm2, true, ["decrypt"]);
    };
    let unwrappedKey;
    switch (this.recipientInfos[recipientIndex].variant) {
      case 1:
        unwrappedKey = await SubKeyTransRecipientInfo(recipientIndex);
        break;
      case 2:
        unwrappedKey = await SubKeyAgreeRecipientInfo(recipientIndex);
        break;
      case 3:
        unwrappedKey = await SubKEKRecipientInfo(recipientIndex);
        break;
      case 4:
        unwrappedKey = await SubPasswordRecipientinfo(recipientIndex);
        break;
      default:
        throw new Error(`Unknown recipient type in array with index ${recipientIndex}`);
    }
    const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
    const contentEncryptionAlgorithm = crypto9.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
    const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
    const ivView = new Uint8Array(ivBuffer);
    if (!this.encryptedContentInfo.encryptedContent) {
      throw new Error("Required property `encryptedContent` is empty");
    }
    const dataBuffer = this.encryptedContentInfo.getEncryptedContent();
    return crypto9.decrypt({
      name: contentEncryptionAlgorithm.name,
      iv: ivView
    }, unwrappedKey, dataBuffer);
  }
};
EnvelopedData.CLASS_NAME = "EnvelopedData";
var SAFE_CONTENTS = "safeContents";
var PARSED_VALUE$1 = "parsedValue";
var CONTENT_INFOS = "contentInfos";
var AuthenticatedSafe = class _AuthenticatedSafe extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.safeContents = getParametersValue(parameters, SAFE_CONTENTS, _AuthenticatedSafe.defaultValues(SAFE_CONTENTS));
    if (PARSED_VALUE$1 in parameters) {
      this.parsedValue = getParametersValue(parameters, PARSED_VALUE$1, _AuthenticatedSafe.defaultValues(PARSED_VALUE$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SAFE_CONTENTS:
        return [];
      case PARSED_VALUE$1:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case SAFE_CONTENTS:
        return memberValue.length === 0;
      case PARSED_VALUE$1:
        return memberValue instanceof Object && Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Repeated({
          name: names.contentInfos || EMPTY_STRING,
          value: ContentInfo.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      CONTENT_INFOS
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _AuthenticatedSafe.schema({
      names: {
        contentInfos: CONTENT_INFOS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.safeContents = Array.from(asn1.result.contentInfos, (element) => new ContentInfo({ schema: element }));
  }
  toSchema() {
    return new asn1js.Sequence({
      value: Array.from(this.safeContents, (o) => o.toSchema())
    });
  }
  toJSON() {
    return {
      safeContents: Array.from(this.safeContents, (o) => o.toJSON())
    };
  }
  async parseInternalValues(parameters, crypto9 = getCrypto2(true)) {
    ParameterError.assert(parameters, SAFE_CONTENTS);
    ArgumentError.assert(parameters.safeContents, SAFE_CONTENTS, "Array");
    if (parameters.safeContents.length !== this.safeContents.length) {
      throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');
    }
    this.parsedValue = {
      safeContents: []
    };
    for (const [index, content] of this.safeContents.entries()) {
      const safeContent = parameters.safeContents[index];
      const errorTarget = `parameters.safeContents[${index}]`;
      switch (content.contentType) {
        case id_ContentType_Data:
          {
            ArgumentError.assert(content.content, "this.safeContents[j].content", asn1js.OctetString);
            const authSafeContent = content.content.getValue();
            this.parsedValue.safeContents.push({
              privacyMode: 0,
              value: SafeContents.fromBER(authSafeContent)
            });
          }
          break;
        case id_ContentType_EnvelopedData:
          {
            const cmsEnveloped = new EnvelopedData({ schema: content.content });
            ParameterError.assert(errorTarget, safeContent, "recipientCertificate", "recipientKey");
            const envelopedData = safeContent;
            const recipientCertificate = envelopedData.recipientCertificate;
            const recipientKey = envelopedData.recipientKey;
            const decrypted = await cmsEnveloped.decrypt(0, {
              recipientCertificate,
              recipientPrivateKey: recipientKey
            }, crypto9);
            this.parsedValue.safeContents.push({
              privacyMode: 2,
              value: SafeContents.fromBER(decrypted)
            });
          }
          break;
        case id_ContentType_EncryptedData:
          {
            const cmsEncrypted = new EncryptedData({ schema: content.content });
            ParameterError.assert(errorTarget, safeContent, "password");
            const password = safeContent.password;
            const decrypted = await cmsEncrypted.decrypt({
              password
            }, crypto9);
            this.parsedValue.safeContents.push({
              privacyMode: 1,
              value: SafeContents.fromBER(decrypted)
            });
          }
          break;
        default:
          throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${content.contentType}`);
      }
    }
  }
  async makeInternalValues(parameters, crypto9 = getCrypto2(true)) {
    if (!this.parsedValue) {
      throw new Error('Please run "parseValues" first or add "parsedValue" manually');
    }
    ArgumentError.assert(this.parsedValue, "this.parsedValue", "object");
    ArgumentError.assert(this.parsedValue.safeContents, "this.parsedValue.safeContents", "Array");
    ArgumentError.assert(parameters, "parameters", "object");
    ParameterError.assert(parameters, "safeContents");
    ArgumentError.assert(parameters.safeContents, "parameters.safeContents", "Array");
    if (parameters.safeContents.length !== this.parsedValue.safeContents.length) {
      throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');
    }
    this.safeContents = [];
    for (const [index, content] of this.parsedValue.safeContents.entries()) {
      ParameterError.assert("content", content, "privacyMode", "value");
      ArgumentError.assert(content.value, "content.value", SafeContents);
      switch (content.privacyMode) {
        case 0:
          {
            const contentBuffer = content.value.toSchema().toBER(false);
            this.safeContents.push(new ContentInfo({
              contentType: "1.2.840.113549.1.7.1",
              content: new asn1js.OctetString({ valueHex: contentBuffer })
            }));
          }
          break;
        case 1:
          {
            const cmsEncrypted = new EncryptedData();
            const currentParameters = parameters.safeContents[index];
            currentParameters.contentToEncrypt = content.value.toSchema().toBER(false);
            await cmsEncrypted.encrypt(currentParameters, crypto9);
            this.safeContents.push(new ContentInfo({
              contentType: "1.2.840.113549.1.7.6",
              content: cmsEncrypted.toSchema()
            }));
          }
          break;
        case 2:
          {
            const cmsEnveloped = new EnvelopedData();
            const contentToEncrypt = content.value.toSchema().toBER(false);
            const safeContent = parameters.safeContents[index];
            ParameterError.assert(`parameters.safeContents[${index}]`, safeContent, "encryptingCertificate", "encryptionAlgorithm");
            switch (true) {
              case safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-cbc":
              case safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-gcm":
                break;
              default:
                throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${safeContent.encryptionAlgorithm}`);
            }
            switch (true) {
              case safeContent.encryptionAlgorithm.length === 128:
              case safeContent.encryptionAlgorithm.length === 192:
              case safeContent.encryptionAlgorithm.length === 256:
                break;
              default:
                throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${safeContent.encryptionAlgorithm.length}`);
            }
            const encryptionAlgorithm = safeContent.encryptionAlgorithm;
            cmsEnveloped.addRecipientByCertificate(safeContent.encryptingCertificate, {}, void 0, crypto9);
            await cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt, crypto9);
            this.safeContents.push(new ContentInfo({
              contentType: "1.2.840.113549.1.7.3",
              content: cmsEnveloped.toSchema()
            }));
          }
          break;
        default:
          throw new Error(`Incorrect value for "content.privacyMode": ${content.privacyMode}`);
      }
    }
    return this;
  }
};
AuthenticatedSafe.CLASS_NAME = "AuthenticatedSafe";
var HASH_ALGORITHM$1 = "hashAlgorithm";
var ISSUER_NAME_HASH = "issuerNameHash";
var ISSUER_KEY_HASH = "issuerKeyHash";
var SERIAL_NUMBER$1 = "serialNumber";
var CLEAR_PROPS$j = [
  HASH_ALGORITHM$1,
  ISSUER_NAME_HASH,
  ISSUER_KEY_HASH,
  SERIAL_NUMBER$1
];
var CertID = class _CertID extends PkiObject {
  static async create(certificate, parameters, crypto9 = getCrypto2(true)) {
    const certID = new _CertID();
    await certID.createForCertificate(certificate, parameters, crypto9);
    return certID;
  }
  constructor(parameters = {}) {
    super();
    this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$1, _CertID.defaultValues(HASH_ALGORITHM$1));
    this.issuerNameHash = getParametersValue(parameters, ISSUER_NAME_HASH, _CertID.defaultValues(ISSUER_NAME_HASH));
    this.issuerKeyHash = getParametersValue(parameters, ISSUER_KEY_HASH, _CertID.defaultValues(ISSUER_KEY_HASH));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$1, _CertID.defaultValues(SERIAL_NUMBER$1));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case HASH_ALGORITHM$1:
        return new AlgorithmIdentifier();
      case ISSUER_NAME_HASH:
      case ISSUER_KEY_HASH:
        return new asn1js.OctetString();
      case SERIAL_NUMBER$1:
        return new asn1js.Integer();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case HASH_ALGORITHM$1:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case ISSUER_NAME_HASH:
      case ISSUER_KEY_HASH:
      case SERIAL_NUMBER$1:
        return memberValue.isEqual(_CertID.defaultValues(SERIAL_NUMBER$1));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.hashAlgorithmObject || {
          names: {
            blockName: names.hashAlgorithm || EMPTY_STRING
          }
        }),
        new asn1js.OctetString({ name: names.issuerNameHash || EMPTY_STRING }),
        new asn1js.OctetString({ name: names.issuerKeyHash || EMPTY_STRING }),
        new asn1js.Integer({ name: names.serialNumber || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$j);
    const asn1 = asn1js.compareSchema(schema, schema, _CertID.schema({
      names: {
        hashAlgorithm: HASH_ALGORITHM$1,
        issuerNameHash: ISSUER_NAME_HASH,
        issuerKeyHash: ISSUER_KEY_HASH,
        serialNumber: SERIAL_NUMBER$1
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
    this.issuerNameHash = asn1.result.issuerNameHash;
    this.issuerKeyHash = asn1.result.issuerKeyHash;
    this.serialNumber = asn1.result.serialNumber;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.hashAlgorithm.toSchema(),
        this.issuerNameHash,
        this.issuerKeyHash,
        this.serialNumber
      ]
    });
  }
  toJSON() {
    return {
      hashAlgorithm: this.hashAlgorithm.toJSON(),
      issuerNameHash: this.issuerNameHash.toJSON(),
      issuerKeyHash: this.issuerKeyHash.toJSON(),
      serialNumber: this.serialNumber.toJSON()
    };
  }
  isEqual(certificateID) {
    if (this.hashAlgorithm.algorithmId !== certificateID.hashAlgorithm.algorithmId) {
      return false;
    }
    if (!BufferSourceConverter.isEqual(this.issuerNameHash.valueBlock.valueHexView, certificateID.issuerNameHash.valueBlock.valueHexView)) {
      return false;
    }
    if (!BufferSourceConverter.isEqual(this.issuerKeyHash.valueBlock.valueHexView, certificateID.issuerKeyHash.valueBlock.valueHexView)) {
      return false;
    }
    if (!this.serialNumber.isEqual(certificateID.serialNumber)) {
      return false;
    }
    return true;
  }
  async createForCertificate(certificate, parameters, crypto9 = getCrypto2(true)) {
    ParameterError.assert(parameters, HASH_ALGORITHM$1, "issuerCertificate");
    const hashOID = crypto9.getOIDByAlgorithm({ name: parameters.hashAlgorithm }, true, "hashAlgorithm");
    this.hashAlgorithm = new AlgorithmIdentifier({
      algorithmId: hashOID,
      algorithmParams: new asn1js.Null()
    });
    const issuerCertificate = parameters.issuerCertificate;
    this.serialNumber = certificate.serialNumber;
    const hashIssuerName = await crypto9.digest({ name: parameters.hashAlgorithm }, issuerCertificate.subject.toSchema().toBER(false));
    this.issuerNameHash = new asn1js.OctetString({ valueHex: hashIssuerName });
    const issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView;
    const hashIssuerKey = await crypto9.digest({ name: parameters.hashAlgorithm }, issuerKeyBuffer);
    this.issuerKeyHash = new asn1js.OctetString({ valueHex: hashIssuerKey });
  }
};
CertID.CLASS_NAME = "CertID";
var CERT_ID = "certID";
var CERT_STATUS = "certStatus";
var THIS_UPDATE = "thisUpdate";
var NEXT_UPDATE = "nextUpdate";
var SINGLE_EXTENSIONS = "singleExtensions";
var CLEAR_PROPS$i = [
  CERT_ID,
  CERT_STATUS,
  THIS_UPDATE,
  NEXT_UPDATE,
  SINGLE_EXTENSIONS
];
var SingleResponse = class _SingleResponse extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.certID = getParametersValue(parameters, CERT_ID, _SingleResponse.defaultValues(CERT_ID));
    this.certStatus = getParametersValue(parameters, CERT_STATUS, _SingleResponse.defaultValues(CERT_STATUS));
    this.thisUpdate = getParametersValue(parameters, THIS_UPDATE, _SingleResponse.defaultValues(THIS_UPDATE));
    if (NEXT_UPDATE in parameters) {
      this.nextUpdate = getParametersValue(parameters, NEXT_UPDATE, _SingleResponse.defaultValues(NEXT_UPDATE));
    }
    if (SINGLE_EXTENSIONS in parameters) {
      this.singleExtensions = getParametersValue(parameters, SINGLE_EXTENSIONS, _SingleResponse.defaultValues(SINGLE_EXTENSIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case CERT_ID:
        return new CertID();
      case CERT_STATUS:
        return {};
      case THIS_UPDATE:
      case NEXT_UPDATE:
        return new Date(0, 0, 0);
      case SINGLE_EXTENSIONS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case CERT_ID:
        return CertID.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && CertID.compareWithDefault("issuerNameHash", memberValue.issuerNameHash) && CertID.compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash) && CertID.compareWithDefault("serialNumber", memberValue.serialNumber);
      case CERT_STATUS:
        return Object.keys(memberValue).length === 0;
      case THIS_UPDATE:
      case NEXT_UPDATE:
        return memberValue === _SingleResponse.defaultValues(memberName);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        CertID.schema(names.certID || {}),
        new asn1js.Choice({
          value: [
            new asn1js.Primitive({
              name: names.certStatus || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            }),
            new asn1js.Constructed({
              name: names.certStatus || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js.GeneralizedTime(),
                new asn1js.Constructed({
                  optional: true,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [new asn1js.Enumerated()]
                })
              ]
            }),
            new asn1js.Primitive({
              name: names.certStatus || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              lenBlock: { length: 1 }
            })
          ]
        }),
        new asn1js.GeneralizedTime({ name: names.thisUpdate || EMPTY_STRING }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.GeneralizedTime({ name: names.nextUpdate || EMPTY_STRING })]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [Extensions.schema(names.singleExtensions || {})]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$i);
    const asn1 = asn1js.compareSchema(schema, schema, _SingleResponse.schema({
      names: {
        certID: {
          names: {
            blockName: CERT_ID
          }
        },
        certStatus: CERT_STATUS,
        thisUpdate: THIS_UPDATE,
        nextUpdate: NEXT_UPDATE,
        singleExtensions: {
          names: {
            blockName: SINGLE_EXTENSIONS
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.certID = new CertID({ schema: asn1.result.certID });
    this.certStatus = asn1.result.certStatus;
    this.thisUpdate = asn1.result.thisUpdate.toDate();
    if (NEXT_UPDATE in asn1.result)
      this.nextUpdate = asn1.result.nextUpdate.toDate();
    if (SINGLE_EXTENSIONS in asn1.result)
      this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, (element) => new Extension({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.certID.toSchema());
    outputArray.push(this.certStatus);
    outputArray.push(new asn1js.GeneralizedTime({ valueDate: this.thisUpdate }));
    if (this.nextUpdate) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [new asn1js.GeneralizedTime({ valueDate: this.nextUpdate })]
      }));
    }
    if (this.singleExtensions) {
      outputArray.push(new asn1js.Sequence({
        value: Array.from(this.singleExtensions, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      certID: this.certID.toJSON(),
      certStatus: this.certStatus.toJSON(),
      thisUpdate: this.thisUpdate
    };
    if (this.nextUpdate) {
      res.nextUpdate = this.nextUpdate;
    }
    if (this.singleExtensions) {
      res.singleExtensions = Array.from(this.singleExtensions, (o) => o.toJSON());
    }
    return res;
  }
};
SingleResponse.CLASS_NAME = "SingleResponse";
var TBS$2 = "tbs";
var VERSION$7 = "version";
var RESPONDER_ID = "responderID";
var PRODUCED_AT = "producedAt";
var RESPONSES = "responses";
var RESPONSE_EXTENSIONS = "responseExtensions";
var RESPONSE_DATA = "ResponseData";
var RESPONSE_DATA_VERSION = `${RESPONSE_DATA}.${VERSION$7}`;
var RESPONSE_DATA_RESPONDER_ID = `${RESPONSE_DATA}.${RESPONDER_ID}`;
var RESPONSE_DATA_PRODUCED_AT = `${RESPONSE_DATA}.${PRODUCED_AT}`;
var RESPONSE_DATA_RESPONSES = `${RESPONSE_DATA}.${RESPONSES}`;
var RESPONSE_DATA_RESPONSE_EXTENSIONS = `${RESPONSE_DATA}.${RESPONSE_EXTENSIONS}`;
var CLEAR_PROPS$h = [
  RESPONSE_DATA,
  RESPONSE_DATA_VERSION,
  RESPONSE_DATA_RESPONDER_ID,
  RESPONSE_DATA_PRODUCED_AT,
  RESPONSE_DATA_RESPONSES,
  RESPONSE_DATA_RESPONSE_EXTENSIONS
];
var ResponseData = class _ResponseData extends PkiObject {
  get tbs() {
    return BufferSourceConverter.toArrayBuffer(this.tbsView);
  }
  set tbs(value) {
    this.tbsView = new Uint8Array(value);
  }
  constructor(parameters = {}) {
    super();
    this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$2, _ResponseData.defaultValues(TBS$2)));
    if (VERSION$7 in parameters) {
      this.version = getParametersValue(parameters, VERSION$7, _ResponseData.defaultValues(VERSION$7));
    }
    this.responderID = getParametersValue(parameters, RESPONDER_ID, _ResponseData.defaultValues(RESPONDER_ID));
    this.producedAt = getParametersValue(parameters, PRODUCED_AT, _ResponseData.defaultValues(PRODUCED_AT));
    this.responses = getParametersValue(parameters, RESPONSES, _ResponseData.defaultValues(RESPONSES));
    if (RESPONSE_EXTENSIONS in parameters) {
      this.responseExtensions = getParametersValue(parameters, RESPONSE_EXTENSIONS, _ResponseData.defaultValues(RESPONSE_EXTENSIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$7:
        return 0;
      case TBS$2:
        return EMPTY_BUFFER;
      case RESPONDER_ID:
        return {};
      case PRODUCED_AT:
        return new Date(0, 0, 0);
      case RESPONSES:
      case RESPONSE_EXTENSIONS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TBS$2:
        return memberValue.byteLength === 0;
      case RESPONDER_ID:
        return Object.keys(memberValue).length === 0;
      case PRODUCED_AT:
        return memberValue === _ResponseData.defaultValues(memberName);
      case RESPONSES:
      case RESPONSE_EXTENSIONS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || RESPONSE_DATA,
      value: [
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Integer({ name: names.version || RESPONSE_DATA_VERSION })]
        }),
        new asn1js.Choice({
          value: [
            new asn1js.Constructed({
              name: names.responderID || RESPONSE_DATA_RESPONDER_ID,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [RelativeDistinguishedNames.schema(names.ResponseDataByName || {
                names: {
                  blockName: "ResponseData.byName"
                }
              })]
            }),
            new asn1js.Constructed({
              name: names.responderID || RESPONSE_DATA_RESPONDER_ID,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [new asn1js.OctetString({ name: names.ResponseDataByKey || "ResponseData.byKey" })]
            })
          ]
        }),
        new asn1js.GeneralizedTime({ name: names.producedAt || RESPONSE_DATA_PRODUCED_AT }),
        new asn1js.Sequence({
          value: [
            new asn1js.Repeated({
              name: RESPONSE_DATA_RESPONSES,
              value: SingleResponse.schema(names.response || {})
            })
          ]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [Extensions.schema(names.extensions || {
            names: {
              blockName: RESPONSE_DATA_RESPONSE_EXTENSIONS
            }
          })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$h);
    const asn1 = asn1js.compareSchema(schema, schema, _ResponseData.schema());
    AsnError.assertSchema(asn1, this.className);
    this.tbsView = asn1.result.ResponseData.valueBeforeDecodeView;
    if (RESPONSE_DATA_VERSION in asn1.result)
      this.version = asn1.result[RESPONSE_DATA_VERSION].valueBlock.valueDec;
    if (asn1.result[RESPONSE_DATA_RESPONDER_ID].idBlock.tagNumber === 1)
      this.responderID = new RelativeDistinguishedNames({ schema: asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0] });
    else
      this.responderID = asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0];
    this.producedAt = asn1.result[RESPONSE_DATA_PRODUCED_AT].toDate();
    this.responses = Array.from(asn1.result[RESPONSE_DATA_RESPONSES], (element) => new SingleResponse({ schema: element }));
    if (RESPONSE_DATA_RESPONSE_EXTENSIONS in asn1.result)
      this.responseExtensions = Array.from(asn1.result[RESPONSE_DATA_RESPONSE_EXTENSIONS].valueBlock.value, (element) => new Extension({ schema: element }));
  }
  toSchema(encodeFlag = false) {
    let tbsSchema;
    if (encodeFlag === false) {
      if (!this.tbsView.byteLength) {
        return _ResponseData.schema();
      }
      const asn1 = asn1js.fromBER(this.tbsView);
      AsnError.assert(asn1, "TBS Response Data");
      tbsSchema = asn1.result;
    } else {
      const outputArray = [];
      if (VERSION$7 in this) {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Integer({ value: this.version })]
        }));
      }
      if (this.responderID instanceof RelativeDistinguishedNames) {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [this.responderID.toSchema()]
        }));
      } else {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [this.responderID]
        }));
      }
      outputArray.push(new asn1js.GeneralizedTime({ valueDate: this.producedAt }));
      outputArray.push(new asn1js.Sequence({
        value: Array.from(this.responses, (o) => o.toSchema())
      }));
      if (this.responseExtensions) {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [new asn1js.Sequence({
            value: Array.from(this.responseExtensions, (o) => o.toSchema())
          })]
        }));
      }
      tbsSchema = new asn1js.Sequence({
        value: outputArray
      });
    }
    return tbsSchema;
  }
  toJSON() {
    const res = {};
    if (VERSION$7 in this) {
      res.version = this.version;
    }
    if (this.responderID) {
      res.responderID = this.responderID;
    }
    if (this.producedAt) {
      res.producedAt = this.producedAt;
    }
    if (this.responses) {
      res.responses = Array.from(this.responses, (o) => o.toJSON());
    }
    if (this.responseExtensions) {
      res.responseExtensions = Array.from(this.responseExtensions, (o) => o.toJSON());
    }
    return res;
  }
};
ResponseData.CLASS_NAME = "ResponseData";
var TRUSTED_CERTS = "trustedCerts";
var CERTS$2 = "certs";
var CRLS$1 = "crls";
var OCSPS$1 = "ocsps";
var CHECK_DATE = "checkDate";
var FIND_ORIGIN = "findOrigin";
var FIND_ISSUER = "findIssuer";
var ChainValidationCode;
(function(ChainValidationCode2) {
  ChainValidationCode2[ChainValidationCode2["unknown"] = -1] = "unknown";
  ChainValidationCode2[ChainValidationCode2["success"] = 0] = "success";
  ChainValidationCode2[ChainValidationCode2["noRevocation"] = 11] = "noRevocation";
  ChainValidationCode2[ChainValidationCode2["noPath"] = 60] = "noPath";
  ChainValidationCode2[ChainValidationCode2["noValidPath"] = 97] = "noValidPath";
})(ChainValidationCode || (ChainValidationCode = {}));
var ChainValidationError = class _ChainValidationError extends Error {
  constructor(code4, message) {
    super(message);
    this.name = _ChainValidationError.NAME;
    this.code = code4;
    this.message = message;
  }
};
ChainValidationError.NAME = "ChainValidationError";
function isTrusted(cert, trustedList) {
  for (let i2 = 0; i2 < trustedList.length; i2++) {
    if (BufferSourceConverter.isEqual(cert.tbsView, trustedList[i2].tbsView)) {
      return true;
    }
  }
  return false;
}
var CertificateChainValidationEngine = class _CertificateChainValidationEngine {
  constructor(parameters = {}) {
    this.trustedCerts = getParametersValue(parameters, TRUSTED_CERTS, this.defaultValues(TRUSTED_CERTS));
    this.certs = getParametersValue(parameters, CERTS$2, this.defaultValues(CERTS$2));
    this.crls = getParametersValue(parameters, CRLS$1, this.defaultValues(CRLS$1));
    this.ocsps = getParametersValue(parameters, OCSPS$1, this.defaultValues(OCSPS$1));
    this.checkDate = getParametersValue(parameters, CHECK_DATE, this.defaultValues(CHECK_DATE));
    this.findOrigin = getParametersValue(parameters, FIND_ORIGIN, this.defaultValues(FIND_ORIGIN));
    this.findIssuer = getParametersValue(parameters, FIND_ISSUER, this.defaultValues(FIND_ISSUER));
  }
  static defaultFindOrigin(certificate, validationEngine) {
    if (certificate.tbsView.byteLength === 0) {
      certificate.tbsView = new Uint8Array(certificate.encodeTBS().toBER());
    }
    for (const localCert of validationEngine.certs) {
      if (localCert.tbsView.byteLength === 0) {
        localCert.tbsView = new Uint8Array(localCert.encodeTBS().toBER());
      }
      if (BufferSourceConverter.isEqual(certificate.tbsView, localCert.tbsView))
        return "Intermediate Certificates";
    }
    for (const trustedCert of validationEngine.trustedCerts) {
      if (trustedCert.tbsView.byteLength === 0)
        trustedCert.tbsView = new Uint8Array(trustedCert.encodeTBS().toBER());
      if (BufferSourceConverter.isEqual(certificate.tbsView, trustedCert.tbsView))
        return "Trusted Certificates";
    }
    return "Unknown";
  }
  async defaultFindIssuer(certificate, validationEngine, crypto9 = getCrypto2(true)) {
    const result = [];
    let keyIdentifier = null;
    let authorityCertIssuer = null;
    let authorityCertSerialNumber = null;
    if (certificate.subject.isEqual(certificate.issuer)) {
      try {
        const verificationResult = await certificate.verify(void 0, crypto9);
        if (verificationResult) {
          return [certificate];
        }
      } catch (ex) {
      }
    }
    if (certificate.extensions) {
      for (const extension of certificate.extensions) {
        if (extension.extnID === id_AuthorityKeyIdentifier && extension.parsedValue instanceof AuthorityKeyIdentifier) {
          if (extension.parsedValue.keyIdentifier) {
            keyIdentifier = extension.parsedValue.keyIdentifier;
          } else {
            if (extension.parsedValue.authorityCertIssuer) {
              authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
            }
            if (extension.parsedValue.authorityCertSerialNumber) {
              authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
            }
          }
          break;
        }
      }
    }
    function checkCertificate(possibleIssuer) {
      if (keyIdentifier !== null) {
        if (possibleIssuer.extensions) {
          let extensionFound = false;
          for (const extension of possibleIssuer.extensions) {
            if (extension.extnID === id_SubjectKeyIdentifier && extension.parsedValue) {
              extensionFound = true;
              if (BufferSourceConverter.isEqual(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHexView)) {
                result.push(possibleIssuer);
              }
              break;
            }
          }
          if (extensionFound) {
            return;
          }
        }
      }
      let authorityCertSerialNumberEqual = false;
      if (authorityCertSerialNumber !== null)
        authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
      if (authorityCertIssuer !== null) {
        if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
          if (authorityCertSerialNumberEqual)
            result.push(possibleIssuer);
        }
      } else {
        if (certificate.issuer.isEqual(possibleIssuer.subject))
          result.push(possibleIssuer);
      }
    }
    for (const trustedCert of validationEngine.trustedCerts) {
      checkCertificate(trustedCert);
    }
    for (const intermediateCert of validationEngine.certs) {
      checkCertificate(intermediateCert);
    }
    for (let i2 = result.length - 1; i2 >= 0; i2--) {
      try {
        const verificationResult = await certificate.verify(result[i2], crypto9);
        if (verificationResult === false)
          result.splice(i2, 1);
      } catch (ex) {
        result.splice(i2, 1);
      }
    }
    return result;
  }
  defaultValues(memberName) {
    switch (memberName) {
      case TRUSTED_CERTS:
        return [];
      case CERTS$2:
        return [];
      case CRLS$1:
        return [];
      case OCSPS$1:
        return [];
      case CHECK_DATE:
        return /* @__PURE__ */ new Date();
      case FIND_ORIGIN:
        return _CertificateChainValidationEngine.defaultFindOrigin;
      case FIND_ISSUER:
        return this.defaultFindIssuer;
      default:
        throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
    }
  }
  async sort(passedWhenNotRevValues = false, crypto9 = getCrypto2(true)) {
    const localCerts = [];
    const buildPath = async (certificate, crypto10) => {
      const result2 = [];
      function checkUnique(array) {
        let unique = true;
        for (let i2 = 0; i2 < array.length; i2++) {
          for (let j = 0; j < array.length; j++) {
            if (j === i2)
              continue;
            if (array[i2] === array[j]) {
              unique = false;
              break;
            }
          }
          if (!unique)
            break;
        }
        return unique;
      }
      if (isTrusted(certificate, this.trustedCerts)) {
        return [[certificate]];
      }
      const findIssuerResult = await this.findIssuer(certificate, this, crypto10);
      if (findIssuerResult.length === 0) {
        throw new Error("No valid certificate paths found");
      }
      for (let i2 = 0; i2 < findIssuerResult.length; i2++) {
        if (BufferSourceConverter.isEqual(findIssuerResult[i2].tbsView, certificate.tbsView)) {
          result2.push([findIssuerResult[i2]]);
          continue;
        }
        const buildPathResult = await buildPath(findIssuerResult[i2], crypto10);
        for (let j = 0; j < buildPathResult.length; j++) {
          const copy = buildPathResult[j].slice();
          copy.splice(0, 0, findIssuerResult[i2]);
          if (checkUnique(copy))
            result2.push(copy);
          else
            result2.push(buildPathResult[j]);
        }
      }
      return result2;
    };
    const findCRL = async (certificate) => {
      const issuerCertificates = [];
      const crls = [];
      const crlsAndCertificates = [];
      issuerCertificates.push(...localCerts.filter((element) => certificate.issuer.isEqual(element.subject)));
      if (issuerCertificates.length === 0) {
        return {
          status: 1,
          statusMessage: "No certificate's issuers"
        };
      }
      crls.push(...this.crls.filter((o) => o.issuer.isEqual(certificate.issuer)));
      if (crls.length === 0) {
        return {
          status: 2,
          statusMessage: "No CRLs for specific certificate issuer"
        };
      }
      for (let i2 = 0; i2 < crls.length; i2++) {
        const crl = crls[i2];
        if (crl.nextUpdate && crl.nextUpdate.value < this.checkDate) {
          continue;
        }
        for (let j = 0; j < issuerCertificates.length; j++) {
          try {
            const result2 = await crls[i2].verify({ issuerCertificate: issuerCertificates[j] }, crypto9);
            if (result2) {
              crlsAndCertificates.push({
                crl: crls[i2],
                certificate: issuerCertificates[j]
              });
              break;
            }
          } catch (ex) {
          }
        }
      }
      if (crlsAndCertificates.length) {
        return {
          status: 0,
          statusMessage: EMPTY_STRING,
          result: crlsAndCertificates
        };
      }
      return {
        status: 3,
        statusMessage: "No valid CRLs found"
      };
    };
    const findOCSP = async (certificate, issuerCertificate) => {
      const hashAlgorithm = crypto9.getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);
      if (!hashAlgorithm.name) {
        return 1;
      }
      if (!hashAlgorithm.hash) {
        return 1;
      }
      for (let i2 = 0; i2 < this.ocsps.length; i2++) {
        const ocsp = this.ocsps[i2];
        const result2 = await ocsp.getCertificateStatus(certificate, issuerCertificate, crypto9);
        if (result2.isForCertificate) {
          if (result2.status === 0)
            return 0;
          return 1;
        }
      }
      return 2;
    };
    async function checkForCA(certificate, needToCheckCRL = false) {
      let isCA = false;
      let mustBeCA = false;
      let keyUsagePresent = false;
      let cRLSign = false;
      if (certificate.extensions) {
        for (let j = 0; j < certificate.extensions.length; j++) {
          const extension = certificate.extensions[j];
          if (extension.critical && !extension.parsedValue) {
            return {
              result: false,
              resultCode: 6,
              resultMessage: `Unable to parse critical certificate extension: ${extension.extnID}`
            };
          }
          if (extension.extnID === id_KeyUsage) {
            keyUsagePresent = true;
            const view = new Uint8Array(extension.parsedValue.valueBlock.valueHex);
            if ((view[0] & 4) === 4)
              mustBeCA = true;
            if ((view[0] & 2) === 2)
              cRLSign = true;
          }
          if (extension.extnID === id_BasicConstraints) {
            if ("cA" in extension.parsedValue) {
              if (extension.parsedValue.cA === true)
                isCA = true;
            }
          }
        }
        if (mustBeCA === true && isCA === false) {
          return {
            result: false,
            resultCode: 3,
            resultMessage: 'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'
          };
        }
        if (keyUsagePresent === true && isCA === true && mustBeCA === false) {
          return {
            result: false,
            resultCode: 4,
            resultMessage: 'Unable to build certificate chain - "keyCertSign" flag was not set'
          };
        }
        if (isCA === true && keyUsagePresent === true && (needToCheckCRL && cRLSign === false)) {
          return {
            result: false,
            resultCode: 5,
            resultMessage: 'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'
          };
        }
      }
      if (isCA === false) {
        return {
          result: false,
          resultCode: 7,
          resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
        };
      }
      return {
        result: true,
        resultCode: 0,
        resultMessage: EMPTY_STRING
      };
    }
    const basicCheck = async (path3, checkDate) => {
      for (let i2 = 0; i2 < path3.length; i2++) {
        if (path3[i2].notBefore.value > checkDate || path3[i2].notAfter.value < checkDate) {
          return {
            result: false,
            resultCode: 8,
            resultMessage: "The certificate is either not yet valid or expired"
          };
        }
      }
      if (path3.length < 2) {
        return {
          result: false,
          resultCode: 9,
          resultMessage: "Too short certificate path"
        };
      }
      for (let i2 = path3.length - 2; i2 >= 0; i2--) {
        if (path3[i2].issuer.isEqual(path3[i2].subject) === false) {
          if (path3[i2].issuer.isEqual(path3[i2 + 1].subject) === false) {
            return {
              result: false,
              resultCode: 10,
              resultMessage: "Incorrect name chaining"
            };
          }
        }
      }
      if (this.crls.length !== 0 || this.ocsps.length !== 0) {
        for (let i2 = 0; i2 < path3.length - 1; i2++) {
          let ocspResult = 2;
          let crlResult = {
            status: 0,
            statusMessage: EMPTY_STRING
          };
          if (this.ocsps.length !== 0) {
            ocspResult = await findOCSP(path3[i2], path3[i2 + 1]);
            switch (ocspResult) {
              case 0:
                continue;
              case 1:
                return {
                  result: false,
                  resultCode: 12,
                  resultMessage: "One of certificates was revoked via OCSP response"
                };
            }
          }
          if (this.crls.length !== 0) {
            crlResult = await findCRL(path3[i2]);
            if (crlResult.status === 0 && crlResult.result) {
              for (let j = 0; j < crlResult.result.length; j++) {
                const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path3[i2]);
                if (isCertificateRevoked) {
                  return {
                    result: false,
                    resultCode: 12,
                    resultMessage: "One of certificates had been revoked"
                  };
                }
                const isCertificateCA = await checkForCA(crlResult.result[j].certificate, true);
                if (isCertificateCA.result === false) {
                  return {
                    result: false,
                    resultCode: 13,
                    resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
                  };
                }
              }
            } else {
              if (passedWhenNotRevValues === false) {
                throw new ChainValidationError(ChainValidationCode.noRevocation, `No revocation values found for one of certificates: ${crlResult.statusMessage}`);
              }
            }
          } else {
            if (ocspResult === 2) {
              return {
                result: false,
                resultCode: 11,
                resultMessage: "No revocation values found for one of certificates"
              };
            }
          }
          if (ocspResult === 2 && crlResult.status === 2 && passedWhenNotRevValues) {
            const issuerCertificate = path3[i2 + 1];
            let extensionFound = false;
            if (issuerCertificate.extensions) {
              for (const extension of issuerCertificate.extensions) {
                switch (extension.extnID) {
                  case id_CRLDistributionPoints:
                  case id_FreshestCRL:
                  case id_AuthorityInfoAccess:
                    extensionFound = true;
                    break;
                }
              }
            }
            if (extensionFound) {
              throw new ChainValidationError(ChainValidationCode.noRevocation, `No revocation values found for one of certificates: ${crlResult.statusMessage}`);
            }
          }
        }
      }
      for (const [i2, cert] of path3.entries()) {
        if (!i2) {
          continue;
        }
        const result2 = await checkForCA(cert);
        if (!result2.result) {
          return {
            result: false,
            resultCode: 14,
            resultMessage: "One of intermediate certificates is not a CA certificate"
          };
        }
      }
      return {
        result: true
      };
    };
    localCerts.push(...this.trustedCerts);
    localCerts.push(...this.certs);
    for (let i2 = 0; i2 < localCerts.length; i2++) {
      for (let j = 0; j < localCerts.length; j++) {
        if (i2 === j)
          continue;
        if (BufferSourceConverter.isEqual(localCerts[i2].tbsView, localCerts[j].tbsView)) {
          localCerts.splice(j, 1);
          i2 = 0;
          break;
        }
      }
    }
    const leafCert = localCerts[localCerts.length - 1];
    let result;
    const certificatePath = [leafCert];
    result = await buildPath(leafCert, crypto9);
    if (result.length === 0) {
      throw new ChainValidationError(ChainValidationCode.noPath, "Unable to find certificate path");
    }
    for (let i2 = result.length - 1; i2 >= 0; i2--) {
      let found = false;
      for (let j = 0; j < result[i2].length; j++) {
        const certificate = result[i2][j];
        for (let k = 0; k < this.trustedCerts.length; k++) {
          if (BufferSourceConverter.isEqual(certificate.tbsView, this.trustedCerts[k].tbsView)) {
            found = true;
            break;
          }
        }
        if (found)
          break;
      }
      if (!found) {
        result.splice(i2, 1);
      }
    }
    if (result.length === 0) {
      throw new ChainValidationError(ChainValidationCode.noValidPath, "No valid certificate paths found");
    }
    let shortestLength = result[0].length;
    let shortestIndex = 0;
    for (let i2 = 0; i2 < result.length; i2++) {
      if (result[i2].length < shortestLength) {
        shortestLength = result[i2].length;
        shortestIndex = i2;
      }
    }
    for (let i2 = 0; i2 < result[shortestIndex].length; i2++)
      certificatePath.push(result[shortestIndex][i2]);
    result = await basicCheck(certificatePath, this.checkDate);
    if (result.result === false)
      throw result;
    return certificatePath;
  }
  async verify(parameters = {}, crypto9 = getCrypto2(true)) {
    function compareDNSName(name4, constraint) {
      const namePrepared = stringPrep(name4);
      const constraintPrepared = stringPrep(constraint);
      const nameSplitted = namePrepared.split(".");
      const constraintSplitted = constraintPrepared.split(".");
      const nameLen = nameSplitted.length;
      const constrLen = constraintSplitted.length;
      if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) {
        return false;
      }
      for (let i2 = 0; i2 < nameLen; i2++) {
        if (nameSplitted[i2].length === 0) {
          return false;
        }
      }
      for (let i2 = 0; i2 < constrLen; i2++) {
        if (constraintSplitted[i2].length === 0) {
          if (i2 === 0) {
            if (constrLen === 1) {
              return false;
            }
            continue;
          }
          return false;
        }
      }
      for (let i2 = 0; i2 < constrLen; i2++) {
        if (constraintSplitted[constrLen - 1 - i2].length === 0) {
          continue;
        }
        if (nameSplitted[nameLen - 1 - i2].localeCompare(constraintSplitted[constrLen - 1 - i2]) !== 0) {
          return false;
        }
      }
      return true;
    }
    function compareRFC822Name(name4, constraint) {
      const namePrepared = stringPrep(name4);
      const constraintPrepared = stringPrep(constraint);
      const nameSplitted = namePrepared.split("@");
      const constraintSplitted = constraintPrepared.split("@");
      if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length)
        return false;
      if (constraintSplitted.length === 1) {
        const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);
        if (result) {
          const ns = nameSplitted[1].split(".");
          const cs = constraintSplitted[0].split(".");
          if (cs[0].length === 0)
            return true;
          return ns.length === cs.length;
        }
        return false;
      }
      return namePrepared.localeCompare(constraintPrepared) === 0;
    }
    function compareUniformResourceIdentifier(name4, constraint) {
      let namePrepared = stringPrep(name4);
      const constraintPrepared = stringPrep(constraint);
      const ns = namePrepared.split("/");
      const cs = constraintPrepared.split("/");
      if (cs.length > 1)
        return false;
      if (ns.length > 1) {
        for (let i2 = 0; i2 < ns.length; i2++) {
          if (ns[i2].length > 0 && ns[i2].charAt(ns[i2].length - 1) !== ":") {
            const nsPort = ns[i2].split(":");
            namePrepared = nsPort[0];
            break;
          }
        }
      }
      const result = compareDNSName(namePrepared, constraintPrepared);
      if (result) {
        const nameSplitted = namePrepared.split(".");
        const constraintSplitted = constraintPrepared.split(".");
        if (constraintSplitted[0].length === 0)
          return true;
        return nameSplitted.length === constraintSplitted.length;
      }
      return false;
    }
    function compareIPAddress(name4, constraint) {
      const nameView = name4.valueBlock.valueHexView;
      const constraintView = constraint.valueBlock.valueHexView;
      if (nameView.length === 4 && constraintView.length === 8) {
        for (let i2 = 0; i2 < 4; i2++) {
          if ((nameView[i2] ^ constraintView[i2]) & constraintView[i2 + 4])
            return false;
        }
        return true;
      }
      if (nameView.length === 16 && constraintView.length === 32) {
        for (let i2 = 0; i2 < 16; i2++) {
          if ((nameView[i2] ^ constraintView[i2]) & constraintView[i2 + 16])
            return false;
        }
        return true;
      }
      return false;
    }
    function compareDirectoryName(name4, constraint) {
      if (name4.typesAndValues.length === 0 || constraint.typesAndValues.length === 0)
        return true;
      if (name4.typesAndValues.length < constraint.typesAndValues.length)
        return false;
      let result = true;
      let nameStart = 0;
      for (let i2 = 0; i2 < constraint.typesAndValues.length; i2++) {
        let localResult = false;
        for (let j = nameStart; j < name4.typesAndValues.length; j++) {
          localResult = name4.typesAndValues[j].isEqual(constraint.typesAndValues[i2]);
          if (name4.typesAndValues[j].type === constraint.typesAndValues[i2].type)
            result = result && localResult;
          if (localResult === true) {
            if (nameStart === 0 || nameStart === j) {
              nameStart = j + 1;
              break;
            } else
              return false;
          }
        }
        if (localResult === false)
          return false;
      }
      return nameStart === 0 ? false : result;
    }
    try {
      if (this.certs.length === 0)
        throw new Error("Empty certificate array");
      const passedWhenNotRevValues = parameters.passedWhenNotRevValues || false;
      const initialPolicySet = parameters.initialPolicySet || [id_AnyPolicy];
      const initialExplicitPolicy = parameters.initialExplicitPolicy || false;
      const initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit || false;
      const initialInhibitPolicy = parameters.initialInhibitPolicy || false;
      const initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet || [];
      const initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet || [];
      const initialRequiredNameForms = parameters.initialRequiredNameForms || [];
      let explicitPolicyIndicator = initialExplicitPolicy;
      let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
      let inhibitAnyPolicyIndicator = initialInhibitPolicy;
      const pendingConstraints = [
        false,
        false,
        false
      ];
      let explicitPolicyPending = 0;
      let policyMappingInhibitPending = 0;
      let inhibitAnyPolicyPending = 0;
      let permittedSubtrees = initialPermittedSubtreesSet;
      let excludedSubtrees = initialExcludedSubtreesSet;
      const requiredNameForms = initialRequiredNameForms;
      let pathDepth = 1;
      this.certs = await this.sort(passedWhenNotRevValues, crypto9);
      const allPolicies = [];
      allPolicies.push(id_AnyPolicy);
      const policiesAndCerts = [];
      const anyPolicyArray = new Array(this.certs.length - 1);
      for (let ii = 0; ii < this.certs.length - 1; ii++)
        anyPolicyArray[ii] = true;
      policiesAndCerts.push(anyPolicyArray);
      const policyMappings = new Array(this.certs.length - 1);
      const certPolicies = new Array(this.certs.length - 1);
      let explicitPolicyStart = explicitPolicyIndicator ? this.certs.length - 1 : -1;
      for (let i2 = this.certs.length - 2; i2 >= 0; i2--, pathDepth++) {
        const cert = this.certs[i2];
        if (cert.extensions) {
          for (let j = 0; j < cert.extensions.length; j++) {
            const extension = cert.extensions[j];
            if (extension.extnID === id_CertificatePolicies) {
              certPolicies[i2] = extension.parsedValue;
              for (let s = 0; s < allPolicies.length; s++) {
                if (allPolicies[s] === id_AnyPolicy) {
                  delete policiesAndCerts[s][i2];
                  break;
                }
              }
              for (let k = 0; k < extension.parsedValue.certificatePolicies.length; k++) {
                let policyIndex = -1;
                const policyId = extension.parsedValue.certificatePolicies[k].policyIdentifier;
                for (let s = 0; s < allPolicies.length; s++) {
                  if (policyId === allPolicies[s]) {
                    policyIndex = s;
                    break;
                  }
                }
                if (policyIndex === -1) {
                  allPolicies.push(policyId);
                  const certArray = new Array(this.certs.length - 1);
                  certArray[i2] = true;
                  policiesAndCerts.push(certArray);
                } else
                  policiesAndCerts[policyIndex][i2] = true;
              }
            }
            if (extension.extnID === id_PolicyMappings) {
              if (policyMappingInhibitIndicator) {
                return {
                  result: false,
                  resultCode: 98,
                  resultMessage: "Policy mapping prohibited"
                };
              }
              policyMappings[i2] = extension.parsedValue;
            }
            if (extension.extnID === id_PolicyConstraints) {
              if (explicitPolicyIndicator === false) {
                if (extension.parsedValue.requireExplicitPolicy === 0) {
                  explicitPolicyIndicator = true;
                  explicitPolicyStart = i2;
                } else {
                  if (pendingConstraints[0] === false) {
                    pendingConstraints[0] = true;
                    explicitPolicyPending = extension.parsedValue.requireExplicitPolicy;
                  } else
                    explicitPolicyPending = explicitPolicyPending > extension.parsedValue.requireExplicitPolicy ? extension.parsedValue.requireExplicitPolicy : explicitPolicyPending;
                }
                if (extension.parsedValue.inhibitPolicyMapping === 0)
                  policyMappingInhibitIndicator = true;
                else {
                  if (pendingConstraints[1] === false) {
                    pendingConstraints[1] = true;
                    policyMappingInhibitPending = extension.parsedValue.inhibitPolicyMapping + 1;
                  } else
                    policyMappingInhibitPending = policyMappingInhibitPending > extension.parsedValue.inhibitPolicyMapping + 1 ? extension.parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
                }
              }
            }
            if (extension.extnID === id_InhibitAnyPolicy) {
              if (inhibitAnyPolicyIndicator === false) {
                if (extension.parsedValue.valueBlock.valueDec === 0)
                  inhibitAnyPolicyIndicator = true;
                else {
                  if (pendingConstraints[2] === false) {
                    pendingConstraints[2] = true;
                    inhibitAnyPolicyPending = extension.parsedValue.valueBlock.valueDec;
                  } else
                    inhibitAnyPolicyPending = inhibitAnyPolicyPending > extension.parsedValue.valueBlock.valueDec ? extension.parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
                }
              }
            }
          }
          if (inhibitAnyPolicyIndicator === true) {
            let policyIndex = -1;
            for (let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++) {
              if (allPolicies[searchAnyPolicy] === id_AnyPolicy) {
                policyIndex = searchAnyPolicy;
                break;
              }
            }
            if (policyIndex !== -1)
              delete policiesAndCerts[0][i2];
          }
          if (explicitPolicyIndicator === false) {
            if (pendingConstraints[0] === true) {
              explicitPolicyPending--;
              if (explicitPolicyPending === 0) {
                explicitPolicyIndicator = true;
                explicitPolicyStart = i2;
                pendingConstraints[0] = false;
              }
            }
          }
          if (policyMappingInhibitIndicator === false) {
            if (pendingConstraints[1] === true) {
              policyMappingInhibitPending--;
              if (policyMappingInhibitPending === 0) {
                policyMappingInhibitIndicator = true;
                pendingConstraints[1] = false;
              }
            }
          }
          if (inhibitAnyPolicyIndicator === false) {
            if (pendingConstraints[2] === true) {
              inhibitAnyPolicyPending--;
              if (inhibitAnyPolicyPending === 0) {
                inhibitAnyPolicyIndicator = true;
                pendingConstraints[2] = false;
              }
            }
          }
        }
      }
      for (let i2 = 0; i2 < this.certs.length - 1; i2++) {
        if (i2 < this.certs.length - 2 && typeof policyMappings[i2 + 1] !== "undefined") {
          for (let k = 0; k < policyMappings[i2 + 1].mappings.length; k++) {
            if (policyMappings[i2 + 1].mappings[k].issuerDomainPolicy === id_AnyPolicy || policyMappings[i2 + 1].mappings[k].subjectDomainPolicy === id_AnyPolicy) {
              return {
                result: false,
                resultCode: 99,
                resultMessage: 'The "anyPolicy" should not be a part of policy mapping scheme'
              };
            }
            let issuerDomainPolicyIndex = -1;
            let subjectDomainPolicyIndex = -1;
            for (let n = 0; n < allPolicies.length; n++) {
              if (allPolicies[n] === policyMappings[i2 + 1].mappings[k].issuerDomainPolicy)
                issuerDomainPolicyIndex = n;
              if (allPolicies[n] === policyMappings[i2 + 1].mappings[k].subjectDomainPolicy)
                subjectDomainPolicyIndex = n;
            }
            if (typeof policiesAndCerts[issuerDomainPolicyIndex][i2] !== "undefined")
              delete policiesAndCerts[issuerDomainPolicyIndex][i2];
            for (let j = 0; j < certPolicies[i2].certificatePolicies.length; j++) {
              if (policyMappings[i2 + 1].mappings[k].subjectDomainPolicy === certPolicies[i2].certificatePolicies[j].policyIdentifier) {
                if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {
                  for (let m = 0; m <= i2; m++) {
                    if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== "undefined") {
                      policiesAndCerts[issuerDomainPolicyIndex][m] = true;
                      delete policiesAndCerts[subjectDomainPolicyIndex][m];
                    }
                  }
                }
              }
            }
          }
        }
      }
      for (let i2 = 0; i2 < allPolicies.length; i2++) {
        if (allPolicies[i2] === id_AnyPolicy) {
          for (let j = 0; j < explicitPolicyStart; j++)
            delete policiesAndCerts[i2][j];
        }
      }
      const authConstrPolicies = [];
      for (let i2 = 0; i2 < policiesAndCerts.length; i2++) {
        let found = true;
        for (let j = 0; j < this.certs.length - 1; j++) {
          let anyPolicyFound = false;
          if (j < explicitPolicyStart && allPolicies[i2] === id_AnyPolicy && allPolicies.length > 1) {
            found = false;
            break;
          }
          if (typeof policiesAndCerts[i2][j] === "undefined") {
            if (j >= explicitPolicyStart) {
              for (let k = 0; k < allPolicies.length; k++) {
                if (allPolicies[k] === id_AnyPolicy) {
                  if (policiesAndCerts[k][j] === true)
                    anyPolicyFound = true;
                  break;
                }
              }
            }
            if (!anyPolicyFound) {
              found = false;
              break;
            }
          }
        }
        if (found === true)
          authConstrPolicies.push(allPolicies[i2]);
      }
      let userConstrPolicies = [];
      if (initialPolicySet.length === 1 && initialPolicySet[0] === id_AnyPolicy && explicitPolicyIndicator === false)
        userConstrPolicies = initialPolicySet;
      else {
        if (authConstrPolicies.length === 1 && authConstrPolicies[0] === id_AnyPolicy)
          userConstrPolicies = initialPolicySet;
        else {
          for (let i2 = 0; i2 < authConstrPolicies.length; i2++) {
            for (let j = 0; j < initialPolicySet.length; j++) {
              if (initialPolicySet[j] === authConstrPolicies[i2] || initialPolicySet[j] === id_AnyPolicy) {
                userConstrPolicies.push(authConstrPolicies[i2]);
                break;
              }
            }
          }
        }
      }
      const policyResult = {
        result: userConstrPolicies.length > 0,
        resultCode: 0,
        resultMessage: userConstrPolicies.length > 0 ? EMPTY_STRING : 'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',
        authConstrPolicies,
        userConstrPolicies,
        explicitPolicyIndicator,
        policyMappings,
        certificatePath: this.certs
      };
      if (userConstrPolicies.length === 0)
        return policyResult;
      if (policyResult.result === false)
        return policyResult;
      pathDepth = 1;
      for (let i2 = this.certs.length - 2; i2 >= 0; i2--, pathDepth++) {
        const cert = this.certs[i2];
        let subjectAltNames = [];
        let certPermittedSubtrees = [];
        let certExcludedSubtrees = [];
        if (cert.extensions) {
          for (let j = 0; j < cert.extensions.length; j++) {
            const extension = cert.extensions[j];
            if (extension.extnID === id_NameConstraints) {
              if ("permittedSubtrees" in extension.parsedValue)
                certPermittedSubtrees = certPermittedSubtrees.concat(extension.parsedValue.permittedSubtrees);
              if ("excludedSubtrees" in extension.parsedValue)
                certExcludedSubtrees = certExcludedSubtrees.concat(extension.parsedValue.excludedSubtrees);
            }
            if (extension.extnID === id_SubjectAltName)
              subjectAltNames = subjectAltNames.concat(extension.parsedValue.altNames);
          }
        }
        let formFound = requiredNameForms.length <= 0;
        for (let j = 0; j < requiredNameForms.length; j++) {
          switch (requiredNameForms[j].base.type) {
            case 4:
              {
                if (requiredNameForms[j].base.value.typesAndValues.length !== cert.subject.typesAndValues.length)
                  continue;
                formFound = true;
                for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                  if (cert.subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type) {
                    formFound = false;
                    break;
                  }
                }
                if (formFound === true)
                  break;
              }
              break;
            default:
          }
        }
        if (formFound === false) {
          policyResult.result = false;
          policyResult.resultCode = 21;
          policyResult.resultMessage = "No necessary name form found";
          throw policyResult;
        }
        const constrGroups = [
          [],
          [],
          [],
          [],
          []
        ];
        for (let j = 0; j < permittedSubtrees.length; j++) {
          switch (permittedSubtrees[j].base.type) {
            case 1:
              constrGroups[0].push(permittedSubtrees[j]);
              break;
            case 2:
              constrGroups[1].push(permittedSubtrees[j]);
              break;
            case 4:
              constrGroups[2].push(permittedSubtrees[j]);
              break;
            case 6:
              constrGroups[3].push(permittedSubtrees[j]);
              break;
            case 7:
              constrGroups[4].push(permittedSubtrees[j]);
              break;
            default:
          }
        }
        for (let p = 0; p < 5; p++) {
          let groupPermitted = false;
          let valueExists = false;
          const group = constrGroups[p];
          for (let j = 0; j < group.length; j++) {
            switch (p) {
              case 0:
                if (subjectAltNames.length > 0) {
                  for (let k = 0; k < subjectAltNames.length; k++) {
                    if (subjectAltNames[k].type === 1) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
                    }
                  }
                } else {
                  for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                    if (cert.subject.typesAndValues[k].type === "1.2.840.113549.1.9.1" || cert.subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3") {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareRFC822Name(cert.subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
                    }
                  }
                }
                break;
              case 1:
                if (subjectAltNames.length > 0) {
                  for (let k = 0; k < subjectAltNames.length; k++) {
                    if (subjectAltNames[k].type === 2) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
                    }
                  }
                }
                break;
              case 2:
                valueExists = true;
                groupPermitted = compareDirectoryName(cert.subject, group[j].base.value);
                break;
              case 3:
                if (subjectAltNames.length > 0) {
                  for (let k = 0; k < subjectAltNames.length; k++) {
                    if (subjectAltNames[k].type === 6) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
                    }
                  }
                }
                break;
              case 4:
                if (subjectAltNames.length > 0) {
                  for (let k = 0; k < subjectAltNames.length; k++) {
                    if (subjectAltNames[k].type === 7) {
                      valueExists = true;
                      groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
                    }
                  }
                }
                break;
              default:
            }
            if (groupPermitted)
              break;
          }
          if (groupPermitted === false && group.length > 0 && valueExists) {
            policyResult.result = false;
            policyResult.resultCode = 41;
            policyResult.resultMessage = 'Failed to meet "permitted sub-trees" name constraint';
            throw policyResult;
          }
        }
        let excluded = false;
        for (let j = 0; j < excludedSubtrees.length; j++) {
          switch (excludedSubtrees[j].base.type) {
            case 1:
              if (subjectAltNames.length >= 0) {
                for (let k = 0; k < subjectAltNames.length; k++) {
                  if (subjectAltNames[k].type === 1)
                    excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                }
              } else {
                for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                  if (cert.subject.typesAndValues[k].type === "1.2.840.113549.1.9.1" || cert.subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")
                    excluded = excluded || compareRFC822Name(cert.subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);
                }
              }
              break;
            case 2:
              if (subjectAltNames.length > 0) {
                for (let k = 0; k < subjectAltNames.length; k++) {
                  if (subjectAltNames[k].type === 2)
                    excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                }
              }
              break;
            case 4:
              excluded = excluded || compareDirectoryName(cert.subject, excludedSubtrees[j].base.value);
              break;
            case 6:
              if (subjectAltNames.length > 0) {
                for (let k = 0; k < subjectAltNames.length; k++) {
                  if (subjectAltNames[k].type === 6)
                    excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                }
              }
              break;
            case 7:
              if (subjectAltNames.length > 0) {
                for (let k = 0; k < subjectAltNames.length; k++) {
                  if (subjectAltNames[k].type === 7)
                    excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                }
              }
              break;
            default:
          }
          if (excluded)
            break;
        }
        if (excluded === true) {
          policyResult.result = false;
          policyResult.resultCode = 42;
          policyResult.resultMessage = 'Failed to meet "excluded sub-trees" name constraint';
          throw policyResult;
        }
        permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
        excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
      }
      return policyResult;
    } catch (error) {
      if (error instanceof Error) {
        if (error instanceof ChainValidationError) {
          return {
            result: false,
            resultCode: error.code,
            resultMessage: error.message,
            error
          };
        }
        return {
          result: false,
          resultCode: ChainValidationCode.unknown,
          resultMessage: error.message,
          error
        };
      }
      if (error && typeof error === "object" && "resultMessage" in error) {
        return error;
      }
      return {
        result: false,
        resultCode: -1,
        resultMessage: `${error}`
      };
    }
  }
};
var TBS_RESPONSE_DATA = "tbsResponseData";
var SIGNATURE_ALGORITHM$3 = "signatureAlgorithm";
var SIGNATURE$2 = "signature";
var CERTS$1 = "certs";
var BASIC_OCSP_RESPONSE = "BasicOCSPResponse";
var BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA = `${BASIC_OCSP_RESPONSE}.${TBS_RESPONSE_DATA}`;
var BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM = `${BASIC_OCSP_RESPONSE}.${SIGNATURE_ALGORITHM$3}`;
var BASIC_OCSP_RESPONSE_SIGNATURE = `${BASIC_OCSP_RESPONSE}.${SIGNATURE$2}`;
var BASIC_OCSP_RESPONSE_CERTS = `${BASIC_OCSP_RESPONSE}.${CERTS$1}`;
var CLEAR_PROPS$g = [
  BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA,
  BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM,
  BASIC_OCSP_RESPONSE_SIGNATURE,
  BASIC_OCSP_RESPONSE_CERTS
];
var BasicOCSPResponse = class _BasicOCSPResponse extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.tbsResponseData = getParametersValue(parameters, TBS_RESPONSE_DATA, _BasicOCSPResponse.defaultValues(TBS_RESPONSE_DATA));
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$3, _BasicOCSPResponse.defaultValues(SIGNATURE_ALGORITHM$3));
    this.signature = getParametersValue(parameters, SIGNATURE$2, _BasicOCSPResponse.defaultValues(SIGNATURE$2));
    if (CERTS$1 in parameters) {
      this.certs = getParametersValue(parameters, CERTS$1, _BasicOCSPResponse.defaultValues(CERTS$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TBS_RESPONSE_DATA:
        return new ResponseData();
      case SIGNATURE_ALGORITHM$3:
        return new AlgorithmIdentifier();
      case SIGNATURE$2:
        return new asn1js.BitString();
      case CERTS$1:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case "type": {
        let comparisonResult = ResponseData.compareWithDefault("tbs", memberValue.tbs) && ResponseData.compareWithDefault("responderID", memberValue.responderID) && ResponseData.compareWithDefault("producedAt", memberValue.producedAt) && ResponseData.compareWithDefault("responses", memberValue.responses);
        if ("responseExtensions" in memberValue)
          comparisonResult = comparisonResult && ResponseData.compareWithDefault("responseExtensions", memberValue.responseExtensions);
        return comparisonResult;
      }
      case SIGNATURE_ALGORITHM$3:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case SIGNATURE$2:
        return memberValue.isEqual(_BasicOCSPResponse.defaultValues(memberName));
      case CERTS$1:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || BASIC_OCSP_RESPONSE,
      value: [
        ResponseData.schema(names.tbsResponseData || {
          names: {
            blockName: BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
          }
        }),
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
          }
        }),
        new asn1js.BitString({ name: names.signature || BASIC_OCSP_RESPONSE_SIGNATURE }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Sequence({
              value: [new asn1js.Repeated({
                name: BASIC_OCSP_RESPONSE_CERTS,
                value: Certificate.schema(names.certs || {})
              })]
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$g);
    const asn1 = asn1js.compareSchema(schema, schema, _BasicOCSPResponse.schema());
    AsnError.assertSchema(asn1, this.className);
    this.tbsResponseData = new ResponseData({ schema: asn1.result[BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA] });
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM] });
    this.signature = asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE];
    if (BASIC_OCSP_RESPONSE_CERTS in asn1.result) {
      this.certs = Array.from(asn1.result[BASIC_OCSP_RESPONSE_CERTS], (element) => new Certificate({ schema: element }));
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.tbsResponseData.toSchema());
    outputArray.push(this.signatureAlgorithm.toSchema());
    outputArray.push(this.signature);
    if (this.certs) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.Sequence({
            value: Array.from(this.certs, (o) => o.toSchema())
          })
        ]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      tbsResponseData: this.tbsResponseData.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signature: this.signature.toJSON()
    };
    if (this.certs) {
      res.certs = Array.from(this.certs, (o) => o.toJSON());
    }
    return res;
  }
  async getCertificateStatus(certificate, issuerCertificate, crypto9 = getCrypto2(true)) {
    const result = {
      isForCertificate: false,
      status: 2
    };
    const hashesObject = {};
    const certIDs = [];
    for (const response of this.tbsResponseData.responses) {
      const hashAlgorithm = crypto9.getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId, true, "CertID.hashAlgorithm");
      if (!hashesObject[hashAlgorithm.name]) {
        hashesObject[hashAlgorithm.name] = 1;
        const certID = new CertID();
        certIDs.push(certID);
        await certID.createForCertificate(certificate, {
          hashAlgorithm: hashAlgorithm.name,
          issuerCertificate
        }, crypto9);
      }
    }
    for (const response of this.tbsResponseData.responses) {
      for (const id of certIDs) {
        if (response.certID.isEqual(id)) {
          result.isForCertificate = true;
          try {
            switch (response.certStatus.idBlock.isConstructed) {
              case true:
                if (response.certStatus.idBlock.tagNumber === 1)
                  result.status = 1;
                break;
              case false:
                switch (response.certStatus.idBlock.tagNumber) {
                  case 0:
                    result.status = 0;
                    break;
                  case 2:
                    result.status = 2;
                    break;
                  default:
                }
                break;
              default:
            }
          } catch (ex) {
          }
          return result;
        }
      }
    }
    return result;
  }
  async sign(privateKey, hashAlgorithm = "SHA-1", crypto9 = getCrypto2(true)) {
    if (!privateKey) {
      throw new Error("Need to provide a private key for signing");
    }
    const signatureParams = await crypto9.getSignatureParameters(privateKey, hashAlgorithm);
    const algorithm = signatureParams.parameters.algorithm;
    if (!("name" in algorithm)) {
      throw new Error("Empty algorithm");
    }
    this.signatureAlgorithm = signatureParams.signatureAlgorithm;
    this.tbsResponseData.tbsView = new Uint8Array(this.tbsResponseData.toSchema(true).toBER());
    const signature = await crypto9.signWithPrivateKey(this.tbsResponseData.tbsView, privateKey, { algorithm });
    this.signature = new asn1js.BitString({ valueHex: signature });
  }
  async verify(params = {}, crypto9 = getCrypto2(true)) {
    let signerCert = null;
    let certIndex = -1;
    const trustedCerts = params.trustedCerts || [];
    if (!this.certs) {
      throw new Error("No certificates attached to the BasicOCSPResponse");
    }
    switch (true) {
      case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:
        for (const [index, certificate] of this.certs.entries()) {
          if (certificate.subject.isEqual(this.tbsResponseData.responderID)) {
            certIndex = index;
            break;
          }
        }
        break;
      case this.tbsResponseData.responderID instanceof asn1js.OctetString:
        for (const [index, cert] of this.certs.entries()) {
          const hash3 = await crypto9.digest({ name: "sha-1" }, cert.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
          if (isEqualBuffer(hash3, this.tbsResponseData.responderID.valueBlock.valueHex)) {
            certIndex = index;
            break;
          }
        }
        break;
      default:
        throw new Error("Wrong value for responderID");
    }
    if (certIndex === -1)
      throw new Error("Correct certificate was not found in OCSP response");
    signerCert = this.certs[certIndex];
    const additionalCerts = [signerCert];
    for (const cert of this.certs) {
      const caCert = await checkCA(cert, signerCert);
      if (caCert) {
        additionalCerts.push(caCert);
      }
    }
    const certChain = new CertificateChainValidationEngine({
      certs: additionalCerts,
      trustedCerts
    });
    const verificationResult = await certChain.verify({}, crypto9);
    if (!verificationResult.result) {
      throw new Error("Validation of signer's certificate failed");
    }
    return crypto9.verifyWithPublicKey(this.tbsResponseData.tbsView, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm);
  }
};
BasicOCSPResponse.CLASS_NAME = "BasicOCSPResponse";
var TBS$1 = "tbs";
var VERSION$6 = "version";
var SUBJECT = "subject";
var SPKI = "subjectPublicKeyInfo";
var ATTRIBUTES$1 = "attributes";
var SIGNATURE_ALGORITHM$2 = "signatureAlgorithm";
var SIGNATURE_VALUE = "signatureValue";
var CSR_INFO = "CertificationRequestInfo";
var CSR_INFO_VERSION = `${CSR_INFO}.version`;
var CSR_INFO_SUBJECT = `${CSR_INFO}.subject`;
var CSR_INFO_SPKI = `${CSR_INFO}.subjectPublicKeyInfo`;
var CSR_INFO_ATTRS = `${CSR_INFO}.attributes`;
var CLEAR_PROPS$f = [
  CSR_INFO,
  CSR_INFO_VERSION,
  CSR_INFO_SUBJECT,
  CSR_INFO_SPKI,
  CSR_INFO_ATTRS,
  SIGNATURE_ALGORITHM$2,
  SIGNATURE_VALUE
];
function CertificationRequestInfo(parameters = {}) {
  const names = getParametersValue(parameters, "names", {});
  return new asn1js.Sequence({
    name: names.CertificationRequestInfo || CSR_INFO,
    value: [
      new asn1js.Integer({ name: names.CertificationRequestInfoVersion || CSR_INFO_VERSION }),
      RelativeDistinguishedNames.schema(names.subject || {
        names: {
          blockName: CSR_INFO_SUBJECT
        }
      }),
      PublicKeyInfo.schema({
        names: {
          blockName: CSR_INFO_SPKI
        }
      }),
      new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.Repeated({
            optional: true,
            name: names.CertificationRequestInfoAttributes || CSR_INFO_ATTRS,
            value: Attribute.schema(names.attributes || {})
          })
        ]
      })
    ]
  });
}
var CertificationRequest = class _CertificationRequest extends PkiObject {
  get tbs() {
    return BufferSourceConverter.toArrayBuffer(this.tbsView);
  }
  set tbs(value) {
    this.tbsView = new Uint8Array(value);
  }
  constructor(parameters = {}) {
    super();
    this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$1, _CertificationRequest.defaultValues(TBS$1)));
    this.version = getParametersValue(parameters, VERSION$6, _CertificationRequest.defaultValues(VERSION$6));
    this.subject = getParametersValue(parameters, SUBJECT, _CertificationRequest.defaultValues(SUBJECT));
    this.subjectPublicKeyInfo = getParametersValue(parameters, SPKI, _CertificationRequest.defaultValues(SPKI));
    if (ATTRIBUTES$1 in parameters) {
      this.attributes = getParametersValue(parameters, ATTRIBUTES$1, _CertificationRequest.defaultValues(ATTRIBUTES$1));
    }
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$2, _CertificationRequest.defaultValues(SIGNATURE_ALGORITHM$2));
    this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE, _CertificationRequest.defaultValues(SIGNATURE_VALUE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TBS$1:
        return EMPTY_BUFFER;
      case VERSION$6:
        return 0;
      case SUBJECT:
        return new RelativeDistinguishedNames();
      case SPKI:
        return new PublicKeyInfo();
      case ATTRIBUTES$1:
        return [];
      case SIGNATURE_ALGORITHM$2:
        return new AlgorithmIdentifier();
      case SIGNATURE_VALUE:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      value: [
        CertificationRequestInfo(names.certificationRequestInfo || {}),
        new asn1js.Sequence({
          name: names.signatureAlgorithm || SIGNATURE_ALGORITHM$2,
          value: [
            new asn1js.ObjectIdentifier(),
            new asn1js.Any({ optional: true })
          ]
        }),
        new asn1js.BitString({ name: names.signatureValue || SIGNATURE_VALUE })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$f);
    const asn1 = asn1js.compareSchema(schema, schema, _CertificationRequest.schema());
    AsnError.assertSchema(asn1, this.className);
    this.tbsView = asn1.result.CertificationRequestInfo.valueBeforeDecodeView;
    this.version = asn1.result[CSR_INFO_VERSION].valueBlock.valueDec;
    this.subject = new RelativeDistinguishedNames({ schema: asn1.result[CSR_INFO_SUBJECT] });
    this.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[CSR_INFO_SPKI] });
    if (CSR_INFO_ATTRS in asn1.result) {
      this.attributes = Array.from(asn1.result[CSR_INFO_ATTRS], (element) => new Attribute({ schema: element }));
    }
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
    this.signatureValue = asn1.result.signatureValue;
  }
  encodeTBS() {
    const outputArray = [
      new asn1js.Integer({ value: this.version }),
      this.subject.toSchema(),
      this.subjectPublicKeyInfo.toSchema()
    ];
    if (ATTRIBUTES$1 in this) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: Array.from(this.attributes || [], (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toSchema(encodeFlag = false) {
    let tbsSchema;
    if (encodeFlag === false) {
      if (this.tbsView.byteLength === 0) {
        return _CertificationRequest.schema();
      }
      const asn1 = asn1js.fromBER(this.tbsView);
      AsnError.assert(asn1, "PKCS#10 Certificate Request");
      tbsSchema = asn1.result;
    } else {
      tbsSchema = this.encodeTBS();
    }
    return new asn1js.Sequence({
      value: [
        tbsSchema,
        this.signatureAlgorithm.toSchema(),
        this.signatureValue
      ]
    });
  }
  toJSON() {
    const object2 = {
      tbs: Convert.ToHex(this.tbsView),
      version: this.version,
      subject: this.subject.toJSON(),
      subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signatureValue: this.signatureValue.toJSON()
    };
    if (ATTRIBUTES$1 in this) {
      object2.attributes = Array.from(this.attributes || [], (o) => o.toJSON());
    }
    return object2;
  }
  async sign(privateKey, hashAlgorithm = "SHA-1", crypto9 = getCrypto2(true)) {
    if (!privateKey) {
      throw new Error("Need to provide a private key for signing");
    }
    const signatureParams = await crypto9.getSignatureParameters(privateKey, hashAlgorithm);
    const parameters = signatureParams.parameters;
    this.signatureAlgorithm = signatureParams.signatureAlgorithm;
    this.tbsView = new Uint8Array(this.encodeTBS().toBER());
    const signature = await crypto9.signWithPrivateKey(this.tbsView, privateKey, parameters);
    this.signatureValue = new asn1js.BitString({ valueHex: signature });
  }
  async verify(crypto9 = getCrypto2(true)) {
    return crypto9.verifyWithPublicKey(this.tbsView, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);
  }
  async getPublicKey(parameters, crypto9 = getCrypto2(true)) {
    return crypto9.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
  }
};
CertificationRequest.CLASS_NAME = "CertificationRequest";
var DIGEST_ALGORITHM$1 = "digestAlgorithm";
var DIGEST = "digest";
var CLEAR_PROPS$e = [
  DIGEST_ALGORITHM$1,
  DIGEST
];
var DigestInfo = class _DigestInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM$1, _DigestInfo.defaultValues(DIGEST_ALGORITHM$1));
    this.digest = getParametersValue(parameters, DIGEST, _DigestInfo.defaultValues(DIGEST));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case DIGEST_ALGORITHM$1:
        return new AlgorithmIdentifier();
      case DIGEST:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case DIGEST_ALGORITHM$1:
        return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
      case DIGEST:
        return memberValue.isEqual(_DigestInfo.defaultValues(memberName));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.digestAlgorithm || {
          names: {
            blockName: DIGEST_ALGORITHM$1
          }
        }),
        new asn1js.OctetString({ name: names.digest || DIGEST })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$e);
    const asn1 = asn1js.compareSchema(schema, schema, _DigestInfo.schema({
      names: {
        digestAlgorithm: {
          names: {
            blockName: DIGEST_ALGORITHM$1
          }
        },
        digest: DIGEST
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.digestAlgorithm });
    this.digest = asn1.result.digest;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.digestAlgorithm.toSchema(),
        this.digest
      ]
    });
  }
  toJSON() {
    return {
      digestAlgorithm: this.digestAlgorithm.toJSON(),
      digest: this.digest.toJSON()
    };
  }
};
DigestInfo.CLASS_NAME = "DigestInfo";
var E_CONTENT_TYPE = "eContentType";
var E_CONTENT = "eContent";
var CLEAR_PROPS$d = [
  E_CONTENT_TYPE,
  E_CONTENT
];
var EncapsulatedContentInfo = class _EncapsulatedContentInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.eContentType = getParametersValue(parameters, E_CONTENT_TYPE, _EncapsulatedContentInfo.defaultValues(E_CONTENT_TYPE));
    if (E_CONTENT in parameters) {
      this.eContent = getParametersValue(parameters, E_CONTENT, _EncapsulatedContentInfo.defaultValues(E_CONTENT));
      if (this.eContent.idBlock.tagClass === 1 && this.eContent.idBlock.tagNumber === 4) {
        if (this.eContent.idBlock.isConstructed === false) {
          const constrString = new asn1js.OctetString({
            idBlock: { isConstructed: true },
            isConstructed: true
          });
          let offset = 0;
          const viewHex = this.eContent.valueBlock.valueHexView.slice().buffer;
          let length3 = viewHex.byteLength;
          while (length3 > 0) {
            const pieceView = new Uint8Array(viewHex, offset, offset + 65536 > viewHex.byteLength ? viewHex.byteLength - offset : 65536);
            const _array = new ArrayBuffer(pieceView.length);
            const _view = new Uint8Array(_array);
            for (let i2 = 0; i2 < _view.length; i2++) {
              _view[i2] = pieceView[i2];
            }
            constrString.valueBlock.value.push(new asn1js.OctetString({ valueHex: _array }));
            length3 -= pieceView.length;
            offset += pieceView.length;
          }
          this.eContent = constrString;
        }
      }
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case E_CONTENT_TYPE:
        return EMPTY_STRING;
      case E_CONTENT:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case E_CONTENT_TYPE:
        return memberValue === EMPTY_STRING;
      case E_CONTENT: {
        if (memberValue.idBlock.tagClass === 1 && memberValue.idBlock.tagNumber === 4)
          return memberValue.isEqual(_EncapsulatedContentInfo.defaultValues(E_CONTENT));
        return false;
      }
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.eContentType || EMPTY_STRING }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Any({ name: names.eContent || EMPTY_STRING })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$d);
    const asn1 = asn1js.compareSchema(schema, schema, _EncapsulatedContentInfo.schema({
      names: {
        eContentType: E_CONTENT_TYPE,
        eContent: E_CONTENT
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.eContentType = asn1.result.eContentType.valueBlock.toString();
    if (E_CONTENT in asn1.result)
      this.eContent = asn1.result.eContent;
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.eContentType }));
    if (this.eContent) {
      if (_EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
        outputArray.push(new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.eContent]
        }));
      }
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      eContentType: this.eContentType
    };
    if (this.eContent && _EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
      res.eContent = this.eContent.toJSON();
    }
    return res;
  }
};
EncapsulatedContentInfo.CLASS_NAME = "EncapsulatedContentInfo";
var MAC = "mac";
var MAC_SALT = "macSalt";
var ITERATIONS = "iterations";
var CLEAR_PROPS$c = [
  MAC,
  MAC_SALT,
  ITERATIONS
];
var MacData = class _MacData extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.mac = getParametersValue(parameters, MAC, _MacData.defaultValues(MAC));
    this.macSalt = getParametersValue(parameters, MAC_SALT, _MacData.defaultValues(MAC_SALT));
    if (ITERATIONS in parameters) {
      this.iterations = getParametersValue(parameters, ITERATIONS, _MacData.defaultValues(ITERATIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case MAC:
        return new DigestInfo();
      case MAC_SALT:
        return new asn1js.OctetString();
      case ITERATIONS:
        return 1;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case MAC:
        return DigestInfo.compareWithDefault("digestAlgorithm", memberValue.digestAlgorithm) && DigestInfo.compareWithDefault("digest", memberValue.digest);
      case MAC_SALT:
        return memberValue.isEqual(_MacData.defaultValues(memberName));
      case ITERATIONS:
        return memberValue === _MacData.defaultValues(memberName);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      optional: names.optional || true,
      value: [
        DigestInfo.schema(names.mac || {
          names: {
            blockName: MAC
          }
        }),
        new asn1js.OctetString({ name: names.macSalt || MAC_SALT }),
        new asn1js.Integer({
          optional: true,
          name: names.iterations || ITERATIONS
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$c);
    const asn1 = asn1js.compareSchema(schema, schema, _MacData.schema({
      names: {
        mac: {
          names: {
            blockName: MAC
          }
        },
        macSalt: MAC_SALT,
        iterations: ITERATIONS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.mac = new DigestInfo({ schema: asn1.result.mac });
    this.macSalt = asn1.result.macSalt;
    if (ITERATIONS in asn1.result)
      this.iterations = asn1.result.iterations.valueBlock.valueDec;
  }
  toSchema() {
    const outputArray = [
      this.mac.toSchema(),
      this.macSalt
    ];
    if (this.iterations !== void 0) {
      outputArray.push(new asn1js.Integer({ value: this.iterations }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      mac: this.mac.toJSON(),
      macSalt: this.macSalt.toJSON()
    };
    if (this.iterations !== void 0) {
      res.iterations = this.iterations;
    }
    return res;
  }
};
MacData.CLASS_NAME = "MacData";
var HASH_ALGORITHM = "hashAlgorithm";
var HASHED_MESSAGE = "hashedMessage";
var CLEAR_PROPS$b = [
  HASH_ALGORITHM,
  HASHED_MESSAGE
];
var MessageImprint = class _MessageImprint extends PkiObject {
  static async create(hashAlgorithm, message, crypto9 = getCrypto2(true)) {
    const hashAlgorithmOID = crypto9.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
    const hashedMessage = await crypto9.digest(hashAlgorithm, message);
    const res = new _MessageImprint({
      hashAlgorithm: new AlgorithmIdentifier({
        algorithmId: hashAlgorithmOID,
        algorithmParams: new asn1js.Null()
      }),
      hashedMessage: new asn1js.OctetString({ valueHex: hashedMessage })
    });
    return res;
  }
  constructor(parameters = {}) {
    super();
    this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM, _MessageImprint.defaultValues(HASH_ALGORITHM));
    this.hashedMessage = getParametersValue(parameters, HASHED_MESSAGE, _MessageImprint.defaultValues(HASHED_MESSAGE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case HASH_ALGORITHM:
        return new AlgorithmIdentifier();
      case HASHED_MESSAGE:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case HASH_ALGORITHM:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case HASHED_MESSAGE:
        return memberValue.isEqual(_MessageImprint.defaultValues(memberName)) === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.hashAlgorithm || {}),
        new asn1js.OctetString({ name: names.hashedMessage || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$b);
    const asn1 = asn1js.compareSchema(schema, schema, _MessageImprint.schema({
      names: {
        hashAlgorithm: {
          names: {
            blockName: HASH_ALGORITHM
          }
        },
        hashedMessage: HASHED_MESSAGE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
    this.hashedMessage = asn1.result.hashedMessage;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        this.hashAlgorithm.toSchema(),
        this.hashedMessage
      ]
    });
  }
  toJSON() {
    return {
      hashAlgorithm: this.hashAlgorithm.toJSON(),
      hashedMessage: this.hashedMessage.toJSON()
    };
  }
};
MessageImprint.CLASS_NAME = "MessageImprint";
var REQ_CERT = "reqCert";
var SINGLE_REQUEST_EXTENSIONS = "singleRequestExtensions";
var CLEAR_PROPS$a = [
  REQ_CERT,
  SINGLE_REQUEST_EXTENSIONS
];
var Request = class _Request extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.reqCert = getParametersValue(parameters, REQ_CERT, _Request.defaultValues(REQ_CERT));
    if (SINGLE_REQUEST_EXTENSIONS in parameters) {
      this.singleRequestExtensions = getParametersValue(parameters, SINGLE_REQUEST_EXTENSIONS, _Request.defaultValues(SINGLE_REQUEST_EXTENSIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case REQ_CERT:
        return new CertID();
      case SINGLE_REQUEST_EXTENSIONS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case REQ_CERT:
        return memberValue.isEqual(_Request.defaultValues(memberName));
      case SINGLE_REQUEST_EXTENSIONS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        CertID.schema(names.reqCert || {}),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [Extension.schema(names.extensions || {
            names: {
              blockName: names.singleRequestExtensions || EMPTY_STRING
            }
          })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$a);
    const asn1 = asn1js.compareSchema(schema, schema, _Request.schema({
      names: {
        reqCert: {
          names: {
            blockName: REQ_CERT
          }
        },
        extensions: {
          names: {
            blockName: SINGLE_REQUEST_EXTENSIONS
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.reqCert = new CertID({ schema: asn1.result.reqCert });
    if (SINGLE_REQUEST_EXTENSIONS in asn1.result) {
      this.singleRequestExtensions = Array.from(asn1.result.singleRequestExtensions.valueBlock.value, (element) => new Extension({ schema: element }));
    }
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.reqCert.toSchema());
    if (this.singleRequestExtensions) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.Sequence({
            value: Array.from(this.singleRequestExtensions, (o) => o.toSchema())
          })
        ]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      reqCert: this.reqCert.toJSON()
    };
    if (this.singleRequestExtensions) {
      res.singleRequestExtensions = Array.from(this.singleRequestExtensions, (o) => o.toJSON());
    }
    return res;
  }
};
Request.CLASS_NAME = "Request";
var TBS = "tbs";
var VERSION$5 = "version";
var REQUESTOR_NAME = "requestorName";
var REQUEST_LIST = "requestList";
var REQUEST_EXTENSIONS = "requestExtensions";
var TBS_REQUEST$1 = "TBSRequest";
var TBS_REQUEST_VERSION = `${TBS_REQUEST$1}.${VERSION$5}`;
var TBS_REQUEST_REQUESTOR_NAME = `${TBS_REQUEST$1}.${REQUESTOR_NAME}`;
var TBS_REQUEST_REQUESTS = `${TBS_REQUEST$1}.requests`;
var TBS_REQUEST_REQUEST_EXTENSIONS = `${TBS_REQUEST$1}.${REQUEST_EXTENSIONS}`;
var CLEAR_PROPS$9 = [
  TBS_REQUEST$1,
  TBS_REQUEST_VERSION,
  TBS_REQUEST_REQUESTOR_NAME,
  TBS_REQUEST_REQUESTS,
  TBS_REQUEST_REQUEST_EXTENSIONS
];
var TBSRequest = class _TBSRequest extends PkiObject {
  get tbs() {
    return BufferSourceConverter.toArrayBuffer(this.tbsView);
  }
  set tbs(value) {
    this.tbsView = new Uint8Array(value);
  }
  constructor(parameters = {}) {
    super();
    this.tbsView = new Uint8Array(getParametersValue(parameters, TBS, _TBSRequest.defaultValues(TBS)));
    if (VERSION$5 in parameters) {
      this.version = getParametersValue(parameters, VERSION$5, _TBSRequest.defaultValues(VERSION$5));
    }
    if (REQUESTOR_NAME in parameters) {
      this.requestorName = getParametersValue(parameters, REQUESTOR_NAME, _TBSRequest.defaultValues(REQUESTOR_NAME));
    }
    this.requestList = getParametersValue(parameters, REQUEST_LIST, _TBSRequest.defaultValues(REQUEST_LIST));
    if (REQUEST_EXTENSIONS in parameters) {
      this.requestExtensions = getParametersValue(parameters, REQUEST_EXTENSIONS, _TBSRequest.defaultValues(REQUEST_EXTENSIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TBS:
        return EMPTY_BUFFER;
      case VERSION$5:
        return 0;
      case REQUESTOR_NAME:
        return new GeneralName();
      case REQUEST_LIST:
      case REQUEST_EXTENSIONS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TBS:
        return memberValue.byteLength === 0;
      case VERSION$5:
        return memberValue === _TBSRequest.defaultValues(memberName);
      case REQUESTOR_NAME:
        return memberValue.type === GeneralName.defaultValues("type") && Object.keys(memberValue.value).length === 0;
      case REQUEST_LIST:
      case REQUEST_EXTENSIONS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || TBS_REQUEST$1,
      value: [
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Integer({ name: names.TBSRequestVersion || TBS_REQUEST_VERSION })]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [GeneralName.schema(names.requestorName || {
            names: {
              blockName: TBS_REQUEST_REQUESTOR_NAME
            }
          })]
        }),
        new asn1js.Sequence({
          name: names.requestList || "TBSRequest.requestList",
          value: [
            new asn1js.Repeated({
              name: names.requests || TBS_REQUEST_REQUESTS,
              value: Request.schema(names.requestNames || {})
            })
          ]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [Extensions.schema(names.extensions || {
            names: {
              blockName: names.requestExtensions || TBS_REQUEST_REQUEST_EXTENSIONS
            }
          })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$9);
    const asn1 = asn1js.compareSchema(schema, schema, _TBSRequest.schema());
    AsnError.assertSchema(asn1, this.className);
    this.tbsView = asn1.result.TBSRequest.valueBeforeDecodeView;
    if (TBS_REQUEST_VERSION in asn1.result)
      this.version = asn1.result[TBS_REQUEST_VERSION].valueBlock.valueDec;
    if (TBS_REQUEST_REQUESTOR_NAME in asn1.result)
      this.requestorName = new GeneralName({ schema: asn1.result[TBS_REQUEST_REQUESTOR_NAME] });
    this.requestList = Array.from(asn1.result[TBS_REQUEST_REQUESTS], (element) => new Request({ schema: element }));
    if (TBS_REQUEST_REQUEST_EXTENSIONS in asn1.result)
      this.requestExtensions = Array.from(asn1.result[TBS_REQUEST_REQUEST_EXTENSIONS].valueBlock.value, (element) => new Extension({ schema: element }));
  }
  toSchema(encodeFlag = false) {
    let tbsSchema;
    if (encodeFlag === false) {
      if (this.tbsView.byteLength === 0)
        return _TBSRequest.schema();
      const asn1 = asn1js.fromBER(this.tbsView);
      AsnError.assert(asn1, "TBS Request");
      if (!(asn1.result instanceof asn1js.Sequence)) {
        throw new Error("ASN.1 result should be SEQUENCE");
      }
      tbsSchema = asn1.result;
    } else {
      const outputArray = [];
      if (this.version !== void 0) {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Integer({ value: this.version })]
        }));
      }
      if (this.requestorName) {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [this.requestorName.toSchema()]
        }));
      }
      outputArray.push(new asn1js.Sequence({
        value: Array.from(this.requestList, (o) => o.toSchema())
      }));
      if (this.requestExtensions) {
        outputArray.push(new asn1js.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [
            new asn1js.Sequence({
              value: Array.from(this.requestExtensions, (o) => o.toSchema())
            })
          ]
        }));
      }
      tbsSchema = new asn1js.Sequence({
        value: outputArray
      });
    }
    return tbsSchema;
  }
  toJSON() {
    const res = {};
    if (this.version != void 0)
      res.version = this.version;
    if (this.requestorName) {
      res.requestorName = this.requestorName.toJSON();
    }
    res.requestList = Array.from(this.requestList, (o) => o.toJSON());
    if (this.requestExtensions) {
      res.requestExtensions = Array.from(this.requestExtensions, (o) => o.toJSON());
    }
    return res;
  }
};
TBSRequest.CLASS_NAME = "TBSRequest";
var SIGNATURE_ALGORITHM$1 = "signatureAlgorithm";
var SIGNATURE$1 = "signature";
var CERTS = "certs";
var Signature = class _Signature extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$1, _Signature.defaultValues(SIGNATURE_ALGORITHM$1));
    this.signature = getParametersValue(parameters, SIGNATURE$1, _Signature.defaultValues(SIGNATURE$1));
    if (CERTS in parameters) {
      this.certs = getParametersValue(parameters, CERTS, _Signature.defaultValues(CERTS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case SIGNATURE_ALGORITHM$1:
        return new AlgorithmIdentifier();
      case SIGNATURE$1:
        return new asn1js.BitString();
      case CERTS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case SIGNATURE_ALGORITHM$1:
        return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
      case SIGNATURE$1:
        return memberValue.isEqual(_Signature.defaultValues(memberName));
      case CERTS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
        new asn1js.BitString({ name: names.signature || EMPTY_STRING }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            new asn1js.Sequence({
              value: [new asn1js.Repeated({
                name: names.certs || EMPTY_STRING,
                value: Certificate.schema({})
              })]
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      SIGNATURE_ALGORITHM$1,
      SIGNATURE$1,
      CERTS
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _Signature.schema({
      names: {
        signatureAlgorithm: {
          names: {
            blockName: SIGNATURE_ALGORITHM$1
          }
        },
        signature: SIGNATURE$1,
        certs: CERTS
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
    this.signature = asn1.result.signature;
    if (CERTS in asn1.result)
      this.certs = Array.from(asn1.result.certs, (element) => new Certificate({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.signatureAlgorithm.toSchema());
    outputArray.push(this.signature);
    if (this.certs) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          new asn1js.Sequence({
            value: Array.from(this.certs, (o) => o.toSchema())
          })
        ]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signature: this.signature.toJSON()
    };
    if (this.certs) {
      res.certs = Array.from(this.certs, (o) => o.toJSON());
    }
    return res;
  }
};
Signature.CLASS_NAME = "Signature";
var TBS_REQUEST = "tbsRequest";
var OPTIONAL_SIGNATURE = "optionalSignature";
var CLEAR_PROPS$8 = [
  TBS_REQUEST,
  OPTIONAL_SIGNATURE
];
var OCSPRequest = class _OCSPRequest extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.tbsRequest = getParametersValue(parameters, TBS_REQUEST, _OCSPRequest.defaultValues(TBS_REQUEST));
    if (OPTIONAL_SIGNATURE in parameters) {
      this.optionalSignature = getParametersValue(parameters, OPTIONAL_SIGNATURE, _OCSPRequest.defaultValues(OPTIONAL_SIGNATURE));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TBS_REQUEST:
        return new TBSRequest();
      case OPTIONAL_SIGNATURE:
        return new Signature();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TBS_REQUEST:
        return TBSRequest.compareWithDefault("tbs", memberValue.tbs) && TBSRequest.compareWithDefault("version", memberValue.version) && TBSRequest.compareWithDefault("requestorName", memberValue.requestorName) && TBSRequest.compareWithDefault("requestList", memberValue.requestList) && TBSRequest.compareWithDefault("requestExtensions", memberValue.requestExtensions);
      case OPTIONAL_SIGNATURE:
        return Signature.compareWithDefault("signatureAlgorithm", memberValue.signatureAlgorithm) && Signature.compareWithDefault("signature", memberValue.signature) && Signature.compareWithDefault("certs", memberValue.certs);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || "OCSPRequest",
      value: [
        TBSRequest.schema(names.tbsRequest || {
          names: {
            blockName: TBS_REQUEST
          }
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            Signature.schema(names.optionalSignature || {
              names: {
                blockName: OPTIONAL_SIGNATURE
              }
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$8);
    const asn1 = asn1js.compareSchema(schema, schema, _OCSPRequest.schema());
    AsnError.assertSchema(asn1, this.className);
    this.tbsRequest = new TBSRequest({ schema: asn1.result.tbsRequest });
    if (OPTIONAL_SIGNATURE in asn1.result)
      this.optionalSignature = new Signature({ schema: asn1.result.optionalSignature });
  }
  toSchema(encodeFlag = false) {
    const outputArray = [];
    outputArray.push(this.tbsRequest.toSchema(encodeFlag));
    if (this.optionalSignature)
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [
          this.optionalSignature.toSchema()
        ]
      }));
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      tbsRequest: this.tbsRequest.toJSON()
    };
    if (this.optionalSignature) {
      res.optionalSignature = this.optionalSignature.toJSON();
    }
    return res;
  }
  async createForCertificate(certificate, parameters, crypto9 = getCrypto2(true)) {
    const certID = new CertID();
    await certID.createForCertificate(certificate, parameters, crypto9);
    this.tbsRequest.requestList.push(new Request({
      reqCert: certID
    }));
  }
  async sign(privateKey, hashAlgorithm = "SHA-1", crypto9 = getCrypto2(true)) {
    ParameterError.assertEmpty(privateKey, "privateKey", "OCSPRequest.sign method");
    if (!this.optionalSignature) {
      throw new Error('Need to create "optionalSignature" field before signing');
    }
    const signatureParams = await crypto9.getSignatureParameters(privateKey, hashAlgorithm);
    const parameters = signatureParams.parameters;
    this.optionalSignature.signatureAlgorithm = signatureParams.signatureAlgorithm;
    const tbs = this.tbsRequest.toSchema(true).toBER(false);
    const signature = await crypto9.signWithPrivateKey(tbs, privateKey, parameters);
    this.optionalSignature.signature = new asn1js.BitString({ valueHex: signature });
  }
  verify() {
  }
};
OCSPRequest.CLASS_NAME = "OCSPRequest";
var RESPONSE_TYPE = "responseType";
var RESPONSE = "response";
var CLEAR_PROPS$7 = [
  RESPONSE_TYPE,
  RESPONSE
];
var ResponseBytes = class _ResponseBytes extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.responseType = getParametersValue(parameters, RESPONSE_TYPE, _ResponseBytes.defaultValues(RESPONSE_TYPE));
    this.response = getParametersValue(parameters, RESPONSE, _ResponseBytes.defaultValues(RESPONSE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case RESPONSE_TYPE:
        return EMPTY_STRING;
      case RESPONSE:
        return new asn1js.OctetString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case RESPONSE_TYPE:
        return memberValue === EMPTY_STRING;
      case RESPONSE:
        return memberValue.isEqual(_ResponseBytes.defaultValues(memberName));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.ObjectIdentifier({ name: names.responseType || EMPTY_STRING }),
        new asn1js.OctetString({ name: names.response || EMPTY_STRING })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$7);
    const asn1 = asn1js.compareSchema(schema, schema, _ResponseBytes.schema({
      names: {
        responseType: RESPONSE_TYPE,
        response: RESPONSE
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.responseType = asn1.result.responseType.valueBlock.toString();
    this.response = asn1.result.response;
  }
  toSchema() {
    return new asn1js.Sequence({
      value: [
        new asn1js.ObjectIdentifier({ value: this.responseType }),
        this.response
      ]
    });
  }
  toJSON() {
    return {
      responseType: this.responseType,
      response: this.response.toJSON()
    };
  }
};
ResponseBytes.CLASS_NAME = "ResponseBytes";
var RESPONSE_STATUS = "responseStatus";
var RESPONSE_BYTES = "responseBytes";
var OCSPResponse = class _OCSPResponse extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.responseStatus = getParametersValue(parameters, RESPONSE_STATUS, _OCSPResponse.defaultValues(RESPONSE_STATUS));
    if (RESPONSE_BYTES in parameters) {
      this.responseBytes = getParametersValue(parameters, RESPONSE_BYTES, _OCSPResponse.defaultValues(RESPONSE_BYTES));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case RESPONSE_STATUS:
        return new asn1js.Enumerated();
      case RESPONSE_BYTES:
        return new ResponseBytes();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case RESPONSE_STATUS:
        return memberValue.isEqual(_OCSPResponse.defaultValues(memberName));
      case RESPONSE_BYTES:
        return ResponseBytes.compareWithDefault("responseType", memberValue.responseType) && ResponseBytes.compareWithDefault("response", memberValue.response);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || "OCSPResponse",
      value: [
        new asn1js.Enumerated({ name: names.responseStatus || RESPONSE_STATUS }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [
            ResponseBytes.schema(names.responseBytes || {
              names: {
                blockName: RESPONSE_BYTES
              }
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, [
      RESPONSE_STATUS,
      RESPONSE_BYTES
    ]);
    const asn1 = asn1js.compareSchema(schema, schema, _OCSPResponse.schema());
    AsnError.assertSchema(asn1, this.className);
    this.responseStatus = asn1.result.responseStatus;
    if (RESPONSE_BYTES in asn1.result)
      this.responseBytes = new ResponseBytes({ schema: asn1.result.responseBytes });
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.responseStatus);
    if (this.responseBytes) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [this.responseBytes.toSchema()]
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      responseStatus: this.responseStatus.toJSON()
    };
    if (this.responseBytes) {
      res.responseBytes = this.responseBytes.toJSON();
    }
    return res;
  }
  async getCertificateStatus(certificate, issuerCertificate, crypto9 = getCrypto2(true)) {
    let basicResponse;
    const result = {
      isForCertificate: false,
      status: 2
    };
    if (!this.responseBytes)
      return result;
    if (this.responseBytes.responseType !== id_PKIX_OCSP_Basic)
      return result;
    try {
      const asn1Basic = asn1js.fromBER(this.responseBytes.response.valueBlock.valueHexView);
      AsnError.assert(asn1Basic, "Basic OCSP response");
      basicResponse = new BasicOCSPResponse({ schema: asn1Basic.result });
    } catch (ex) {
      return result;
    }
    return basicResponse.getCertificateStatus(certificate, issuerCertificate, crypto9);
  }
  async sign(privateKey, hashAlgorithm, crypto9 = getCrypto2(true)) {
    var _a3;
    if (this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic) {
      const basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
      return basicResponse.sign(privateKey, hashAlgorithm, crypto9);
    }
    throw new Error(`Unknown ResponseBytes type: ${((_a3 = this.responseBytes) === null || _a3 === void 0 ? void 0 : _a3.responseType) || "Unknown"}`);
  }
  async verify(issuerCertificate = null, crypto9 = getCrypto2(true)) {
    var _a3;
    if (RESPONSE_BYTES in this === false)
      throw new Error("Empty ResponseBytes field");
    if (this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic) {
      const basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
      if (issuerCertificate !== null) {
        if (!basicResponse.certs) {
          basicResponse.certs = [];
        }
        basicResponse.certs.push(issuerCertificate);
      }
      return basicResponse.verify({}, crypto9);
    }
    throw new Error(`Unknown ResponseBytes type: ${((_a3 = this.responseBytes) === null || _a3 === void 0 ? void 0 : _a3.responseType) || "Unknown"}`);
  }
};
OCSPResponse.CLASS_NAME = "OCSPResponse";
var TYPE = "type";
var ATTRIBUTES = "attributes";
var ENCODED_VALUE = "encodedValue";
var CLEAR_PROPS$6 = [
  ATTRIBUTES
];
var SignedAndUnsignedAttributes = class _SignedAndUnsignedAttributes extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.type = getParametersValue(parameters, TYPE, _SignedAndUnsignedAttributes.defaultValues(TYPE));
    this.attributes = getParametersValue(parameters, ATTRIBUTES, _SignedAndUnsignedAttributes.defaultValues(ATTRIBUTES));
    this.encodedValue = getParametersValue(parameters, ENCODED_VALUE, _SignedAndUnsignedAttributes.defaultValues(ENCODED_VALUE));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case TYPE:
        return -1;
      case ATTRIBUTES:
        return [];
      case ENCODED_VALUE:
        return EMPTY_BUFFER;
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case TYPE:
        return memberValue === _SignedAndUnsignedAttributes.defaultValues(TYPE);
      case ATTRIBUTES:
        return memberValue.length === 0;
      case ENCODED_VALUE:
        return memberValue.byteLength === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Constructed({
      name: names.blockName || EMPTY_STRING,
      optional: true,
      idBlock: {
        tagClass: 3,
        tagNumber: names.tagNumber || 0
      },
      value: [
        new asn1js.Repeated({
          name: names.attributes || EMPTY_STRING,
          value: Attribute.schema()
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$6);
    const asn1 = asn1js.compareSchema(schema, schema, _SignedAndUnsignedAttributes.schema({
      names: {
        tagNumber: this.type,
        attributes: ATTRIBUTES
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.type = asn1.result.idBlock.tagNumber;
    this.encodedValue = BufferSourceConverter.toArrayBuffer(asn1.result.valueBeforeDecodeView);
    const encodedView = new Uint8Array(this.encodedValue);
    encodedView[0] = 49;
    if (ATTRIBUTES in asn1.result === false) {
      if (this.type === 0)
        throw new Error("Wrong structure of SignedUnsignedAttributes");
      else
        return;
    }
    this.attributes = Array.from(asn1.result.attributes, (element) => new Attribute({ schema: element }));
  }
  toSchema() {
    if (_SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || _SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes))
      throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');
    return new asn1js.Constructed({
      optional: true,
      idBlock: {
        tagClass: 3,
        tagNumber: this.type
      },
      value: Array.from(this.attributes, (o) => o.toSchema())
    });
  }
  toJSON() {
    if (_SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || _SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes))
      throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');
    return {
      type: this.type,
      attributes: Array.from(this.attributes, (o) => o.toJSON())
    };
  }
};
SignedAndUnsignedAttributes.CLASS_NAME = "SignedAndUnsignedAttributes";
var VERSION$4 = "version";
var SID = "sid";
var DIGEST_ALGORITHM = "digestAlgorithm";
var SIGNED_ATTRS = "signedAttrs";
var SIGNATURE_ALGORITHM = "signatureAlgorithm";
var SIGNATURE = "signature";
var UNSIGNED_ATTRS = "unsignedAttrs";
var SIGNER_INFO = "SignerInfo";
var SIGNER_INFO_VERSION = `${SIGNER_INFO}.${VERSION$4}`;
var SIGNER_INFO_SID = `${SIGNER_INFO}.${SID}`;
var SIGNER_INFO_DIGEST_ALGORITHM = `${SIGNER_INFO}.${DIGEST_ALGORITHM}`;
var SIGNER_INFO_SIGNED_ATTRS = `${SIGNER_INFO}.${SIGNED_ATTRS}`;
var SIGNER_INFO_SIGNATURE_ALGORITHM = `${SIGNER_INFO}.${SIGNATURE_ALGORITHM}`;
var SIGNER_INFO_SIGNATURE = `${SIGNER_INFO}.${SIGNATURE}`;
var SIGNER_INFO_UNSIGNED_ATTRS = `${SIGNER_INFO}.${UNSIGNED_ATTRS}`;
var CLEAR_PROPS$5 = [
  SIGNER_INFO_VERSION,
  SIGNER_INFO_SID,
  SIGNER_INFO_DIGEST_ALGORITHM,
  SIGNER_INFO_SIGNED_ATTRS,
  SIGNER_INFO_SIGNATURE_ALGORITHM,
  SIGNER_INFO_SIGNATURE,
  SIGNER_INFO_UNSIGNED_ATTRS
];
var SignerInfo = class _SignerInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$4, _SignerInfo.defaultValues(VERSION$4));
    this.sid = getParametersValue(parameters, SID, _SignerInfo.defaultValues(SID));
    this.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM, _SignerInfo.defaultValues(DIGEST_ALGORITHM));
    if (SIGNED_ATTRS in parameters) {
      this.signedAttrs = getParametersValue(parameters, SIGNED_ATTRS, _SignerInfo.defaultValues(SIGNED_ATTRS));
    }
    this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM, _SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
    this.signature = getParametersValue(parameters, SIGNATURE, _SignerInfo.defaultValues(SIGNATURE));
    if (UNSIGNED_ATTRS in parameters) {
      this.unsignedAttrs = getParametersValue(parameters, UNSIGNED_ATTRS, _SignerInfo.defaultValues(UNSIGNED_ATTRS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$4:
        return 0;
      case SID:
        return new asn1js.Any();
      case DIGEST_ALGORITHM:
        return new AlgorithmIdentifier();
      case SIGNED_ATTRS:
        return new SignedAndUnsignedAttributes({ type: 0 });
      case SIGNATURE_ALGORITHM:
        return new AlgorithmIdentifier();
      case SIGNATURE:
        return new asn1js.OctetString();
      case UNSIGNED_ATTRS:
        return new SignedAndUnsignedAttributes({ type: 1 });
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$4:
        return _SignerInfo.defaultValues(VERSION$4) === memberValue;
      case SID:
        return memberValue instanceof asn1js.Any;
      case DIGEST_ALGORITHM:
        if (memberValue instanceof AlgorithmIdentifier === false)
          return false;
        return memberValue.isEqual(_SignerInfo.defaultValues(DIGEST_ALGORITHM));
      case SIGNED_ATTRS:
        return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
      case SIGNATURE_ALGORITHM:
        if (memberValue instanceof AlgorithmIdentifier === false)
          return false;
        return memberValue.isEqual(_SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
      case SIGNATURE:
      case UNSIGNED_ATTRS:
        return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: SIGNER_INFO,
      value: [
        new asn1js.Integer({ name: names.version || SIGNER_INFO_VERSION }),
        new asn1js.Choice({
          value: [
            IssuerAndSerialNumber.schema(names.sidSchema || {
              names: {
                blockName: SIGNER_INFO_SID
              }
            }),
            new asn1js.Choice({
              value: [
                new asn1js.Constructed({
                  optional: true,
                  name: names.sid || SIGNER_INFO_SID,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [new asn1js.OctetString()]
                }),
                new asn1js.Primitive({
                  optional: true,
                  name: names.sid || SIGNER_INFO_SID,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  }
                })
              ]
            })
          ]
        }),
        AlgorithmIdentifier.schema(names.digestAlgorithm || {
          names: {
            blockName: SIGNER_INFO_DIGEST_ALGORITHM
          }
        }),
        SignedAndUnsignedAttributes.schema(names.signedAttrs || {
          names: {
            blockName: SIGNER_INFO_SIGNED_ATTRS,
            tagNumber: 0
          }
        }),
        AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: SIGNER_INFO_SIGNATURE_ALGORITHM
          }
        }),
        new asn1js.OctetString({ name: names.signature || SIGNER_INFO_SIGNATURE }),
        SignedAndUnsignedAttributes.schema(names.unsignedAttrs || {
          names: {
            blockName: SIGNER_INFO_UNSIGNED_ATTRS,
            tagNumber: 1
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$5);
    const asn1 = asn1js.compareSchema(schema, schema, _SignerInfo.schema());
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result[SIGNER_INFO_VERSION].valueBlock.valueDec;
    const currentSid = asn1.result[SIGNER_INFO_SID];
    if (currentSid.idBlock.tagClass === 1)
      this.sid = new IssuerAndSerialNumber({ schema: currentSid });
    else
      this.sid = currentSid;
    this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[SIGNER_INFO_DIGEST_ALGORITHM] });
    if (SIGNER_INFO_SIGNED_ATTRS in asn1.result)
      this.signedAttrs = new SignedAndUnsignedAttributes({ type: 0, schema: asn1.result[SIGNER_INFO_SIGNED_ATTRS] });
    this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[SIGNER_INFO_SIGNATURE_ALGORITHM] });
    this.signature = asn1.result[SIGNER_INFO_SIGNATURE];
    if (SIGNER_INFO_UNSIGNED_ATTRS in asn1.result)
      this.unsignedAttrs = new SignedAndUnsignedAttributes({ type: 1, schema: asn1.result[SIGNER_INFO_UNSIGNED_ATTRS] });
  }
  toSchema() {
    if (_SignerInfo.compareWithDefault(SID, this.sid))
      throw new Error('Incorrectly initialized "SignerInfo" class');
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    if (this.sid instanceof IssuerAndSerialNumber)
      outputArray.push(this.sid.toSchema());
    else
      outputArray.push(this.sid);
    outputArray.push(this.digestAlgorithm.toSchema());
    if (this.signedAttrs) {
      if (_SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false)
        outputArray.push(this.signedAttrs.toSchema());
    }
    outputArray.push(this.signatureAlgorithm.toSchema());
    outputArray.push(this.signature);
    if (this.unsignedAttrs) {
      if (_SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false)
        outputArray.push(this.unsignedAttrs.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    if (_SignerInfo.compareWithDefault(SID, this.sid)) {
      throw new Error('Incorrectly initialized "SignerInfo" class');
    }
    const res = {
      version: this.version,
      digestAlgorithm: this.digestAlgorithm.toJSON(),
      signatureAlgorithm: this.signatureAlgorithm.toJSON(),
      signature: this.signature.toJSON()
    };
    if (!(this.sid instanceof asn1js.Any))
      res.sid = this.sid.toJSON();
    if (this.signedAttrs && _SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false) {
      res.signedAttrs = this.signedAttrs.toJSON();
    }
    if (this.unsignedAttrs && _SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false) {
      res.unsignedAttrs = this.unsignedAttrs.toJSON();
    }
    return res;
  }
};
SignerInfo.CLASS_NAME = "SignerInfo";
var VERSION$3 = "version";
var POLICY = "policy";
var MESSAGE_IMPRINT$1 = "messageImprint";
var SERIAL_NUMBER = "serialNumber";
var GEN_TIME = "genTime";
var ORDERING = "ordering";
var NONCE$1 = "nonce";
var ACCURACY = "accuracy";
var TSA = "tsa";
var EXTENSIONS$1 = "extensions";
var TST_INFO = "TSTInfo";
var TST_INFO_VERSION = `${TST_INFO}.${VERSION$3}`;
var TST_INFO_POLICY = `${TST_INFO}.${POLICY}`;
var TST_INFO_MESSAGE_IMPRINT = `${TST_INFO}.${MESSAGE_IMPRINT$1}`;
var TST_INFO_SERIAL_NUMBER = `${TST_INFO}.${SERIAL_NUMBER}`;
var TST_INFO_GEN_TIME = `${TST_INFO}.${GEN_TIME}`;
var TST_INFO_ACCURACY = `${TST_INFO}.${ACCURACY}`;
var TST_INFO_ORDERING = `${TST_INFO}.${ORDERING}`;
var TST_INFO_NONCE = `${TST_INFO}.${NONCE$1}`;
var TST_INFO_TSA = `${TST_INFO}.${TSA}`;
var TST_INFO_EXTENSIONS = `${TST_INFO}.${EXTENSIONS$1}`;
var CLEAR_PROPS$4 = [
  TST_INFO_VERSION,
  TST_INFO_POLICY,
  TST_INFO_MESSAGE_IMPRINT,
  TST_INFO_SERIAL_NUMBER,
  TST_INFO_GEN_TIME,
  TST_INFO_ACCURACY,
  TST_INFO_ORDERING,
  TST_INFO_NONCE,
  TST_INFO_TSA,
  TST_INFO_EXTENSIONS
];
var TSTInfo = class _TSTInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$3, _TSTInfo.defaultValues(VERSION$3));
    this.policy = getParametersValue(parameters, POLICY, _TSTInfo.defaultValues(POLICY));
    this.messageImprint = getParametersValue(parameters, MESSAGE_IMPRINT$1, _TSTInfo.defaultValues(MESSAGE_IMPRINT$1));
    this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER, _TSTInfo.defaultValues(SERIAL_NUMBER));
    this.genTime = getParametersValue(parameters, GEN_TIME, _TSTInfo.defaultValues(GEN_TIME));
    if (ACCURACY in parameters) {
      this.accuracy = getParametersValue(parameters, ACCURACY, _TSTInfo.defaultValues(ACCURACY));
    }
    if (ORDERING in parameters) {
      this.ordering = getParametersValue(parameters, ORDERING, _TSTInfo.defaultValues(ORDERING));
    }
    if (NONCE$1 in parameters) {
      this.nonce = getParametersValue(parameters, NONCE$1, _TSTInfo.defaultValues(NONCE$1));
    }
    if (TSA in parameters) {
      this.tsa = getParametersValue(parameters, TSA, _TSTInfo.defaultValues(TSA));
    }
    if (EXTENSIONS$1 in parameters) {
      this.extensions = getParametersValue(parameters, EXTENSIONS$1, _TSTInfo.defaultValues(EXTENSIONS$1));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$3:
        return 0;
      case POLICY:
        return EMPTY_STRING;
      case MESSAGE_IMPRINT$1:
        return new MessageImprint();
      case SERIAL_NUMBER:
        return new asn1js.Integer();
      case GEN_TIME:
        return new Date(0, 0, 0);
      case ACCURACY:
        return new Accuracy();
      case ORDERING:
        return false;
      case NONCE$1:
        return new asn1js.Integer();
      case TSA:
        return new GeneralName();
      case EXTENSIONS$1:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$3:
      case POLICY:
      case GEN_TIME:
      case ORDERING:
        return memberValue === _TSTInfo.defaultValues(ORDERING);
      case MESSAGE_IMPRINT$1:
        return MessageImprint.compareWithDefault(HASH_ALGORITHM, memberValue.hashAlgorithm) && MessageImprint.compareWithDefault(HASHED_MESSAGE, memberValue.hashedMessage);
      case SERIAL_NUMBER:
      case NONCE$1:
        return memberValue.isEqual(_TSTInfo.defaultValues(NONCE$1));
      case ACCURACY:
        return Accuracy.compareWithDefault(SECONDS, memberValue.seconds) && Accuracy.compareWithDefault(MILLIS, memberValue.millis) && Accuracy.compareWithDefault(MICROS, memberValue.micros);
      case TSA:
        return GeneralName.compareWithDefault(TYPE$4, memberValue.type) && GeneralName.compareWithDefault(VALUE$5, memberValue.value);
      case EXTENSIONS$1:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || TST_INFO,
      value: [
        new asn1js.Integer({ name: names.version || TST_INFO_VERSION }),
        new asn1js.ObjectIdentifier({ name: names.policy || TST_INFO_POLICY }),
        MessageImprint.schema(names.messageImprint || {
          names: {
            blockName: TST_INFO_MESSAGE_IMPRINT
          }
        }),
        new asn1js.Integer({ name: names.serialNumber || TST_INFO_SERIAL_NUMBER }),
        new asn1js.GeneralizedTime({ name: names.genTime || TST_INFO_GEN_TIME }),
        Accuracy.schema(names.accuracy || {
          names: {
            blockName: TST_INFO_ACCURACY
          }
        }),
        new asn1js.Boolean({
          name: names.ordering || TST_INFO_ORDERING,
          optional: true
        }),
        new asn1js.Integer({
          name: names.nonce || TST_INFO_NONCE,
          optional: true
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [GeneralName.schema(names.tsa || {
            names: {
              blockName: TST_INFO_TSA
            }
          })]
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: [
            new asn1js.Repeated({
              name: names.extensions || TST_INFO_EXTENSIONS,
              value: Extension.schema(names.extension || {})
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$4);
    const asn1 = asn1js.compareSchema(schema, schema, _TSTInfo.schema());
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result[TST_INFO_VERSION].valueBlock.valueDec;
    this.policy = asn1.result[TST_INFO_POLICY].valueBlock.toString();
    this.messageImprint = new MessageImprint({ schema: asn1.result[TST_INFO_MESSAGE_IMPRINT] });
    this.serialNumber = asn1.result[TST_INFO_SERIAL_NUMBER];
    this.genTime = asn1.result[TST_INFO_GEN_TIME].toDate();
    if (TST_INFO_ACCURACY in asn1.result)
      this.accuracy = new Accuracy({ schema: asn1.result[TST_INFO_ACCURACY] });
    if (TST_INFO_ORDERING in asn1.result)
      this.ordering = asn1.result[TST_INFO_ORDERING].valueBlock.value;
    if (TST_INFO_NONCE in asn1.result)
      this.nonce = asn1.result[TST_INFO_NONCE];
    if (TST_INFO_TSA in asn1.result)
      this.tsa = new GeneralName({ schema: asn1.result[TST_INFO_TSA] });
    if (TST_INFO_EXTENSIONS in asn1.result)
      this.extensions = Array.from(asn1.result[TST_INFO_EXTENSIONS], (element) => new Extension({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    outputArray.push(new asn1js.ObjectIdentifier({ value: this.policy }));
    outputArray.push(this.messageImprint.toSchema());
    outputArray.push(this.serialNumber);
    outputArray.push(new asn1js.GeneralizedTime({ valueDate: this.genTime }));
    if (this.accuracy)
      outputArray.push(this.accuracy.toSchema());
    if (this.ordering !== void 0)
      outputArray.push(new asn1js.Boolean({ value: this.ordering }));
    if (this.nonce)
      outputArray.push(this.nonce);
    if (this.tsa) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: [this.tsa.toSchema()]
      }));
    }
    if (this.extensions) {
      outputArray.push(new asn1js.Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: Array.from(this.extensions, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      policy: this.policy,
      messageImprint: this.messageImprint.toJSON(),
      serialNumber: this.serialNumber.toJSON(),
      genTime: this.genTime
    };
    if (this.accuracy)
      res.accuracy = this.accuracy.toJSON();
    if (this.ordering !== void 0)
      res.ordering = this.ordering;
    if (this.nonce)
      res.nonce = this.nonce.toJSON();
    if (this.tsa)
      res.tsa = this.tsa.toJSON();
    if (this.extensions)
      res.extensions = Array.from(this.extensions, (o) => o.toJSON());
    return res;
  }
  async verify(params, crypto9 = getCrypto2(true)) {
    if (!params.data) {
      throw new Error('"data" is a mandatory attribute for TST_INFO verification');
    }
    const data = params.data;
    if (params.notBefore) {
      if (this.genTime < params.notBefore)
        throw new Error("Generation time for TSTInfo object is less than notBefore value");
    }
    if (params.notAfter) {
      if (this.genTime > params.notAfter)
        throw new Error("Generation time for TSTInfo object is more than notAfter value");
    }
    const shaAlgorithm = crypto9.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId, true, "MessageImprint.hashAlgorithm");
    const hash3 = await crypto9.digest(shaAlgorithm.name, new Uint8Array(data));
    return BufferSourceConverter.isEqual(hash3, this.messageImprint.hashedMessage.valueBlock.valueHexView);
  }
};
TSTInfo.CLASS_NAME = "TSTInfo";
var VERSION$2 = "version";
var DIGEST_ALGORITHMS = "digestAlgorithms";
var ENCAP_CONTENT_INFO = "encapContentInfo";
var CERTIFICATES = "certificates";
var CRLS = "crls";
var SIGNER_INFOS = "signerInfos";
var OCSPS = "ocsps";
var SIGNED_DATA = "SignedData";
var SIGNED_DATA_VERSION = `${SIGNED_DATA}.${VERSION$2}`;
var SIGNED_DATA_DIGEST_ALGORITHMS = `${SIGNED_DATA}.${DIGEST_ALGORITHMS}`;
var SIGNED_DATA_ENCAP_CONTENT_INFO = `${SIGNED_DATA}.${ENCAP_CONTENT_INFO}`;
var SIGNED_DATA_CERTIFICATES = `${SIGNED_DATA}.${CERTIFICATES}`;
var SIGNED_DATA_CRLS = `${SIGNED_DATA}.${CRLS}`;
var SIGNED_DATA_SIGNER_INFOS = `${SIGNED_DATA}.${SIGNER_INFOS}`;
var CLEAR_PROPS$3 = [
  SIGNED_DATA_VERSION,
  SIGNED_DATA_DIGEST_ALGORITHMS,
  SIGNED_DATA_ENCAP_CONTENT_INFO,
  SIGNED_DATA_CERTIFICATES,
  SIGNED_DATA_CRLS,
  SIGNED_DATA_SIGNER_INFOS
];
var SignedDataVerifyError = class extends Error {
  constructor({ message, code: code4 = 0, date = /* @__PURE__ */ new Date(), signatureVerified = null, signerCertificate = null, signerCertificateVerified = null, timestampSerial = null, certificatePath = [] }) {
    super(message);
    this.name = "SignedDataVerifyError";
    this.date = date;
    this.code = code4;
    this.timestampSerial = timestampSerial;
    this.signatureVerified = signatureVerified;
    this.signerCertificate = signerCertificate;
    this.signerCertificateVerified = signerCertificateVerified;
    this.certificatePath = certificatePath;
  }
};
var SignedData = class _SignedData extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$2, _SignedData.defaultValues(VERSION$2));
    this.digestAlgorithms = getParametersValue(parameters, DIGEST_ALGORITHMS, _SignedData.defaultValues(DIGEST_ALGORITHMS));
    this.encapContentInfo = getParametersValue(parameters, ENCAP_CONTENT_INFO, _SignedData.defaultValues(ENCAP_CONTENT_INFO));
    if (CERTIFICATES in parameters) {
      this.certificates = getParametersValue(parameters, CERTIFICATES, _SignedData.defaultValues(CERTIFICATES));
    }
    if (CRLS in parameters) {
      this.crls = getParametersValue(parameters, CRLS, _SignedData.defaultValues(CRLS));
    }
    if (OCSPS in parameters) {
      this.ocsps = getParametersValue(parameters, OCSPS, _SignedData.defaultValues(OCSPS));
    }
    this.signerInfos = getParametersValue(parameters, SIGNER_INFOS, _SignedData.defaultValues(SIGNER_INFOS));
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$2:
        return 0;
      case DIGEST_ALGORITHMS:
        return [];
      case ENCAP_CONTENT_INFO:
        return new EncapsulatedContentInfo();
      case CERTIFICATES:
        return [];
      case CRLS:
        return [];
      case OCSPS:
        return [];
      case SIGNER_INFOS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$2:
        return memberValue === _SignedData.defaultValues(VERSION$2);
      case ENCAP_CONTENT_INFO:
        return EncapsulatedContentInfo.compareWithDefault("eContentType", memberValue.eContentType) && EncapsulatedContentInfo.compareWithDefault("eContent", memberValue.eContent);
      case DIGEST_ALGORITHMS:
      case CERTIFICATES:
      case CRLS:
      case OCSPS:
      case SIGNER_INFOS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    if (names.optional === void 0) {
      names.optional = false;
    }
    return new asn1js.Sequence({
      name: names.blockName || SIGNED_DATA,
      optional: names.optional,
      value: [
        new asn1js.Integer({ name: names.version || SIGNED_DATA_VERSION }),
        new asn1js.Set({
          value: [
            new asn1js.Repeated({
              name: names.digestAlgorithms || SIGNED_DATA_DIGEST_ALGORITHMS,
              value: AlgorithmIdentifier.schema()
            })
          ]
        }),
        EncapsulatedContentInfo.schema(names.encapContentInfo || {
          names: {
            blockName: SIGNED_DATA_ENCAP_CONTENT_INFO
          }
        }),
        new asn1js.Constructed({
          name: names.certificates || SIGNED_DATA_CERTIFICATES,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: CertificateSet.schema().valueBlock.value
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 1
          },
          value: RevocationInfoChoices.schema(names.crls || {
            names: {
              crls: SIGNED_DATA_CRLS
            }
          }).valueBlock.value
        }),
        new asn1js.Set({
          value: [
            new asn1js.Repeated({
              name: names.signerInfos || SIGNED_DATA_SIGNER_INFOS,
              value: SignerInfo.schema()
            })
          ]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$3);
    const asn1 = asn1js.compareSchema(schema, schema, _SignedData.schema());
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result[SIGNED_DATA_VERSION].valueBlock.valueDec;
    if (SIGNED_DATA_DIGEST_ALGORITHMS in asn1.result)
      this.digestAlgorithms = Array.from(asn1.result[SIGNED_DATA_DIGEST_ALGORITHMS], (algorithm) => new AlgorithmIdentifier({ schema: algorithm }));
    this.encapContentInfo = new EncapsulatedContentInfo({ schema: asn1.result[SIGNED_DATA_ENCAP_CONTENT_INFO] });
    if (SIGNED_DATA_CERTIFICATES in asn1.result) {
      const certificateSet = new CertificateSet({
        schema: new asn1js.Set({
          value: asn1.result[SIGNED_DATA_CERTIFICATES].valueBlock.value
        })
      });
      this.certificates = certificateSet.certificates.slice(0);
    }
    if (SIGNED_DATA_CRLS in asn1.result) {
      this.crls = Array.from(asn1.result[SIGNED_DATA_CRLS], (crl) => {
        if (crl.idBlock.tagClass === 1)
          return new CertificateRevocationList({ schema: crl });
        crl.idBlock.tagClass = 1;
        crl.idBlock.tagNumber = 16;
        return new OtherRevocationInfoFormat({ schema: crl });
      });
    }
    if (SIGNED_DATA_SIGNER_INFOS in asn1.result)
      this.signerInfos = Array.from(asn1.result[SIGNED_DATA_SIGNER_INFOS], (signerInfoSchema) => new SignerInfo({ schema: signerInfoSchema }));
  }
  toSchema(encodeFlag = false) {
    const outputArray = [];
    if (this.certificates && this.certificates.length && this.certificates.some((o) => o instanceof OtherCertificateFormat) || this.crls && this.crls.length && this.crls.some((o) => o instanceof OtherRevocationInfoFormat)) {
      this.version = 5;
    } else if (this.certificates && this.certificates.length && this.certificates.some((o) => o instanceof AttributeCertificateV2)) {
      this.version = 4;
    } else if (this.certificates && this.certificates.length && this.certificates.some((o) => o instanceof AttributeCertificateV1) || this.signerInfos.some((o) => o.version === 3) || this.encapContentInfo.eContentType !== _SignedData.ID_DATA) {
      this.version = 3;
    } else {
      this.version = 1;
    }
    outputArray.push(new asn1js.Integer({ value: this.version }));
    outputArray.push(new asn1js.Set({
      value: Array.from(this.digestAlgorithms, (algorithm) => algorithm.toSchema())
    }));
    outputArray.push(this.encapContentInfo.toSchema());
    if (this.certificates) {
      const certificateSet = new CertificateSet({ certificates: this.certificates });
      const certificateSetSchema = certificateSet.toSchema();
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: certificateSetSchema.valueBlock.value
      }));
    }
    if (this.crls) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 1
        },
        value: Array.from(this.crls, (crl) => {
          if (crl instanceof OtherRevocationInfoFormat) {
            const crlSchema = crl.toSchema();
            crlSchema.idBlock.tagClass = 3;
            crlSchema.idBlock.tagNumber = 1;
            return crlSchema;
          }
          return crl.toSchema(encodeFlag);
        })
      }));
    }
    outputArray.push(new asn1js.Set({
      value: Array.from(this.signerInfos, (signerInfo) => signerInfo.toSchema())
    }));
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      digestAlgorithms: Array.from(this.digestAlgorithms, (algorithm) => algorithm.toJSON()),
      encapContentInfo: this.encapContentInfo.toJSON(),
      signerInfos: Array.from(this.signerInfos, (signerInfo) => signerInfo.toJSON())
    };
    if (this.certificates) {
      res.certificates = Array.from(this.certificates, (certificate) => certificate.toJSON());
    }
    if (this.crls) {
      res.crls = Array.from(this.crls, (crl) => crl.toJSON());
    }
    return res;
  }
  async verify({ signer = -1, data = EMPTY_BUFFER, trustedCerts = [], checkDate = /* @__PURE__ */ new Date(), checkChain = false, passedWhenNotRevValues = false, extendedMode = false, findOrigin = null, findIssuer = null } = {}, crypto9 = getCrypto2(true)) {
    let signerCert = null;
    let timestampSerial = null;
    try {
      let messageDigestValue = EMPTY_BUFFER;
      let shaAlgorithm = EMPTY_STRING;
      let certificatePath = [];
      const signerInfo = this.signerInfos[signer];
      if (!signerInfo) {
        throw new SignedDataVerifyError({
          date: checkDate,
          code: 1,
          message: "Unable to get signer by supplied index"
        });
      }
      if (!this.certificates) {
        throw new SignedDataVerifyError({
          date: checkDate,
          code: 2,
          message: "No certificates attached to this signed data"
        });
      }
      if (signerInfo.sid instanceof IssuerAndSerialNumber) {
        for (const certificate of this.certificates) {
          if (!(certificate instanceof Certificate))
            continue;
          if (certificate.issuer.isEqual(signerInfo.sid.issuer) && certificate.serialNumber.isEqual(signerInfo.sid.serialNumber)) {
            signerCert = certificate;
            break;
          }
        }
      } else {
        const sid = signerInfo.sid;
        const keyId = sid.idBlock.isConstructed ? sid.valueBlock.value[0].valueBlock.valueHex : sid.valueBlock.valueHex;
        for (const certificate of this.certificates) {
          if (!(certificate instanceof Certificate)) {
            continue;
          }
          const digest3 = await crypto9.digest({ name: "sha-1" }, certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
          if (isEqualBuffer(digest3, keyId)) {
            signerCert = certificate;
            break;
          }
        }
      }
      if (!signerCert) {
        throw new SignedDataVerifyError({
          date: checkDate,
          code: 3,
          message: "Unable to find signer certificate"
        });
      }
      if (this.encapContentInfo.eContentType === id_eContentType_TSTInfo) {
        if (!this.encapContentInfo.eContent) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 15,
            message: "Error during verification: TSTInfo eContent is empty",
            signatureVerified: null,
            signerCertificate: signerCert,
            timestampSerial,
            signerCertificateVerified: true
          });
        }
        let tstInfo;
        try {
          tstInfo = TSTInfo.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView);
        } catch (ex) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 15,
            message: "Error during verification: TSTInfo wrong ASN.1 schema ",
            signatureVerified: null,
            signerCertificate: signerCert,
            timestampSerial,
            signerCertificateVerified: true
          });
        }
        checkDate = tstInfo.genTime;
        timestampSerial = tstInfo.serialNumber.valueBlock.valueHexView.slice();
        if (data.byteLength === 0) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 4,
            message: "Missed detached data input array"
          });
        }
        if (!await tstInfo.verify({ data }, crypto9)) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 15,
            message: "Error during verification: TSTInfo verification is failed",
            signatureVerified: false,
            signerCertificate: signerCert,
            timestampSerial,
            signerCertificateVerified: true
          });
        }
      }
      if (checkChain) {
        const certs = this.certificates.filter((certificate) => certificate instanceof Certificate && !!checkCA(certificate, signerCert));
        const chainParams = {
          checkDate,
          certs,
          trustedCerts
        };
        if (findIssuer) {
          chainParams.findIssuer = findIssuer;
        }
        if (findOrigin) {
          chainParams.findOrigin = findOrigin;
        }
        const chainEngine = new CertificateChainValidationEngine(chainParams);
        chainEngine.certs.push(signerCert);
        if (this.crls) {
          for (const crl of this.crls) {
            if ("thisUpdate" in crl)
              chainEngine.crls.push(crl);
            else {
              if (crl.otherRevInfoFormat === id_PKIX_OCSP_Basic)
                chainEngine.ocsps.push(new BasicOCSPResponse({ schema: crl.otherRevInfo }));
            }
          }
        }
        if (this.ocsps) {
          chainEngine.ocsps.push(...this.ocsps);
        }
        const verificationResult = await chainEngine.verify({ passedWhenNotRevValues }, crypto9).catch((e) => {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 5,
            message: `Validation of signer's certificate failed with error: ${e instanceof Object ? e.resultMessage : e}`,
            signerCertificate: signerCert,
            signerCertificateVerified: false
          });
        });
        if (verificationResult.certificatePath) {
          certificatePath = verificationResult.certificatePath;
        }
        if (!verificationResult.result)
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 5,
            message: `Validation of signer's certificate failed: ${verificationResult.resultMessage}`,
            signerCertificate: signerCert,
            signerCertificateVerified: false
          });
      }
      const signerInfoHashAlgorithm = crypto9.getAlgorithmByOID(signerInfo.digestAlgorithm.algorithmId);
      if (!("name" in signerInfoHashAlgorithm)) {
        throw new SignedDataVerifyError({
          date: checkDate,
          code: 7,
          message: `Unsupported signature algorithm: ${signerInfo.digestAlgorithm.algorithmId}`,
          signerCertificate: signerCert,
          signerCertificateVerified: true
        });
      }
      shaAlgorithm = signerInfoHashAlgorithm.name;
      const eContent = this.encapContentInfo.eContent;
      if (eContent) {
        if (eContent.idBlock.tagClass === 1 && eContent.idBlock.tagNumber === 4) {
          data = eContent.getValue();
        } else
          data = eContent.valueBlock.valueBeforeDecodeView;
      } else {
        if (data.byteLength === 0) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 8,
            message: "Missed detached data input array",
            signerCertificate: signerCert,
            signerCertificateVerified: true
          });
        }
      }
      if (signerInfo.signedAttrs) {
        let foundContentType = false;
        let foundMessageDigest = false;
        for (const attribute of signerInfo.signedAttrs.attributes) {
          if (attribute.type === "1.2.840.113549.1.9.3")
            foundContentType = true;
          if (attribute.type === "1.2.840.113549.1.9.4") {
            foundMessageDigest = true;
            messageDigestValue = attribute.values[0].valueBlock.valueHex;
          }
          if (foundContentType && foundMessageDigest)
            break;
        }
        if (foundContentType === false) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 9,
            message: 'Attribute "content-type" is a mandatory attribute for "signed attributes"',
            signerCertificate: signerCert,
            signerCertificateVerified: true
          });
        }
        if (foundMessageDigest === false) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 10,
            message: 'Attribute "message-digest" is a mandatory attribute for "signed attributes"',
            signatureVerified: null,
            signerCertificate: signerCert,
            signerCertificateVerified: true
          });
        }
      }
      if (signerInfo.signedAttrs) {
        const messageDigest = await crypto9.digest(shaAlgorithm, new Uint8Array(data));
        if (!isEqualBuffer(messageDigest, messageDigestValue)) {
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 15,
            message: "Error during verification: Message digest doesn't match",
            signatureVerified: null,
            signerCertificate: signerCert,
            timestampSerial,
            signerCertificateVerified: true
          });
        }
        data = signerInfo.signedAttrs.encodedValue;
      }
      const verifyResult = signerInfo.signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.1" ? await crypto9.verifyWithPublicKey(data, signerInfo.signature, signerCert.subjectPublicKeyInfo, signerInfo.signatureAlgorithm, shaAlgorithm) : await crypto9.verifyWithPublicKey(data, signerInfo.signature, signerCert.subjectPublicKeyInfo, signerInfo.signatureAlgorithm);
      if (extendedMode) {
        return {
          date: checkDate,
          code: 14,
          message: EMPTY_STRING,
          signatureVerified: verifyResult,
          signerCertificate: signerCert,
          timestampSerial,
          signerCertificateVerified: true,
          certificatePath
        };
      } else {
        return verifyResult;
      }
    } catch (e) {
      if (e instanceof SignedDataVerifyError) {
        throw e;
      }
      throw new SignedDataVerifyError({
        date: checkDate,
        code: 15,
        message: `Error during verification: ${e instanceof Error ? e.message : e}`,
        signatureVerified: null,
        signerCertificate: signerCert,
        timestampSerial,
        signerCertificateVerified: true
      });
    }
  }
  async sign(privateKey, signerIndex, hashAlgorithm = "SHA-1", data = EMPTY_BUFFER, crypto9 = getCrypto2(true)) {
    var _a3;
    if (!privateKey)
      throw new Error("Need to provide a private key for signing");
    const signerInfo = this.signerInfos[signerIndex];
    if (!signerInfo) {
      throw new RangeError("SignerInfo index is out of range");
    }
    if (!((_a3 = signerInfo.signedAttrs) === null || _a3 === void 0 ? void 0 : _a3.attributes.length) && "hash" in privateKey.algorithm && "hash" in privateKey.algorithm && privateKey.algorithm.hash) {
      hashAlgorithm = privateKey.algorithm.hash.name;
    }
    const hashAlgorithmOID = crypto9.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
    if (this.digestAlgorithms.filter((algorithm) => algorithm.algorithmId === hashAlgorithmOID).length === 0) {
      this.digestAlgorithms.push(new AlgorithmIdentifier({
        algorithmId: hashAlgorithmOID,
        algorithmParams: new asn1js.Null()
      }));
    }
    signerInfo.digestAlgorithm = new AlgorithmIdentifier({
      algorithmId: hashAlgorithmOID,
      algorithmParams: new asn1js.Null()
    });
    const signatureParams = await crypto9.getSignatureParameters(privateKey, hashAlgorithm);
    const parameters = signatureParams.parameters;
    signerInfo.signatureAlgorithm = signatureParams.signatureAlgorithm;
    if (signerInfo.signedAttrs) {
      if (signerInfo.signedAttrs.encodedValue.byteLength !== 0)
        data = signerInfo.signedAttrs.encodedValue;
      else {
        data = signerInfo.signedAttrs.toSchema().toBER();
        const view = BufferSourceConverter.toUint8Array(data);
        view[0] = 49;
      }
    } else {
      const eContent = this.encapContentInfo.eContent;
      if (eContent) {
        if (eContent.idBlock.tagClass === 1 && eContent.idBlock.tagNumber === 4) {
          data = eContent.getValue();
        } else
          data = eContent.valueBlock.valueBeforeDecodeView;
      } else {
        if (data.byteLength === 0)
          throw new Error("Missed detached data input array");
      }
    }
    const signature = await crypto9.signWithPrivateKey(data, privateKey, parameters);
    signerInfo.signature = new asn1js.OctetString({ valueHex: signature });
  }
};
SignedData.CLASS_NAME = "SignedData";
SignedData.ID_DATA = id_ContentType_Data;
var VERSION$1 = "version";
var AUTH_SAFE = "authSafe";
var MAC_DATA = "macData";
var PARSED_VALUE = "parsedValue";
var CLERA_PROPS = [
  VERSION$1,
  AUTH_SAFE,
  MAC_DATA
];
var PFX = class _PFX extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION$1, _PFX.defaultValues(VERSION$1));
    this.authSafe = getParametersValue(parameters, AUTH_SAFE, _PFX.defaultValues(AUTH_SAFE));
    if (MAC_DATA in parameters) {
      this.macData = getParametersValue(parameters, MAC_DATA, _PFX.defaultValues(MAC_DATA));
    }
    if (PARSED_VALUE in parameters) {
      this.parsedValue = getParametersValue(parameters, PARSED_VALUE, _PFX.defaultValues(PARSED_VALUE));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION$1:
        return 3;
      case AUTH_SAFE:
        return new ContentInfo();
      case MAC_DATA:
        return new MacData();
      case PARSED_VALUE:
        return {};
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION$1:
        return memberValue === _PFX.defaultValues(memberName);
      case AUTH_SAFE:
        return ContentInfo.compareWithDefault("contentType", memberValue.contentType) && ContentInfo.compareWithDefault("content", memberValue.content);
      case MAC_DATA:
        return MacData.compareWithDefault("mac", memberValue.mac) && MacData.compareWithDefault("macSalt", memberValue.macSalt) && MacData.compareWithDefault("iterations", memberValue.iterations);
      case PARSED_VALUE:
        return memberValue instanceof Object && Object.keys(memberValue).length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.version || VERSION$1 }),
        ContentInfo.schema(names.authSafe || {
          names: {
            blockName: AUTH_SAFE
          }
        }),
        MacData.schema(names.macData || {
          names: {
            blockName: MAC_DATA,
            optional: true
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLERA_PROPS);
    const asn1 = asn1js.compareSchema(schema, schema, _PFX.schema({
      names: {
        version: VERSION$1,
        authSafe: {
          names: {
            blockName: AUTH_SAFE
          }
        },
        macData: {
          names: {
            blockName: MAC_DATA
          }
        }
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result.version.valueBlock.valueDec;
    this.authSafe = new ContentInfo({ schema: asn1.result.authSafe });
    if (MAC_DATA in asn1.result)
      this.macData = new MacData({ schema: asn1.result.macData });
  }
  toSchema() {
    const outputArray = [
      new asn1js.Integer({ value: this.version }),
      this.authSafe.toSchema()
    ];
    if (this.macData) {
      outputArray.push(this.macData.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const output6 = {
      version: this.version,
      authSafe: this.authSafe.toJSON()
    };
    if (this.macData) {
      output6.macData = this.macData.toJSON();
    }
    return output6;
  }
  async makeInternalValues(parameters = {}, crypto9 = getCrypto2(true)) {
    ArgumentError.assert(parameters, "parameters", "object");
    if (!this.parsedValue) {
      throw new Error('Please call "parseValues" function first in order to make "parsedValue" data');
    }
    ParameterError.assertEmpty(this.parsedValue.integrityMode, "integrityMode", "parsedValue");
    ParameterError.assertEmpty(this.parsedValue.authenticatedSafe, "authenticatedSafe", "parsedValue");
    switch (this.parsedValue.integrityMode) {
      case 0:
        {
          if (!("iterations" in parameters))
            throw new ParameterError("iterations");
          ParameterError.assertEmpty(parameters.pbkdf2HashAlgorithm, "pbkdf2HashAlgorithm");
          ParameterError.assertEmpty(parameters.hmacHashAlgorithm, "hmacHashAlgorithm");
          ParameterError.assertEmpty(parameters.password, "password");
          const saltBuffer = new ArrayBuffer(64);
          const saltView = new Uint8Array(saltBuffer);
          crypto9.getRandomValues(saltView);
          const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
          this.authSafe = new ContentInfo({
            contentType: ContentInfo.DATA,
            content: new asn1js.OctetString({ valueHex: data })
          });
          const result = await crypto9.stampDataWithPassword({
            password: parameters.password,
            hashAlgorithm: parameters.hmacHashAlgorithm,
            salt: saltBuffer,
            iterationCount: parameters.iterations,
            contentToStamp: data
          });
          this.macData = new MacData({
            mac: new DigestInfo({
              digestAlgorithm: new AlgorithmIdentifier({
                algorithmId: crypto9.getOIDByAlgorithm({ name: parameters.hmacHashAlgorithm }, true, "hmacHashAlgorithm")
              }),
              digest: new asn1js.OctetString({ valueHex: result })
            }),
            macSalt: new asn1js.OctetString({ valueHex: saltBuffer }),
            iterations: parameters.iterations
          });
        }
        break;
      case 1:
        {
          if (!("signingCertificate" in parameters)) {
            throw new ParameterError("signingCertificate");
          }
          ParameterError.assertEmpty(parameters.privateKey, "privateKey");
          ParameterError.assertEmpty(parameters.hashAlgorithm, "hashAlgorithm");
          const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
          const cmsSigned = new SignedData({
            version: 1,
            encapContentInfo: new EncapsulatedContentInfo({
              eContentType: "1.2.840.113549.1.7.1",
              eContent: new asn1js.OctetString({ valueHex: toBeSigned })
            }),
            certificates: [parameters.signingCertificate]
          });
          const result = await crypto9.digest({ name: parameters.hashAlgorithm }, new Uint8Array(toBeSigned));
          const signedAttr = [];
          signedAttr.push(new Attribute({
            type: "1.2.840.113549.1.9.3",
            values: [
              new asn1js.ObjectIdentifier({ value: "1.2.840.113549.1.7.1" })
            ]
          }));
          signedAttr.push(new Attribute({
            type: "1.2.840.113549.1.9.5",
            values: [
              new asn1js.UTCTime({ valueDate: /* @__PURE__ */ new Date() })
            ]
          }));
          signedAttr.push(new Attribute({
            type: "1.2.840.113549.1.9.4",
            values: [
              new asn1js.OctetString({ valueHex: result })
            ]
          }));
          cmsSigned.signerInfos.push(new SignerInfo({
            version: 1,
            sid: new IssuerAndSerialNumber({
              issuer: parameters.signingCertificate.issuer,
              serialNumber: parameters.signingCertificate.serialNumber
            }),
            signedAttrs: new SignedAndUnsignedAttributes({
              type: 0,
              attributes: signedAttr
            })
          }));
          await cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm, void 0, crypto9);
          this.authSafe = new ContentInfo({
            contentType: "1.2.840.113549.1.7.2",
            content: cmsSigned.toSchema(true)
          });
        }
        break;
      default:
        throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`);
    }
  }
  async parseInternalValues(parameters, crypto9 = getCrypto2(true)) {
    ArgumentError.assert(parameters, "parameters", "object");
    if (parameters.checkIntegrity === void 0) {
      parameters.checkIntegrity = true;
    }
    this.parsedValue = {};
    switch (this.authSafe.contentType) {
      case ContentInfo.DATA:
        {
          ParameterError.assertEmpty(parameters.password, "password");
          this.parsedValue.integrityMode = 0;
          ArgumentError.assert(this.authSafe.content, "authSafe.content", asn1js.OctetString);
          const authSafeContent = this.authSafe.content.getValue();
          this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(authSafeContent);
          if (parameters.checkIntegrity) {
            if (!this.macData) {
              throw new Error('Absent "macData" value, can not check PKCS#12 data integrity');
            }
            const hashAlgorithm = crypto9.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId, true, "digestAlgorithm");
            const result = await crypto9.verifyDataStampedWithPassword({
              password: parameters.password,
              hashAlgorithm: hashAlgorithm.name,
              salt: BufferSourceConverter.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),
              iterationCount: this.macData.iterations || 1,
              contentToVerify: authSafeContent,
              signatureToVerify: BufferSourceConverter.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)
            });
            if (!result) {
              throw new Error("Integrity for the PKCS#12 data is broken!");
            }
          }
        }
        break;
      case ContentInfo.SIGNED_DATA:
        {
          this.parsedValue.integrityMode = 1;
          const cmsSigned = new SignedData({ schema: this.authSafe.content });
          const eContent = cmsSigned.encapContentInfo.eContent;
          ParameterError.assert(eContent, "eContent", "cmsSigned.encapContentInfo");
          ArgumentError.assert(eContent, "eContent", asn1js.OctetString);
          const data = eContent.getValue();
          this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(data);
          const ok = await cmsSigned.verify({ signer: 0, checkChain: false }, crypto9);
          if (!ok) {
            throw new Error("Integrity for the PKCS#12 data is broken!");
          }
        }
        break;
      default:
        throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`);
    }
  }
};
PFX.CLASS_NAME = "PFX";
var STATUS$1 = "status";
var STATUS_STRINGS = "statusStrings";
var FAIL_INFO = "failInfo";
var CLEAR_PROPS$2 = [
  STATUS$1,
  STATUS_STRINGS,
  FAIL_INFO
];
var PKIStatus;
(function(PKIStatus2) {
  PKIStatus2[PKIStatus2["granted"] = 0] = "granted";
  PKIStatus2[PKIStatus2["grantedWithMods"] = 1] = "grantedWithMods";
  PKIStatus2[PKIStatus2["rejection"] = 2] = "rejection";
  PKIStatus2[PKIStatus2["waiting"] = 3] = "waiting";
  PKIStatus2[PKIStatus2["revocationWarning"] = 4] = "revocationWarning";
  PKIStatus2[PKIStatus2["revocationNotification"] = 5] = "revocationNotification";
})(PKIStatus || (PKIStatus = {}));
var PKIStatusInfo = class _PKIStatusInfo extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.status = getParametersValue(parameters, STATUS$1, _PKIStatusInfo.defaultValues(STATUS$1));
    if (STATUS_STRINGS in parameters) {
      this.statusStrings = getParametersValue(parameters, STATUS_STRINGS, _PKIStatusInfo.defaultValues(STATUS_STRINGS));
    }
    if (FAIL_INFO in parameters) {
      this.failInfo = getParametersValue(parameters, FAIL_INFO, _PKIStatusInfo.defaultValues(FAIL_INFO));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case STATUS$1:
        return 2;
      case STATUS_STRINGS:
        return [];
      case FAIL_INFO:
        return new asn1js.BitString();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case STATUS$1:
        return memberValue === _PKIStatusInfo.defaultValues(memberName);
      case STATUS_STRINGS:
        return memberValue.length === 0;
      case FAIL_INFO:
        return memberValue.isEqual(_PKIStatusInfo.defaultValues(memberName));
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || EMPTY_STRING,
      value: [
        new asn1js.Integer({ name: names.status || EMPTY_STRING }),
        new asn1js.Sequence({
          optional: true,
          value: [
            new asn1js.Repeated({
              name: names.statusStrings || EMPTY_STRING,
              value: new asn1js.Utf8String()
            })
          ]
        }),
        new asn1js.BitString({
          name: names.failInfo || EMPTY_STRING,
          optional: true
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$2);
    const asn1 = asn1js.compareSchema(schema, schema, _PKIStatusInfo.schema({
      names: {
        status: STATUS$1,
        statusStrings: STATUS_STRINGS,
        failInfo: FAIL_INFO
      }
    }));
    AsnError.assertSchema(asn1, this.className);
    const _status = asn1.result.status;
    if (_status.valueBlock.isHexOnly === true || _status.valueBlock.valueDec < 0 || _status.valueBlock.valueDec > 5)
      throw new Error('PKIStatusInfo "status" has invalid value');
    this.status = _status.valueBlock.valueDec;
    if (STATUS_STRINGS in asn1.result)
      this.statusStrings = asn1.result.statusStrings;
    if (FAIL_INFO in asn1.result)
      this.failInfo = asn1.result.failInfo;
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.status }));
    if (this.statusStrings) {
      outputArray.push(new asn1js.Sequence({
        optional: true,
        value: this.statusStrings
      }));
    }
    if (this.failInfo) {
      outputArray.push(this.failInfo);
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      status: this.status
    };
    if (this.statusStrings) {
      res.statusStrings = Array.from(this.statusStrings, (o) => o.toJSON());
    }
    if (this.failInfo) {
      res.failInfo = this.failInfo.toJSON();
    }
    return res;
  }
};
PKIStatusInfo.CLASS_NAME = "PKIStatusInfo";
var VERSION = "version";
var MESSAGE_IMPRINT = "messageImprint";
var REQ_POLICY = "reqPolicy";
var NONCE = "nonce";
var CERT_REQ = "certReq";
var EXTENSIONS = "extensions";
var TIME_STAMP_REQ = "TimeStampReq";
var TIME_STAMP_REQ_VERSION = `${TIME_STAMP_REQ}.${VERSION}`;
var TIME_STAMP_REQ_MESSAGE_IMPRINT = `${TIME_STAMP_REQ}.${MESSAGE_IMPRINT}`;
var TIME_STAMP_REQ_POLICY = `${TIME_STAMP_REQ}.${REQ_POLICY}`;
var TIME_STAMP_REQ_NONCE = `${TIME_STAMP_REQ}.${NONCE}`;
var TIME_STAMP_REQ_CERT_REQ = `${TIME_STAMP_REQ}.${CERT_REQ}`;
var TIME_STAMP_REQ_EXTENSIONS = `${TIME_STAMP_REQ}.${EXTENSIONS}`;
var CLEAR_PROPS$1 = [
  TIME_STAMP_REQ_VERSION,
  TIME_STAMP_REQ_MESSAGE_IMPRINT,
  TIME_STAMP_REQ_POLICY,
  TIME_STAMP_REQ_NONCE,
  TIME_STAMP_REQ_CERT_REQ,
  TIME_STAMP_REQ_EXTENSIONS
];
var TimeStampReq = class _TimeStampReq extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.version = getParametersValue(parameters, VERSION, _TimeStampReq.defaultValues(VERSION));
    this.messageImprint = getParametersValue(parameters, MESSAGE_IMPRINT, _TimeStampReq.defaultValues(MESSAGE_IMPRINT));
    if (REQ_POLICY in parameters) {
      this.reqPolicy = getParametersValue(parameters, REQ_POLICY, _TimeStampReq.defaultValues(REQ_POLICY));
    }
    if (NONCE in parameters) {
      this.nonce = getParametersValue(parameters, NONCE, _TimeStampReq.defaultValues(NONCE));
    }
    if (CERT_REQ in parameters) {
      this.certReq = getParametersValue(parameters, CERT_REQ, _TimeStampReq.defaultValues(CERT_REQ));
    }
    if (EXTENSIONS in parameters) {
      this.extensions = getParametersValue(parameters, EXTENSIONS, _TimeStampReq.defaultValues(EXTENSIONS));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case VERSION:
        return 0;
      case MESSAGE_IMPRINT:
        return new MessageImprint();
      case REQ_POLICY:
        return EMPTY_STRING;
      case NONCE:
        return new asn1js.Integer();
      case CERT_REQ:
        return false;
      case EXTENSIONS:
        return [];
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case VERSION:
      case REQ_POLICY:
      case CERT_REQ:
        return memberValue === _TimeStampReq.defaultValues(memberName);
      case MESSAGE_IMPRINT:
        return MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage);
      case NONCE:
        return memberValue.isEqual(_TimeStampReq.defaultValues(memberName));
      case EXTENSIONS:
        return memberValue.length === 0;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || TIME_STAMP_REQ,
      value: [
        new asn1js.Integer({ name: names.version || TIME_STAMP_REQ_VERSION }),
        MessageImprint.schema(names.messageImprint || {
          names: {
            blockName: TIME_STAMP_REQ_MESSAGE_IMPRINT
          }
        }),
        new asn1js.ObjectIdentifier({
          name: names.reqPolicy || TIME_STAMP_REQ_POLICY,
          optional: true
        }),
        new asn1js.Integer({
          name: names.nonce || TIME_STAMP_REQ_NONCE,
          optional: true
        }),
        new asn1js.Boolean({
          name: names.certReq || TIME_STAMP_REQ_CERT_REQ,
          optional: true
        }),
        new asn1js.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [new asn1js.Repeated({
            name: names.extensions || TIME_STAMP_REQ_EXTENSIONS,
            value: Extension.schema()
          })]
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS$1);
    const asn1 = asn1js.compareSchema(schema, schema, _TimeStampReq.schema());
    AsnError.assertSchema(asn1, this.className);
    this.version = asn1.result[TIME_STAMP_REQ_VERSION].valueBlock.valueDec;
    this.messageImprint = new MessageImprint({ schema: asn1.result[TIME_STAMP_REQ_MESSAGE_IMPRINT] });
    if (TIME_STAMP_REQ_POLICY in asn1.result)
      this.reqPolicy = asn1.result[TIME_STAMP_REQ_POLICY].valueBlock.toString();
    if (TIME_STAMP_REQ_NONCE in asn1.result)
      this.nonce = asn1.result[TIME_STAMP_REQ_NONCE];
    if (TIME_STAMP_REQ_CERT_REQ in asn1.result)
      this.certReq = asn1.result[TIME_STAMP_REQ_CERT_REQ].valueBlock.value;
    if (TIME_STAMP_REQ_EXTENSIONS in asn1.result)
      this.extensions = Array.from(asn1.result[TIME_STAMP_REQ_EXTENSIONS], (element) => new Extension({ schema: element }));
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(new asn1js.Integer({ value: this.version }));
    outputArray.push(this.messageImprint.toSchema());
    if (this.reqPolicy)
      outputArray.push(new asn1js.ObjectIdentifier({ value: this.reqPolicy }));
    if (this.nonce)
      outputArray.push(this.nonce);
    if (CERT_REQ in this && _TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false)
      outputArray.push(new asn1js.Boolean({ value: this.certReq }));
    if (this.extensions) {
      outputArray.push(new asn1js.Constructed({
        idBlock: {
          tagClass: 3,
          tagNumber: 0
        },
        value: Array.from(this.extensions, (o) => o.toSchema())
      }));
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      version: this.version,
      messageImprint: this.messageImprint.toJSON()
    };
    if (this.reqPolicy !== void 0)
      res.reqPolicy = this.reqPolicy;
    if (this.nonce !== void 0)
      res.nonce = this.nonce.toJSON();
    if (this.certReq !== void 0 && _TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false)
      res.certReq = this.certReq;
    if (this.extensions) {
      res.extensions = Array.from(this.extensions, (o) => o.toJSON());
    }
    return res;
  }
};
TimeStampReq.CLASS_NAME = "TimeStampReq";
var STATUS = "status";
var TIME_STAMP_TOKEN = "timeStampToken";
var TIME_STAMP_RESP = "TimeStampResp";
var TIME_STAMP_RESP_STATUS = `${TIME_STAMP_RESP}.${STATUS}`;
var TIME_STAMP_RESP_TOKEN = `${TIME_STAMP_RESP}.${TIME_STAMP_TOKEN}`;
var CLEAR_PROPS = [
  TIME_STAMP_RESP_STATUS,
  TIME_STAMP_RESP_TOKEN
];
var TimeStampResp = class _TimeStampResp extends PkiObject {
  constructor(parameters = {}) {
    super();
    this.status = getParametersValue(parameters, STATUS, _TimeStampResp.defaultValues(STATUS));
    if (TIME_STAMP_TOKEN in parameters) {
      this.timeStampToken = getParametersValue(parameters, TIME_STAMP_TOKEN, _TimeStampResp.defaultValues(TIME_STAMP_TOKEN));
    }
    if (parameters.schema) {
      this.fromSchema(parameters.schema);
    }
  }
  static defaultValues(memberName) {
    switch (memberName) {
      case STATUS:
        return new PKIStatusInfo();
      case TIME_STAMP_TOKEN:
        return new ContentInfo();
      default:
        return super.defaultValues(memberName);
    }
  }
  static compareWithDefault(memberName, memberValue) {
    switch (memberName) {
      case STATUS:
        return PKIStatusInfo.compareWithDefault(STATUS, memberValue.status) && "statusStrings" in memberValue === false && "failInfo" in memberValue === false;
      case TIME_STAMP_TOKEN:
        return memberValue.contentType === EMPTY_STRING && memberValue.content instanceof asn1js.Any;
      default:
        return super.defaultValues(memberName);
    }
  }
  static schema(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new asn1js.Sequence({
      name: names.blockName || TIME_STAMP_RESP,
      value: [
        PKIStatusInfo.schema(names.status || {
          names: {
            blockName: TIME_STAMP_RESP_STATUS
          }
        }),
        ContentInfo.schema(names.timeStampToken || {
          names: {
            blockName: TIME_STAMP_RESP_TOKEN,
            optional: true
          }
        })
      ]
    });
  }
  fromSchema(schema) {
    clearProps(schema, CLEAR_PROPS);
    const asn1 = asn1js.compareSchema(schema, schema, _TimeStampResp.schema());
    AsnError.assertSchema(asn1, this.className);
    this.status = new PKIStatusInfo({ schema: asn1.result[TIME_STAMP_RESP_STATUS] });
    if (TIME_STAMP_RESP_TOKEN in asn1.result)
      this.timeStampToken = new ContentInfo({ schema: asn1.result[TIME_STAMP_RESP_TOKEN] });
  }
  toSchema() {
    const outputArray = [];
    outputArray.push(this.status.toSchema());
    if (this.timeStampToken) {
      outputArray.push(this.timeStampToken.toSchema());
    }
    return new asn1js.Sequence({
      value: outputArray
    });
  }
  toJSON() {
    const res = {
      status: this.status.toJSON()
    };
    if (this.timeStampToken) {
      res.timeStampToken = this.timeStampToken.toJSON();
    }
    return res;
  }
  async sign(privateKey, hashAlgorithm, crypto9 = getCrypto2(true)) {
    this.assertContentType();
    const signed = new SignedData({ schema: this.timeStampToken.content });
    return signed.sign(privateKey, 0, hashAlgorithm, void 0, crypto9);
  }
  async verify(verificationParameters = { signer: 0, trustedCerts: [], data: EMPTY_BUFFER }, crypto9 = getCrypto2(true)) {
    this.assertContentType();
    const signed = new SignedData({ schema: this.timeStampToken.content });
    return signed.verify(verificationParameters, crypto9);
  }
  assertContentType() {
    if (!this.timeStampToken) {
      throw new Error("timeStampToken is absent in TSP response");
    }
    if (this.timeStampToken.contentType !== id_ContentType_SignedData) {
      throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
    }
  }
};
TimeStampResp.CLASS_NAME = "TimeStampResp";
function initCryptoEngine() {
  if (typeof self !== "undefined") {
    if ("crypto" in self) {
      let engineName = "webcrypto";
      if ("webkitSubtle" in self.crypto) {
        engineName = "safari";
      }
      setEngine(engineName, new CryptoEngine({ name: engineName, crypto }));
    }
  } else if (typeof crypto !== "undefined" && "webcrypto" in crypto) {
    const name4 = "NodeJS ^15";
    const nodeCrypto = crypto.webcrypto;
    setEngine(name4, new CryptoEngine({ name: name4, crypto: nodeCrypto }));
  }
}
initCryptoEngine();

// src/witness/witness_tsa.ts
var WitnessTSA = class {
  constructor() {
    /**
    * Converts ISO date to Unix timestamp
    * 
    * @param t - Date object or ISO date string
    * @returns Unix timestamp (seconds since epoch)
    * 
    * This method normalizes dates to Unix timestamps for
    * consistent timestamp handling across the system.
    */
    this.isoDate2unix = (t) => {
      const date = t instanceof Date ? t : new Date(t);
      return Math.floor(date.getTime() / 1e3);
    };
    /**
    * Extracts generation time from TSA response
    * 
    * @param resp - TSA response object
    * @returns Unix timestamp of when TSA generated the timestamp
    * 
    * This method:
    * - Extracts signed data from TSA response
    * - Parses TSTInfo structure
    * - Converts TSA generation time to Unix timestamp
    */
    this.extractGenTimeFromResp = (resp) => {
      const signedData = new SignedData({
        schema: resp?.timeStampToken?.content
      });
      const tstInfoAsn1 = asn1js2.fromBER(
        signedData.encapContentInfo.eContent.valueBlock.valueHexView
      );
      const tstInfo = new TSTInfo({ schema: tstInfoAsn1.result });
      return this.isoDate2unix(tstInfo.genTime);
    };
    /**
    * Creates a timestamp request and submits to TSA
    * 
    * @param hash - Hash to be timestamped
    * @param tsaUrl - URL of the Time Stamp Authority service
    * @returns Promise resolving to [base64 response, provider name, timestamp]
    * 
    * This method:
    * - Creates SHA-256 hash of input
    * - Constructs TSP request according to RFC 3161
    * - Submits request to TSA service
    * - Validates TSA response
    * - Returns encoded response and timestamp
    */
    this.witness = async (hash3, tsaUrl) => {
      const hashHex = getHashSum(hash3);
      const hashBuffer = Uint8Array.from(Buffer.from(hashHex, "hex"));
      const tspReq = new TimeStampReq({
        version: 1,
        messageImprint: new MessageImprint({
          hashAlgorithm: new AlgorithmIdentifier({
            algorithmId: "2.16.840.1.101.3.4.2.1"
            // OID for SHA2-256
          }),
          hashedMessage: new asn1js2.OctetString({ valueHex: hashBuffer.buffer })
        }),
        nonce: new asn1js2.Integer({ value: Date.now() }),
        certReq: true
      });
      const tspReqSchema = tspReq.toSchema();
      const tspReqBuffer = tspReqSchema.toBER(false);
      const response = await fetch(tsaUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/timestamp-query"
        },
        body: tspReqBuffer
      });
      const tspResponseBuffer = await response.arrayBuffer();
      const tspResponseAsn1 = asn1js2.fromBER(tspResponseBuffer);
      const tspResponse = new TimeStampResp({
        schema: tspResponseAsn1.result
      });
      if (tspResponse.status.status !== 0) {
        throw new Error("TSA response is invalid. Failed to witness");
      }
      const base64EncodedResp = Buffer.from(tspResponseBuffer).toString("base64");
      const witnessTimestamp = this.extractGenTimeFromResp(tspResponse);
      return [base64EncodedResp, "DigiCert", witnessTimestamp];
    };
    /**
    * Verifies a TSA timestamp response
    * 
    * @param transactionHash - Base64 encoded TSA response
    * @param expectedMR - Expected Merkle root hash
    * @param expectedTimestamp - Expected timestamp
    * @returns Promise resolving to boolean indicating verification success
    * 
    * This method:
    * - Decodes TSA response
    * - Verifies timestamp matches expected time
    * - Verifies hashed content matches expected Merkle root
    * - Uses SHA-256 for hash verification
    */
    this.verify = async (transactionHash, expectedMR, expectedTimestamp) => {
      const tspResponseBuffer = Buffer.from(transactionHash, "base64");
      const tspResponseAsn1 = asn1js2.fromBER(tspResponseBuffer);
      const tspResponse = new TimeStampResp({
        schema: tspResponseAsn1.result
      });
      const signedData = new SignedData({
        schema: tspResponse.timeStampToken.content
      });
      const tstInfoAsn1 = asn1js2.fromBER(
        signedData.encapContentInfo.eContent.valueBlock.valueHexView
      );
      const tstInfo = new TSTInfo({ schema: tstInfoAsn1.result });
      if (this.isoDate2unix(tstInfo.genTime) !== expectedTimestamp) {
        return false;
      }
      const hashHex = getHashSum(expectedMR);
      const messageImprintHash = Buffer.from(
        tstInfo.messageImprint.hashedMessage.valueBlock.valueHexView
      ).toString("hex");
      return messageImprintHash === hashHex;
    };
  }
};

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
function number4(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes3(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number4(hash3.outputLen);
  number4(hash3.blockLen);
}
function exists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output3(out, instance) {
  bytes3(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js
var nc2 = __toESM(require("crypto"), 1);
var crypto7 = nc2 && typeof nc2 === "object" && "webcrypto" in nc2 ? nc2.webcrypto : void 0;

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
var u8a3 = (a) => a instanceof Uint8Array;
var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE4)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes5(data) {
  if (typeof data === "string")
    data = utf8ToBytes5(data);
  if (!u8a3(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad4 = 0;
  arrays.forEach((a) => {
    if (!u8a3(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad4);
    pad4 += a.length;
  });
  return r;
}
var Hash3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr2 = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes5(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes3(bytesLength = 32) {
  if (crypto7 && typeof crypto7.getRandomValues === "function") {
    return crypto7.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint643(view, byteOffset, value, isLE7) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE7);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE7 ? 4 : 0;
  const l = isLE7 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE7);
  view.setUint32(byteOffset + l, wl, isLE7);
}
var SHA2 = class extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE7) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE7;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView3(this.buffer);
  }
  update(data) {
    exists3(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes5(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView2 = createView3(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE7 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE7);
    this.process(view, 0);
    const oview = createView3(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE7);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length3, finished, destroyed, pos } = this;
    to.length = length3;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length3 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
var SHA2563 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W2[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W2[i2 - 15];
      const W2 = SHA256_W2[i2 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2566 = /* @__PURE__ */ wrapConstructor2(() => new SHA2563());

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen2,
  bitMask: () => bitMask2,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex4,
  bytesToNumberBE: () => bytesToNumberBE2,
  bytesToNumberLE: () => bytesToNumberLE2,
  concatBytes: () => concatBytes3,
  createHmacDrbg: () => createHmacDrbg2,
  ensureBytes: () => ensureBytes3,
  equalBytes: () => equalBytes3,
  hexToBytes: () => hexToBytes4,
  hexToNumber: () => hexToNumber2,
  numberToBytesBE: () => numberToBytesBE2,
  numberToBytesLE: () => numberToBytesLE2,
  numberToHexUnpadded: () => numberToHexUnpadded2,
  numberToVarBytesBE: () => numberToVarBytesBE2,
  utf8ToBytes: () => utf8ToBytes6,
  validateObject: () => validateObject2
});
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n9 = BigInt(2);
var u8a4 = (a) => a instanceof Uint8Array;
var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex4(bytes6) {
  if (!u8a4(bytes6))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i2 = 0; i2 < bytes6.length; i2++) {
    hex2 += hexes3[bytes6[i2]];
  }
  return hex2;
}
function numberToHexUnpadded2(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes4(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumberBE2(bytes6) {
  return hexToNumber2(bytesToHex4(bytes6));
}
function bytesToNumberLE2(bytes6) {
  if (!u8a4(bytes6))
    throw new Error("Uint8Array expected");
  return hexToNumber2(bytesToHex4(Uint8Array.from(bytes6).reverse()));
}
function numberToBytesBE2(n, len) {
  return hexToBytes4(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n, len) {
  return numberToBytesBE2(n, len).reverse();
}
function numberToVarBytesBE2(n) {
  return hexToBytes4(numberToHexUnpadded2(n));
}
function ensureBytes3(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes4(hex2);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e}`);
    }
  } else if (u8a4(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes3(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad4 = 0;
  arrays.forEach((a) => {
    if (!u8a4(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad4);
    pad4 += a.length;
  });
  return r;
}
function equalBytes3(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < b1.length; i2++)
    if (b1[i2] !== b2[i2])
      return false;
  return true;
}
function utf8ToBytes6(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen2(n) {
  let len;
  for (len = 0; n > _0n11; n >>= _1n11, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n11;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n11 : _0n11) << BigInt(pos);
};
var bitMask2 = (n) => (_2n9 << BigInt(n - 1)) - _1n11;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen3 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen3())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject2(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js
var _0n12 = BigInt(0);
var _1n12 = BigInt(1);
var _2n10 = BigInt(2);
var _3n4 = BigInt(3);
var _4n3 = BigInt(4);
var _5n3 = BigInt(5);
var _8n4 = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a, b) {
  const result = a % b;
  return result >= _0n12 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n12 || power < _0n12)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n12)
    return _0n12;
  let res = _1n12;
  while (power > _0n12) {
    if (power & _1n12)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n12;
  }
  return res;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n12) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number7, modulo) {
  if (number7 === _0n12 || modulo <= _0n12) {
    throw new Error(`invert: expected positive integers, got n=${number7} mod=${modulo}`);
  }
  let a = mod2(number7, modulo);
  let b = modulo;
  let x = _0n12, y = _1n12, u = _1n12, v = _0n12;
  while (a !== _0n12) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd3 = b;
  if (gcd3 !== _1n12)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function tonelliShanks2(P) {
  const legendreC = (P - _1n12) / _2n10;
  let Q, S, Z;
  for (Q = P - _1n12, S = 0; Q % _2n10 === _0n12; Q /= _2n10, S++)
    ;
  for (Z = _2n10; Z < P && pow(Z, legendreC, P) !== P - _1n12; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n12) / _4n3;
    return function tonelliFast(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n12) / _2n10;
  return function tonelliSlow(Fp3, n) {
    if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n, Q1div2);
    let b = Fp3.pow(n, Q);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO))
        return Fp3.ZERO;
      let m = 1;
      for (let t2 = Fp3.sqr(b); m < r; m++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge2 = Fp3.pow(g, _1n12 << BigInt(r - m - 1));
      g = Fp3.sqr(ge2);
      x = Fp3.mul(x, ge2);
      b = Fp3.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt2(P) {
  if (P % _4n3 === _3n4) {
    const p1div4 = (P + _1n12) / _4n3;
    return function sqrt3mod42(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n4 === _5n3) {
    const c1 = (P - _5n3) / _8n4;
    return function sqrt5mod82(Fp3, n) {
      const n2 = Fp3.mul(n, _2n10);
      const v = Fp3.pow(n2, c1);
      const nv = Fp3.mul(n, v);
      const i2 = Fp3.mul(Fp3.mul(nv, _2n10), v);
      const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks2(P);
}
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS2.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject2(field, opts);
}
function FpPow2(f, num, power) {
  if (power < _0n12)
    throw new Error("Expected power > 0");
  if (power === _0n12)
    return f.ONE;
  if (power === _1n12)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n12) {
    if (power & _1n12)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n12;
  }
  return p;
}
function FpInvertBatch2(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f.is0(num))
      return acc;
    tmp[i2] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f.is0(num))
      return acc;
    tmp[i2] = f.mul(acc, tmp[i2]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength2(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLen3, isLE7 = false, redef = {}) {
  if (ORDER <= _0n12)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt2(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n12,
    ONE: _1n12,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n12 <= num && num < ORDER;
    },
    is0: (num) => num === _0n12,
    isOdd: (num) => (num & _1n12) === _1n12,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow2(f, num, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert2(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch2(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE7 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
    fromBytes: (bytes6) => {
      if (bytes6.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes6.length}`);
      return isLE7 ? bytesToNumberLE2(bytes6) : bytesToNumberBE2(bytes6);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length3 = getFieldBytesLength2(fieldOrder);
  return length3 + Math.ceil(length3 / 2);
}
function mapHashToField2(key, fieldOrder, isLE7 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE7 ? bytesToNumberBE2(key) : bytesToNumberLE2(key);
  const reduced = mod2(num, fieldOrder - _1n12) + _1n12;
  return isLE7 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js
var _0n13 = BigInt(0);
var _1n13 = BigInt(1);
function wNAF2(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n13) {
        if (n & _1n13)
          p = p.add(d);
        d = d.double();
        n >>= _1n13;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base4 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base4 = p;
        points.push(base4);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base4 = base4.add(p);
          points.push(base4);
        }
        p = base4.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n13;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField2(curve.Fp);
  validateObject2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength2(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject2(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a } = opts;
  if (endo) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER2 = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER2;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E } = DER2;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER2._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER2._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s = slice2(h(sig.s));
    const r = slice2(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n14 = BigInt(0);
var _1n14 = BigInt(1);
var _2n11 = BigInt(2);
var _3n5 = BigInt(3);
var _4n4 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes8 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes3(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes6) => {
    const tail = bytes6.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n14 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex4(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes3("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod2(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes2 = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp3.eql(i2, Fp3.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes3("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes2.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left2 = Fp3.sqr(y);
      const right2 = weierstrassEquation(x);
      if (!Fp3.eql(left2, right2))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp3.mul(b, _3n5);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n5);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes2, n, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n14)
        return I;
      assertGE(n);
      if (n === _1n14)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n14 || k2 > _0n14) {
        if (k1 & _1n14)
          k1p = k1p.add(d);
        if (k2 & _1n14)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n14;
        k2 >>= _1n14;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul3 = (P, a2) => a2 === _0n14 || a2 === _1n14 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul3(this, a).add(mul3(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y, iz);
      const zz = Fp3.mul(z, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n14)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n14)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes8(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex4(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF2(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts2(curve) {
  const opts = validateBasic(curve);
  validateObject2(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass2(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n14 < num && num < Fp3.ORDER;
  }
  function modN2(a) {
    return mod2(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert2(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes3;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes6) {
      const len = bytes6.length;
      const head = bytes6[0];
      const tail = bytes6.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE2(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp3.sqrt(y2);
        const isYOdd = (y & _1n14) === _1n14;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp3.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex4(numberToBytesBE2(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number7) {
    const HALF = CURVE_ORDER >> _1n14;
    return number7 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from5, to) => bytesToNumberBE2(b.slice(from5, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l = CURVE.nByteLength;
      hex2 = ensureBytes3("compactSignature", hex2, l * 2);
      return new Signature2(slcNum(hex2, 0, l), slcNum(hex2, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r, s } = DER2.toSig(ensureBytes3("DER", hex2));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes3("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes4(this.toDERHex());
    }
    toDERHex() {
      return DER2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes4(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length3 = getMinHashLength2(CURVE.n);
      return mapHashToField2(CURVE.randomBytes(length3), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey2(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes6) {
    const num = bytesToNumberBE2(bytes6);
    const delta = bytes6.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes6) {
    return modN2(bits2int(bytes6));
  };
  const ORDER_MASK = bitMask2(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n14 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE2(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes5 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes3("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes3("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes5(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes3("extraEntropy", e));
    }
    const seed = concatBytes3(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n14)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n14)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n14);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg2(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes3("msgHash", msgHash);
    publicKey = ensureBytes3("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
          _sig = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN2(h * is2);
    const u2 = modN2(r * is2);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey: getPublicKey2,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point2,
    Signature: Signature2,
    utils
  };
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash3 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes5(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad4 = new Uint8Array(blockLen);
    pad4.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad4.length; i2++)
      pad4[i2] ^= 54;
    this.iHash.update(pad4);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad4.length; i2++)
      pad4[i2] ^= 54 ^ 92;
    this.oHash.update(pad4);
    pad4.fill(0);
  }
  update(buf2) {
    exists3(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    exists3(this);
    bytes3(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac2(hash3, key, concatBytes2(...msgs)),
    randomBytes: randomBytes3
  };
}
function createCurve2(curveDef, defHash) {
  const create3 = (hash3) => weierstrass2({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n15 = BigInt(1);
var _2n12 = BigInt(2);
var divNearest2 = (a, b) => (a + b / _2n12) / b;
function sqrtMod2(y) {
  const P = secp256k1P;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow22(b3, _3n6, P) * b3 % P;
  const b9 = pow22(b6, _3n6, P) * b3 % P;
  const b11 = pow22(b9, _2n12, P) * b2 % P;
  const b22 = pow22(b11, _11n, P) * b11 % P;
  const b44 = pow22(b22, _22n, P) * b22 % P;
  const b88 = pow22(b44, _44n, P) * b44 % P;
  const b176 = pow22(b88, _88n, P) * b88 % P;
  const b220 = pow22(b176, _44n, P) * b44 % P;
  const b223 = pow22(b220, _3n6, P) * b3 % P;
  const t1 = pow22(b223, _23n, P) * b22 % P;
  const t2 = pow22(t1, _6n, P) * b2 % P;
  const root = pow22(t2, _2n12, P);
  if (!Fp2.eql(Fp2.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field2(secp256k1P, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k12 = createCurve2({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp2,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n15 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b2 * k, n);
      const c2 = divNearest2(-b1 * k, n);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n);
      let k2 = mod2(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2566);
var _0n15 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n15 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n15 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2566(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes3(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2566(concatBytes3(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE2(n, 32);
var modP = (x) => mod2(x, secp256k1P);
var modN = (x) => mod2(x, secp256k1N);
var Point = secp256k12.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k12.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod2(c);
  if (y % _2n12 !== _0n15)
    y = modP(-y);
  const p = new Point(x, y, _1n15);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE2(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes3(32)) {
  const m = ensureBytes3("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes3("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE2(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE2(rand));
  if (k_ === _0n15)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes3("signature", signature, 64);
  const m = ensureBytes3("message", message);
  const pub = ensureBytes3("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE2(pub));
    const r = bytesToNumberBE2(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE2(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k12.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE: numberToBytesBE2,
    bytesToNumberBE: bytesToNumberBE2,
    taggedHash,
    mod: mod2
  }
}))();

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js
var nc3 = __toESM(require("crypto"), 1);
var crypto8 = nc3 && typeof nc3 === "object" && "webcrypto" in nc3 ? nc3.webcrypto : void 0;

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js
var u8a5 = (a) => a instanceof Uint8Array;
var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr3 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE5)
  throw new Error("Non little-endian hardware is not supported");
var hexes4 = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex5(bytes6) {
  if (!u8a5(bytes6))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i2 = 0; i2 < bytes6.length; i2++) {
    hex2 += hexes4[bytes6[i2]];
  }
  return hex2;
}
function hexToBytes5(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function utf8ToBytes7(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes6(data) {
  if (typeof data === "string")
    data = utf8ToBytes7(data);
  if (!u8a5(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes4(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad4 = 0;
  arrays.forEach((a) => {
    if (!u8a5(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad4);
    pad4 += a.length;
  });
  return r;
}
var Hash4 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor3(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes6(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes4(bytesLength = 32) {
  if (crypto8 && typeof crypto8.getRandomValues === "function") {
    return crypto8.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js
function number5(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes4(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number5(hash3.outputLen);
  number5(hash3.blockLen);
}
function exists4(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output4(out, instance) {
  bytes4(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number: number5,
  bool: bool2,
  bytes: bytes4,
  hash: hash2,
  exists: exists4,
  output: output4
};
var assert_default = assert;

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint644(view, byteOffset, value, isLE7) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE7);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE7 ? 4 : 0;
  const l = isLE7 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE7);
  view.setUint32(byteOffset + l, wl, isLE7);
}
var SHA22 = class extends Hash4 {
  constructor(blockLen, outputLen, padOffset, isLE7) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE7;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView4(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes6(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView2 = createView4(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE7 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE7);
    this.process(view, 0);
    const oview = createView4(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE7);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length3, finished, destroyed, pos } = this;
    to.length = length3;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length3 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js
var Chi3 = (a, b, c) => a & b ^ ~a & c;
var Maj3 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K3 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W3 = new Uint32Array(64);
var SHA2564 = class extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W3[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W3[i2 - 15];
      const W2 = SHA256_W3[i2 - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W2, 17) ^ rotr3(W2, 19) ^ W2 >>> 10;
      SHA256_W3[i2] = s1 + SHA256_W3[i2 - 7] + s0 + SHA256_W3[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr3(E, 6) ^ rotr3(E, 11) ^ rotr3(E, 25);
      const T1 = H + sigma1 + Chi3(E, F, G) + SHA256_K3[i2] + SHA256_W3[i2] | 0;
      const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
      const T2 = sigma0 + Maj3(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2243 = class extends SHA2564 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2567 = wrapConstructor3(() => new SHA2564());
var sha2242 = wrapConstructor3(() => new SHA2243());

// node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function chain2(...args) {
  const wrap = (a, b) => (c) => a(b(c));
  const encode13 = Array.from(args).reverse().reduce((acc, i2) => acc ? wrap(acc, i2.encode) : i2.encode, void 0);
  const decode17 = args.reduce((acc, i2) => acc ? wrap(acc, i2.decode) : i2.decode, void 0);
  return { encode: encode13, decode: decode17 };
}
function alphabet4(alphabet5) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i2) => {
        assertNumber(i2);
        if (i2 < 0 || i2 >= alphabet5.length)
          throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet5.length})`);
        return alphabet5[i2];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet5.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet5}`);
        return index;
      });
    }
  };
}
function join3(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from5) => {
      if (!Array.isArray(from5) || from5.length && typeof from5[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i2 of from5)
        if (typeof i2 !== "string")
          throw new Error(`join.encode: non-string input=${i2}`);
      return from5.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i2 of data)
        if (typeof i2 !== "string")
          throw new Error(`padding.encode: non-string input=${i2}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i2 of input)
        if (typeof i2 !== "string")
          throw new Error(`padding.decode: non-string input=${i2}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from5) => from5, decode: (to) => fn(to) };
}
function convertRadix(data, from5, to) {
  if (from5 < 2)
    throw new Error(`convertRadix: wrong from=${from5}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from5)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < digits.length; i2++) {
      const digit = digits[i2];
      const digitBase = from5 * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from5 * carry / from5 !== carry || digitBase - digit !== from5 * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      digits[i2] = Math.floor(digitBase / to);
      if (!Number.isSafeInteger(digits[i2]) || digits[i2] * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!digits[i2])
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd2 = (a, b) => !b ? a : gcd2(b, a % b);
var radix2carry2 = (from5, to) => from5 + (to - gcd2(from5, to));
function convertRadix22(data, from5, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from5 <= 0 || from5 > 32)
    throw new Error(`convertRadix2: wrong from=${from5}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry2(from5, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from5} to=${to} carryBits=${radix2carry2(from5, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from5)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from5}`);
    carry = carry << from5 | n;
    if (pos + from5 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from5}`);
    pos += from5;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from5)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes6) => {
      if (!(bytes6 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes6), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix22(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes6) => {
      if (!(bytes6 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix22(Array.from(bytes6), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper2(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base163 = chain2(radix22(4), alphabet4("0123456789ABCDEF"), join3(""));
var base323 = chain2(radix22(5), alphabet4("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join3(""));
var base32hex3 = chain2(radix22(5), alphabet4("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join3(""));
var base32crockford = chain2(radix22(5), alphabet4("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join3(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base643 = chain2(radix22(6), alphabet4("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join3(""));
var base64url3 = chain2(radix22(6), alphabet4("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join3(""));
var genBase58 = (abc) => chain2(radix(58), alphabet4(abc), join3(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr3 = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var base58xmr = {
  encode(data) {
    let res = "";
    for (let i2 = 0; i2 < data.length; i2 += 8) {
      const block = data.subarray(i2, i2 + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
    }
    return res;
  },
  decode(str) {
    let res = [];
    for (let i2 = 0; i2 < str.length; i2 += 11) {
      const slice2 = str.slice(i2, i2 + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice2.length);
      const block = base58.decode(slice2);
      for (let j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0)
          throw new Error("base58xmr: wrong padding");
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var BECH_ALPHABET2 = chain2(alphabet4("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join3(""));
var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod2(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS2.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS2[i2];
  }
  return chk;
}
function bechChecksum2(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod2(chk) ^ c >> 5;
  }
  chk = bech32Polymod2(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod2(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod2(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET2.encode(convertRadix22([chk % 2 ** 30], 30, 5, false));
}
function genBech322(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix22(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper2(fromWords);
  function encode13(prefix, words, limit2 = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    prefix = prefix.toLowerCase();
    return `${prefix}1${BECH_ALPHABET2.encode(words)}${bechChecksum2(prefix, words, ENCODING_CONST)}`;
  }
  function decode17(str, limit2 = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit2 !== false && str.length > limit2)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str = lowered;
    const sepIndex = str.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str.slice(0, sepIndex);
    const _words2 = str.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET2.decode(_words2).slice(0, -6);
    const sum = bechChecksum2(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper2(decode17);
  function decodeToBytes(str) {
    const { prefix, words } = decode17(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode13, decode: decode17, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech322 = genBech322("bech32");
var bech32m = genBech322("bech32m");
var utf8 = {
  encode: (data) => new TextDecoder().decode(data),
  decode: (str) => new TextEncoder().encode(str)
};
var hex = chain2(radix22(4), alphabet4("0123456789abcdef"), join3(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));
var CODERS = {
  utf8,
  hex,
  base16: base163,
  base32: base323,
  base64: base643,
  base64url: base64url3,
  base58,
  base58xmr
};
var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js
function number6(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function bool3(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes5(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes5(b, ...lengths) {
  if (!isBytes5(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists5(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output5(out, instance) {
  bytes5(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js
var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
var u324 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView5 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE6)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes8(str) {
  if (typeof str !== "string")
    throw new Error(`string expected, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes7(data) {
  if (typeof data === "string")
    data = utf8ToBytes8(data);
  else if (isBytes5(data))
    data = data.slice();
  else
    throw new Error(`Uint8Array expected, got ${typeof data}`);
  return data;
}
function checkOpts2(defaults, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function equalBytes4(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a.length; i2++)
    diff |= a[i2] ^ b[i2];
  return diff === 0;
}
var wrapCipher2 = /* @__NO_SIDE_EFFECTS__ */ (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint645(view, byteOffset, value, isLE7) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE7);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE7 ? 4 : 0;
  const l = isLE7 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE7);
  view.setUint32(byteOffset + l, wl, isLE7);
}

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS162 = /* @__PURE__ */ new Uint8Array(16);
var ZEROS322 = u324(ZEROS162);
var POLY = 225;
var mul2 = (s0, s1, s2, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s2 << 31 | s3 >>> 1,
    s2: s1 << 31 | s2 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
function _toGHASHKey(k) {
  k.reverse();
  const hiBit = k[15] & 1;
  let carry = 0;
  for (let i2 = 0; i2 < k.length; i2++) {
    const t = k[i2];
    k[i2] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k[0] ^= -hiBit & 225;
  return k;
}
var estimateWindow = (bytes6) => {
  if (bytes6 > 64 * 1024)
    return 8;
  if (bytes6 > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes7(key);
    bytes5(key, 16);
    const kView = createView5(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k2 = kView.getUint32(8, false);
    let k3 = kView.getUint32(12, false);
    const doubles = [];
    for (let i2 = 0; i2 < 128; i2++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
    }
    const W = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W))
      throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);
    this.W = W;
    const bits = 128;
    const windows = bits / W;
    const windowSize = this.windowSize = 2 ** W;
    const items = [];
    for (let w = 0; w < windows; w++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
        for (let j = 0; j < W; j++) {
          const bit = byte >>> W - j - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
        }
        items.push({ s0, s1, s2, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s2, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
    const { W, t, windowSize } = this;
    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
    const mask = (1 << W) - 1;
    let w = 0;
    for (const num of [s0, s1, s2, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W * bitPos & mask;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
          w += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o2;
    this.s3 = o3;
  }
  update(data) {
    data = toBytes7(data);
    exists5(this);
    const b32 = u324(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left2 = data.length % BLOCK_SIZE;
    for (let i2 = 0; i2 < blocks; i2++) {
      this._updateBlock(b32[i2 * 4 + 0], b32[i2 * 4 + 1], b32[i2 * 4 + 2], b32[i2 * 4 + 3]);
    }
    if (left2) {
      ZEROS162.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS322[0], ZEROS322[1], ZEROS322[2], ZEROS322[3]);
      ZEROS322.fill(0);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    exists5(this);
    output5(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u324(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes7(key);
    const ghKey = _toGHASHKey(key.slice());
    super(ghKey, expectedLength);
    ghKey.fill(0);
  }
  update(data) {
    data = toBytes7(data);
    exists5(this);
    const b32 = u324(data);
    const left2 = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i2 = 0; i2 < blocks; i2++) {
      this._updateBlock(swapLE(b32[i2 * 4 + 3]), swapLE(b32[i2 * 4 + 2]), swapLE(b32[i2 * 4 + 1]), swapLE(b32[i2 * 4 + 0]));
    }
    if (left2) {
      ZEROS162.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS322[3]), swapLE(ZEROS322[2]), swapLE(ZEROS322[1]), swapLE(ZEROS322[0]));
      ZEROS322.fill(0);
    }
    return this;
  }
  digestInto(out) {
    exists5(this);
    output5(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u324(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey2(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes7(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey2((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey2((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n) {
  return n << 1 ^ POLY2 & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul22(a);
  }
  return res;
}
var sbox = /* @__PURE__ */ (() => {
  let t = new Uint8Array(256);
  for (let i2 = 0, x = 1; i2 < 256; i2++, x ^= mul22(x))
    t[i2] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i2 = 0; i2 < 255; i2++) {
    let x = t[255 - i2];
    x |= x << 8;
    box[t[i2]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  return box;
})();
var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
function genTtable(sbox2, fn) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
  const T1 = T0.map(rotl32_8);
  const T2 = T1.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i2 = 0; i2 < 256; i2++) {
    for (let j = 0; j < 256; j++) {
      const idx = i2 * 256 + j;
      T01[idx] = T0[i2] ^ T1[j];
      T23[idx] = T2[i2] ^ T3[j];
      sbox22[idx] = sbox2[i2] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
}
var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = /* @__PURE__ */ (() => {
  const p = new Uint8Array(16);
  for (let i2 = 0, x = 1; i2 < 16; i2++, x = mul22(x))
    p[i2] = x;
  return p;
})();
function expandKeyLE(key) {
  bytes5(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
  const { sbox2 } = tableEncoding;
  const k32 = u324(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i2 = Nk; i2 < xk.length; i2++) {
    let t = xk[i2 - 1];
    if (i2 % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i2 / Nk - 1];
    else if (Nk > 6 && i2 % Nk === 4)
      t = subByte(t);
    xk[i2] = xk[i2 - Nk] ^ t;
  }
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0, T1, T2, T3 } = tableDecoding;
  for (let i2 = 0; i2 < Nk; i2 += 4) {
    for (let j = 0; j < 4; j++)
      xk[i2 + j] = encKey[Nk - i2 - 4 + j];
  }
  encKey.fill(0);
  for (let i2 = 4; i2 < Nk - 4; i2++) {
    const x = xk[i2];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i2] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i2 = 0; i2 < rounds; i2++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i2 = 0; i2 < rounds; i2++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function getDst(len, dst) {
  if (!dst)
    return new Uint8Array(len);
  bytes5(dst);
  if (dst.length < len)
    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
  return dst;
}
function ctrCounter(xk, nonce2, src3, dst) {
  bytes5(nonce2, BLOCK_SIZE2);
  bytes5(src3);
  const srcLen = src3.length;
  dst = getDst(srcLen, dst);
  const ctr3 = nonce2;
  const c32 = u324(ctr3);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u324(src3);
  const dst32 = u324(dst);
  for (let i2 = 0; i2 + 4 <= src32.length; i2 += 4) {
    dst32[i2 + 0] = src32[i2 + 0] ^ s0;
    dst32[i2 + 1] = src32[i2 + 1] ^ s1;
    dst32[i2 + 2] = src32[i2 + 2] ^ s2;
    dst32[i2 + 3] = src32[i2 + 3] ^ s3;
    let carry = 1;
    for (let i3 = ctr3.length - 1; i3 >= 0; i3--) {
      carry = carry + (ctr3[i3] & 255) | 0;
      ctr3[i3] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf2 = u8(b32);
    for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
      dst[i2] = src3[i2] ^ buf2[pos];
  }
  return dst;
}
function ctr32(xk, isLE7, nonce2, src3, dst) {
  bytes5(nonce2, BLOCK_SIZE2);
  bytes5(src3);
  dst = getDst(src3.length, dst);
  const ctr3 = nonce2;
  const c32 = u324(ctr3);
  const view = createView5(ctr3);
  const src32 = u324(src3);
  const dst32 = u324(dst);
  const ctrPos = isLE7 ? 0 : 12;
  const srcLen = src3.length;
  let ctrNum = view.getUint32(ctrPos, isLE7);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i2 = 0; i2 + 4 <= src32.length; i2 += 4) {
    dst32[i2 + 0] = src32[i2 + 0] ^ s0;
    dst32[i2 + 1] = src32[i2 + 1] ^ s1;
    dst32[i2 + 2] = src32[i2 + 2] ^ s2;
    dst32[i2 + 3] = src32[i2 + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE7);
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf2 = u8(b32);
    for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
      dst[i2] = src3[i2] ^ buf2[pos];
  }
  return dst;
}
var ctr = wrapCipher2({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce2) {
  bytes5(key);
  bytes5(nonce2, BLOCK_SIZE2);
  function processCtr(buf2, dst) {
    const xk = expandKeyLE(key);
    const n = nonce2.slice();
    const out = ctrCounter(xk, n, buf2, dst);
    xk.fill(0);
    n.fill(0);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  bytes5(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  const b = u324(plaintext);
  if (pcks5) {
    let left2 = BLOCK_SIZE2 - remaining;
    if (!left2)
      left2 = BLOCK_SIZE2;
    outLen = outLen + left2;
  }
  const out = getDst(outLen, dst);
  const o = u324(out);
  return { b, o, out };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
  const out = data.subarray(0, -lastByte);
  for (let i2 = 0; i2 < lastByte; i2++)
    if (data[len - i2 - 1] !== lastByte)
      throw new Error(`aes/pcks5: wrong padding`);
  return out;
}
function padPCKS(left2) {
  const tmp = new Uint8Array(16);
  const tmp32 = u324(tmp);
  tmp.set(left2);
  const paddingByte = BLOCK_SIZE2 - left2.length;
  for (let i2 = BLOCK_SIZE2 - paddingByte; i2 < BLOCK_SIZE2; i2++)
    tmp[i2] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher2({ blockSize: 16 }, function ecb2(key, opts = {}) {
  bytes5(key);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      bytes5(plaintext);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i2 = 0;
      for (; i2 + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = encrypt(xk, b[i2 + 0], b[i2 + 1], b[i2 + 2], b[i2 + 3]);
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
        const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const out = getDst(ciphertext.length, dst);
      const b = u324(ciphertext);
      const o = u324(out);
      for (let i2 = 0; i2 + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = decrypt(xk, b[i2 + 0], b[i2 + 1], b[i2 + 2], b[i2 + 3]);
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cbc = wrapCipher2({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts = {}) {
  bytes5(key);
  bytes5(iv, 16);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const n32 = u324(iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i2 = 0;
      for (; i2 + 4 <= b.length; ) {
        s0 ^= b[i2 + 0], s1 ^= b[i2 + 1], s2 ^= b[i2 + 2], s3 ^= b[i2 + 3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const n32 = u324(iv);
      const out = getDst(ciphertext.length, dst);
      const b = u324(ciphertext);
      const o = u324(out);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i2 = 0; i2 + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i2 + 0], s1 = b[i2 + 1], s2 = b[i2 + 2], s3 = b[i2 + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
        o[i2++] = o0 ^ ps0, o[i2++] = o1 ^ ps1, o[i2++] = o2 ^ ps2, o[i2++] = o3 ^ ps3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cfb = wrapCipher2({ blockSize: 16, nonceLength: 16 }, function cfb2(key, iv) {
  bytes5(key);
  bytes5(iv, 16);
  function processCfb(src3, isEncrypt, dst) {
    const xk = expandKeyLE(key);
    const srcLen = src3.length;
    dst = getDst(srcLen, dst);
    const src32 = u324(src3);
    const dst32 = u324(dst);
    const next32 = isEncrypt ? dst32 : src32;
    const n32 = u324(iv);
    let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
    for (let i2 = 0; i2 + 4 <= src32.length; ) {
      const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);
      dst32[i2 + 0] = src32[i2 + 0] ^ e0;
      dst32[i2 + 1] = src32[i2 + 1] ^ e1;
      dst32[i2 + 2] = src32[i2 + 2] ^ e2;
      dst32[i2 + 3] = src32[i2 + 3] ^ e3;
      s0 = next32[i2++], s1 = next32[i2++], s2 = next32[i2++], s3 = next32[i2++];
    }
    const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start < srcLen) {
      ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
      const buf2 = u8(new Uint32Array([s0, s1, s2, s3]));
      for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
        dst[i2] = src3[i2] ^ buf2[pos];
      buf2.fill(0);
    }
    xk.fill(0);
    return dst;
  }
  return {
    encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),
    decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst)
  };
});
function computeTag2(fn, isLE7, key, data, AAD) {
  const h = fn.create(key, data.length + (AAD?.length || 0));
  if (AAD)
    h.update(AAD);
  h.update(data);
  const num = new Uint8Array(16);
  const view = createView5(num);
  if (AAD)
    setBigUint645(view, 0, BigInt(AAD.length * 8), isLE7);
  setBigUint645(view, 8, BigInt(data.length * 8), isLE7);
  h.update(num);
  return h.digest();
}
var gcm = wrapCipher2({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce2, AAD) {
  bytes5(nonce2);
  if (nonce2.length === 0)
    throw new Error("aes/gcm: empty nonce");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag = computeTag2(ghash, false, authKey, data, AAD);
    for (let i2 = 0; i2 < tagMask.length; i2++)
      tag[i2] ^= tagMask[i2];
    return tag;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter, counter, authKey);
    if (nonce2.length === 12) {
      counter.set(nonce2);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView5(nonceLen);
      setBigUint645(view, 8, BigInt(nonce2.length * 8), false);
      ghash.create(authKey).update(nonce2).update(nonceLen).digestInto(counter);
    }
    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
    return { xk, authKey, counter, tagMask };
  }
  return {
    encrypt: (plaintext) => {
      bytes5(plaintext);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      ctr32(xk, false, counter, plaintext, out);
      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      out.set(tag, plaintext.length);
      xk.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes5(ciphertext);
      if (ciphertext.length < tagLength)
        throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = _computeTag(authKey, tagMask, data);
      if (!equalBytes4(tag, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter, data);
      authKey.fill(0);
      tagMask.fill(0);
      xk.fill(0);
      return out;
    }
  };
});
var limit = (name4, min, max) => (value) => {
  if (!Number.isSafeInteger(value) || min > value || value > max)
    throw new Error(`${name4}: invalid value=${value}, must be [${min}..${max}]`);
};
var siv = wrapCipher2({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce2, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  bytes5(nonce2);
  NONCE_LIMIT(nonce2.length);
  if (AAD) {
    bytes5(AAD);
    AAD_LIMIT(AAD.length);
  }
  function deriveKeys() {
    const len = key.length;
    if (len !== 16 && len !== 24 && len !== 32)
      throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(len);
    const authKey = new Uint8Array(16);
    const n32 = u324(nonce2);
    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
    let counter = 0;
    for (const derivedKey of [authKey, encKey].map(u324)) {
      const d32 = u324(derivedKey);
      for (let i2 = 0; i2 < d32.length; i2 += 2) {
        const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);
        d32[i2 + 0] = o0;
        d32[i2 + 1] = o1;
        s0 = ++counter;
      }
    }
    xk.fill(0);
    return { authKey, encKey: expandKeyLE(encKey) };
  }
  function _computeTag(encKey, authKey, data) {
    const tag = computeTag2(polyval, true, authKey, data, AAD);
    for (let i2 = 0; i2 < 12; i2++)
      tag[i2] ^= nonce2[i2];
    tag[15] &= 127;
    const t32 = u324(tag);
    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
    ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
    return tag;
  }
  function processSiv(encKey, tag, input) {
    let block = tag.slice();
    block[15] |= 128;
    return ctr32(encKey, true, block, input);
  }
  return {
    encrypt: (plaintext) => {
      bytes5(plaintext);
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag = _computeTag(encKey, authKey, plaintext);
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag, plaintext.length);
      out.set(processSiv(encKey, tag, plaintext));
      encKey.fill(0);
      authKey.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes5(ciphertext);
      CIPHER_LIMIT(ciphertext.length);
      const tag = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      encKey.fill(0);
      authKey.fill(0);
      if (!equalBytes4(tag, expectedTag))
        throw new Error("invalid polyval tag");
      return plaintext;
    }
  };
});

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_poly1305.js
var u8to162 = (a, i2) => a[i2++] & 255 | (a[i2++] & 255) << 8;
var Poly13052 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes7(key);
    bytes5(key, 32);
    const t0 = u8to162(key, 0);
    const t1 = u8to162(key, 2);
    const t2 = u8to162(key, 4);
    const t3 = u8to162(key, 6);
    const t4 = u8to162(key, 8);
    const t5 = u8to162(key, 10);
    const t6 = u8to162(key, 12);
    const t7 = u8to162(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i2 = 0; i2 < 8; i2++)
      this.pad[i2] = u8to162(key, 16 + 2 * i2);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to162(data, offset + 0);
    const t1 = u8to162(data, offset + 2);
    const t2 = u8to162(data, offset + 4);
    const t3 = u8to162(data, offset + 6);
    const t4 = u8to162(data, offset + 8);
    const t5 = u8to162(data, offset + 10);
    const t6 = u8to162(data, offset + 12);
    const t7 = u8to162(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad4 } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i2 = 2; i2 < 10; i2++) {
      h[i2] += c;
      c = h[i2] >>> 13;
      h[i2] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i2 = 1; i2 < 10; i2++) {
      g[i2] = h[i2] + c;
      c = g[i2] >>> 13;
      g[i2] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i2 = 0; i2 < 10; i2++)
      g[i2] &= mask;
    mask = ~mask;
    for (let i2 = 0; i2 < 10; i2++)
      h[i2] = h[i2] & mask | g[i2];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad4[0];
    h[0] = f & 65535;
    for (let i2 = 1; i2 < 8; i2++) {
      f = (h[i2] + pad4[i2] | 0) + (f >>> 16) | 0;
      h[i2] = f & 65535;
    }
  }
  update(data) {
    exists5(this);
    const { buffer: buffer2, blockLen } = this;
    data = toBytes7(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer2, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists5(this);
    output5(out, this);
    this.finished = true;
    const { buffer: buffer2, h } = this;
    let { pos } = this;
    if (pos) {
      buffer2[pos++] = 1;
      for (; pos < 16; pos++)
        buffer2[pos] = 0;
      this.process(buffer2, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      out[opos++] = h[i2] >>> 0;
      out[opos++] = h[i2] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey3(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes7(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly13052 = wrapConstructorWithKey3((key) => new Poly13052(key));

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_arx.js
var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
var sigma162 = _utf8ToBytes("expand 16-byte k");
var sigma322 = _utf8ToBytes("expand 32-byte k");
var sigma16_322 = u324(sigma162);
var sigma32_322 = u324(sigma322);
var sigma = sigma32_322.slice();
function rotl3(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned322(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN2 = 64;
var BLOCK_LEN322 = 16;
var MAX_COUNTER2 = 2 ** 32 - 1;
var U32_EMPTY2 = new Uint32Array();
function runCipher2(core, sigma2, key, nonce2, data, output6, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN2);
  const b32 = u324(block);
  const isAligned = isAligned322(data) && isAligned322(output6);
  const d32 = isAligned ? u324(data) : U32_EMPTY2;
  const o32 = isAligned ? u324(output6) : U32_EMPTY2;
  for (let pos = 0; pos < len; counter++) {
    core(sigma2, key, nonce2, b32, counter, rounds);
    if (counter >= MAX_COUNTER2)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN2, len - pos);
    if (isAligned && take === BLOCK_LEN2) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN322; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN2;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output6[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher2(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number6(counterLength);
  number6(rounds);
  bool3(counterRight);
  bool3(allowShortKeys);
  return (key, nonce2, data, output6, counter = 0) => {
    bytes5(key);
    bytes5(nonce2);
    bytes5(data);
    const len = data.length;
    if (!output6)
      output6 = new Uint8Array(len);
    bytes5(output6);
    number6(counter);
    if (counter < 0 || counter >= MAX_COUNTER2)
      throw new Error("arx: counter overflow");
    if (output6.length < len)
      throw new Error(`arx: output (${output6.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma2;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma2 = sigma32_322;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma2 = sigma16_322;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned322(nonce2)) {
      nonce2 = nonce2.slice();
      toClean.push(nonce2);
    }
    const k32 = u324(k);
    if (extendNonceFn) {
      if (nonce2.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma2, k32, u324(nonce2.subarray(0, 16)), k32);
      nonce2 = nonce2.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce2.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc4 = new Uint8Array(12);
      nc4.set(nonce2, counterRight ? 0 : 12 - nonce2.length);
      nonce2 = nc4;
      toClean.push(nonce2);
    }
    const n32 = u324(nonce2);
    runCipher2(core, sigma2, k32, n32, data, output6, counter, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output6;
  };
}

// node_modules/nostr-tools/node_modules/@noble/ciphers/esm/chacha.js
function chachaCore2(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl3(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl3(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl3(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl3(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl3(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl3(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl3(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl3(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl3(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl3(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl3(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl3(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl3(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl3(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl3(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl3(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl3(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl3(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl3(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl3(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl3(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl3(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl3(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl3(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl3(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl3(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl3(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl3(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl3(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl3(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl3(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl3(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha2(s, k, i2, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl3(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl3(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl3(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl3(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl3(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl3(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl3(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl3(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl3(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl3(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl3(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl3(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl3(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl3(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl3(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl3(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl3(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl3(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl3(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl3(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl3(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl3(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl3(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl3(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl3(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl3(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl3(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl3(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl3(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl3(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl3(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl3(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha202 = /* @__PURE__ */ createCipher2(chachaCore2, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha202 = /* @__PURE__ */ createCipher2(chachaCore2, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha2,
  allowShortKeys: false
});
var ZEROS163 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded2 = (h, msg) => {
  h.update(msg);
  const left2 = msg.length % 16;
  if (left2)
    h.update(ZEROS163.subarray(left2));
};
var ZEROS323 = /* @__PURE__ */ new Uint8Array(32);
function computeTag3(fn, key, nonce2, data, AAD) {
  const authKey = fn(key, nonce2, ZEROS323);
  const h = poly13052.create(authKey);
  if (AAD)
    updatePadded2(h, AAD);
  updatePadded2(h, data);
  const num = new Uint8Array(16);
  const view = createView5(num);
  setBigUint645(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint645(view, 8, BigInt(data.length), true);
  h.update(num);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead2 = (xorStream) => (key, nonce2, AAD) => {
  const tagLength = 16;
  bytes5(key, 32);
  bytes5(nonce2);
  return {
    encrypt: (plaintext, output6) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output6) {
        bytes5(output6, clength);
      } else {
        output6 = new Uint8Array(clength);
      }
      xorStream(key, nonce2, plaintext, output6, 1);
      const tag = computeTag3(xorStream, key, nonce2, output6.subarray(0, -tagLength), AAD);
      output6.set(tag, plength);
      return output6;
    },
    decrypt: (ciphertext, output6) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output6) {
        bytes5(output6, plength);
      } else {
        output6 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag3(xorStream, key, nonce2, data, AAD);
      if (!equalBytes4(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce2, data, output6, 1);
      return output6;
    }
  };
};
var chacha20poly13052 = /* @__PURE__ */ wrapCipher2({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead2(chacha202));
var xchacha20poly13052 = /* @__PURE__ */ wrapCipher2({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead2(xchacha202));

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js
var HMAC3 = class extends Hash4 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash3);
    const key = toBytes6(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad4 = new Uint8Array(blockLen);
    pad4.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad4.length; i2++)
      pad4[i2] ^= 54;
    this.iHash.update(pad4);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad4.length; i2++)
      pad4[i2] ^= 54 ^ 92;
    this.oHash.update(pad4);
    pad4.fill(0);
  }
  update(buf2) {
    assert_default.exists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac3 = (hash3, key, message) => new HMAC3(hash3, key).update(message).digest();
hmac3.create = (hash3, key) => new HMAC3(hash3, key);

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js
function extract(hash3, ikm, salt) {
  assert_default.hash(hash3);
  if (salt === void 0)
    salt = new Uint8Array(hash3.outputLen);
  return hmac3(hash3, toBytes6(salt), toBytes6(ikm));
}
var HKDF_COUNTER = new Uint8Array([0]);
var EMPTY_BUFFER2 = new Uint8Array();
function expand(hash3, prk, info, length3 = 32) {
  assert_default.hash(hash3);
  assert_default.number(length3);
  if (length3 > 255 * hash3.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length3 / hash3.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER2;
  const okm = new Uint8Array(blocks * hash3.outputLen);
  const HMAC4 = hmac3.create(hash3, prk);
  const HMACTmp = HMAC4._cloneInto();
  const T = new Uint8Array(HMAC4.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER2 : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash3.outputLen * counter);
    HMAC4._cloneInto(HMACTmp);
  }
  HMAC4.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length3);
}

// node_modules/nostr-tools/lib/esm/index.js
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name4 in all)
    __defProp2(target, name4, { get: all[name4], enumerable: true });
};
var verifiedSymbol = Symbol("verified");
var isRecord = (obj) => obj instanceof Object;
function validateEvent(event) {
  if (!isRecord(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i2 = 0; i2 < event.tags.length; i2++) {
    let tag = event.tags[i2];
    if (!Array.isArray(tag))
      return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] !== "string")
        return false;
    }
  }
  return true;
}
var utils_exports2 = {};
__export2(utils_exports2, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  bytesToHex: () => bytesToHex5,
  hexToBytes: () => hexToBytes5,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8");
var utf8Encoder = new TextEncoder();
function normalizeURL(url) {
  try {
    if (url.indexOf("://") === -1)
      url = "wss://" + url;
    let p = new URL(url);
    p.pathname = p.pathname.replace(/\/+/g, "/");
    if (p.pathname.endsWith("/"))
      p.pathname = p.pathname.slice(0, -1);
    if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
      p.port = "";
    p.searchParams.sort();
    p.hash = "";
    return p.toString();
  } catch (e) {
    throw new Error(`Invalid URL: ${url}`);
  }
}
function insertEventIntoDescendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return b.created_at - event.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function insertEventIntoAscendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return event.created_at - b.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function binarySearch(arr, compare4) {
  let start = 0;
  let end = arr.length - 1;
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    const cmp = compare4(arr[mid]);
    if (cmp === 0) {
      return [mid, true];
    }
    if (cmp < 0) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return [start, false];
}
var QueueNode = class {
  constructor(message) {
    __publicField(this, "value");
    __publicField(this, "next", null);
    __publicField(this, "prev", null);
    this.value = message;
  }
};
var Queue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
    this.first = null;
    this.last = null;
  }
  enqueue(value) {
    const newNode = new QueueNode(value);
    if (!this.last) {
      this.first = newNode;
      this.last = newNode;
    } else if (this.last === this.first) {
      this.last = newNode;
      this.last.prev = this.first;
      this.first.next = newNode;
    } else {
      newNode.prev = this.last;
      this.last.next = newNode;
      this.last = newNode;
    }
    return true;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const target2 = this.first;
      this.first = null;
      this.last = null;
      return target2.value;
    }
    const target = this.first;
    this.first = target.next;
    if (this.first) {
      this.first.prev = null;
    }
    return target.value;
  }
};
var JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex5(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t, secretKey) {
    const event = t;
    event.pubkey = bytesToHex5(schnorr.getPublicKey(secretKey));
    event.id = getEventHash(event);
    event.sig = bytesToHex5(schnorr.sign(getEventHash(event), secretKey));
    event[verifiedSymbol] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol] === "boolean")
      return event[verifiedSymbol];
    const hash3 = getEventHash(event);
    if (hash3 !== event.id) {
      event[verifiedSymbol] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash3, event.pubkey);
      event[verifiedSymbol] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol] = false;
      return false;
    }
  }
};
function serializeEvent(evt) {
  if (!validateEvent(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash(event) {
  let eventHash = sha2567(utf8Encoder.encode(serializeEvent(event)));
  return bytesToHex5(eventHash);
}
var i = new JS();
var generateSecretKey = i.generateSecretKey;
var getPublicKey = i.getPublicKey;
var finalizeEvent = i.finalizeEvent;
var verifyEvent = i.verifyEvent;
var kinds_exports = {};
__export2(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DirectMessageRelaysList: () => DirectMessageRelaysList,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  GiftWrap: () => GiftWrap,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  PrivateDirectMessage: () => PrivateDirectMessage,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  Seal: () => Seal,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time2,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isAddressableKind: () => isAddressableKind,
  isEphemeralKind: () => isEphemeralKind,
  isKind: () => isKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(kind) {
  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);
}
function isReplaceableKind(kind) {
  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
}
function isEphemeralKind(kind) {
  return 2e4 <= kind && kind < 3e4;
}
function isAddressableKind(kind) {
  return 3e4 <= kind && kind < 4e4;
}
function classifyKind(kind) {
  if (isRegularKind(kind))
    return "regular";
  if (isReplaceableKind(kind))
    return "replaceable";
  if (isEphemeralKind(kind))
    return "ephemeral";
  if (isAddressableKind(kind))
    return "parameterized";
  return "unknown";
}
function isKind(event, kind) {
  const kindAsArray = kind instanceof Array ? kind : [kind];
  return validateEvent(event) && kindAsArray.includes(event.kind) || false;
}
var Metadata = 0;
var ShortTextNote = 1;
var RecommendRelay = 2;
var Contacts = 3;
var EncryptedDirectMessage = 4;
var EventDeletion = 5;
var Repost = 6;
var Reaction = 7;
var BadgeAward = 8;
var Seal = 13;
var PrivateDirectMessage = 14;
var GenericRepost = 16;
var ChannelCreation = 40;
var ChannelMetadata = 41;
var ChannelMessage = 42;
var ChannelHideMessage = 43;
var ChannelMuteUser = 44;
var OpenTimestamps = 1040;
var GiftWrap = 1059;
var FileMetadata = 1063;
var LiveChatMessage = 1311;
var ProblemTracker = 1971;
var Report = 1984;
var Reporting = 1984;
var Label = 1985;
var CommunityPostApproval = 4550;
var JobRequest = 5999;
var JobResult = 6999;
var JobFeedback = 7e3;
var ZapGoal = 9041;
var ZapRequest = 9734;
var Zap = 9735;
var Highlights = 9802;
var Mutelist = 1e4;
var Pinlist = 10001;
var RelayList = 10002;
var BookmarkList = 10003;
var CommunitiesList = 10004;
var PublicChatsList = 10005;
var BlockedRelaysList = 10006;
var SearchRelaysList = 10007;
var InterestsList = 10015;
var UserEmojiList = 10030;
var DirectMessageRelaysList = 10050;
var FileServerPreference = 10096;
var NWCWalletInfo = 13194;
var LightningPubRPC = 21e3;
var ClientAuth = 22242;
var NWCWalletRequest = 23194;
var NWCWalletResponse = 23195;
var NostrConnect = 24133;
var HTTPAuth = 27235;
var Followsets = 3e4;
var Genericlists = 30001;
var Relaysets = 30002;
var Bookmarksets = 30003;
var Curationsets = 30004;
var ProfileBadges = 30008;
var BadgeDefinition = 30009;
var Interestsets = 30015;
var CreateOrUpdateStall = 30017;
var CreateOrUpdateProduct = 30018;
var LongFormArticle = 30023;
var DraftLong = 30024;
var Emojisets = 30030;
var Application = 30078;
var LiveEvent = 30311;
var UserStatuses = 30315;
var ClassifiedListing = 30402;
var DraftClassifiedListing = 30403;
var Date2 = 31922;
var Time2 = 31923;
var Calendar = 31924;
var CalendarEventRSVP = 31925;
var Handlerrecommendation = 31989;
var Handlerinformation = 31990;
var CommunityDefinition = 34550;
function matchFilter(filter, event) {
  if (filter.ids && filter.ids.indexOf(event.id) === -1) {
    return false;
  }
  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {
    return false;
  }
  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {
    return false;
  }
  for (let f in filter) {
    if (f[0] === "#") {
      let tagName = f.slice(1);
      let values = filter[`#${tagName}`];
      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))
        return false;
    }
  }
  if (filter.since && event.created_at < filter.since)
    return false;
  if (filter.until && event.created_at > filter.until)
    return false;
  return true;
}
function matchFilters(filters, event) {
  for (let i2 = 0; i2 < filters.length; i2++) {
    if (matchFilter(filters[i2], event)) {
      return true;
    }
  }
  return false;
}
var fakejson_exports = {};
__export2(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s, s + 64);
}
function getInt(json, field) {
  let len = field.length;
  let idx = json.indexOf(`"${field}":`) + len + 3;
  let sliced = json.slice(idx);
  let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
  return parseInt(sliced.slice(0, end), 10);
}
function getSubscriptionId(json) {
  let idx = json.slice(0, 22).indexOf(`"EVENT"`);
  if (idx === -1)
    return null;
  let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
  if (pstart === -1)
    return null;
  let start = idx + 7 + 1 + pstart;
  let pend = json.slice(start + 1, 80).indexOf(`"`);
  if (pend === -1)
    return null;
  let end = start + 1 + pend;
  return json.slice(start + 1, end);
}
function matchEventId(json, id) {
  return id === getHex64(json, "id");
}
function matchEventPubkey(json, pubkey) {
  return pubkey === getHex64(json, "pubkey");
}
function matchEventKind(json, kind) {
  return kind === getInt(json, "kind");
}
var nip42_exports = {};
__export2(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(relayURL, challenge2) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", relayURL],
      ["challenge", challenge2]
    ],
    content: ""
  };
}
async function yieldThread() {
  return new Promise((resolve) => {
    const ch = new MessageChannel();
    const handler = () => {
      ch.port1.removeEventListener("message", handler);
      resolve();
    };
    ch.port1.addEventListener("message", handler);
    ch.port2.postMessage(0);
    ch.port1.start();
  });
}
var SendingOnClosedConnection = class extends Error {
  constructor(message, relay) {
    super(`Tried to send message '${message} on a closed connection to ${relay}.`);
    this.name = "SendingOnClosedConnection";
  }
};
var AbstractRelay = class {
  constructor(url, opts) {
    __publicField(this, "url");
    __publicField(this, "_connected", false);
    __publicField(this, "onclose", null);
    __publicField(this, "onnotice", (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`));
    __publicField(this, "baseEoseTimeout", 4400);
    __publicField(this, "connectionTimeout", 4400);
    __publicField(this, "publishTimeout", 4400);
    __publicField(this, "openSubs", /* @__PURE__ */ new Map());
    __publicField(this, "connectionTimeoutHandle");
    __publicField(this, "connectionPromise");
    __publicField(this, "openCountRequests", /* @__PURE__ */ new Map());
    __publicField(this, "openEventPublishes", /* @__PURE__ */ new Map());
    __publicField(this, "ws");
    __publicField(this, "incomingMessageQueue", new Queue());
    __publicField(this, "queueRunning", false);
    __publicField(this, "challenge");
    __publicField(this, "authPromise");
    __publicField(this, "serial", 0);
    __publicField(this, "verifyEvent");
    __publicField(this, "_WebSocket");
    this.url = normalizeURL(url);
    this.verifyEvent = opts.verifyEvent;
    this._WebSocket = opts.websocketImplementation || WebSocket;
  }
  static async connect(url, opts) {
    const relay = new AbstractRelay(url, opts);
    await relay.connect();
    return relay;
  }
  closeAllSubscriptions(reason) {
    for (let [_, sub] of this.openSubs) {
      sub.close(reason);
    }
    this.openSubs.clear();
    for (let [_, ep] of this.openEventPublishes) {
      ep.reject(new Error(reason));
    }
    this.openEventPublishes.clear();
    for (let [_, cr] of this.openCountRequests) {
      cr.reject(new Error(reason));
    }
    this.openCountRequests.clear();
  }
  get connected() {
    return this._connected;
  }
  async connect() {
    if (this.connectionPromise)
      return this.connectionPromise;
    this.challenge = void 0;
    this.authPromise = void 0;
    this.connectionPromise = new Promise((resolve, reject) => {
      this.connectionTimeoutHandle = setTimeout(() => {
        reject("connection timed out");
        this.connectionPromise = void 0;
        this.onclose?.();
        this.closeAllSubscriptions("relay connection timed out");
      }, this.connectionTimeout);
      try {
        this.ws = new this._WebSocket(this.url);
      } catch (err) {
        clearTimeout(this.connectionTimeoutHandle);
        reject(err);
        return;
      }
      this.ws.onopen = () => {
        clearTimeout(this.connectionTimeoutHandle);
        this._connected = true;
        resolve();
      };
      this.ws.onerror = (ev) => {
        clearTimeout(this.connectionTimeoutHandle);
        reject(ev.message || "websocket error");
        if (this._connected) {
          this._connected = false;
          this.connectionPromise = void 0;
          this.onclose?.();
          this.closeAllSubscriptions("relay connection errored");
        }
      };
      this.ws.onclose = (ev) => {
        clearTimeout(this.connectionTimeoutHandle);
        reject(ev.message || "websocket closed");
        if (this._connected) {
          this._connected = false;
          this.connectionPromise = void 0;
          this.onclose?.();
          this.closeAllSubscriptions("relay connection closed");
        }
      };
      this.ws.onmessage = this._onmessage.bind(this);
    });
    return this.connectionPromise;
  }
  async runQueue() {
    this.queueRunning = true;
    while (true) {
      if (false === this.handleNext()) {
        break;
      }
      await yieldThread();
    }
    this.queueRunning = false;
  }
  handleNext() {
    const json = this.incomingMessageQueue.dequeue();
    if (!json) {
      return false;
    }
    const subid = getSubscriptionId(json);
    if (subid) {
      const so = this.openSubs.get(subid);
      if (!so) {
        return;
      }
      const id = getHex64(json, "id");
      const alreadyHave = so.alreadyHaveEvent?.(id);
      so.receivedEvent?.(this, id);
      if (alreadyHave) {
        return;
      }
    }
    try {
      let data = JSON.parse(json);
      switch (data[0]) {
        case "EVENT": {
          const so = this.openSubs.get(data[1]);
          const event = data[2];
          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {
            so.onevent(event);
          }
          return;
        }
        case "COUNT": {
          const id = data[1];
          const payload = data[2];
          const cr = this.openCountRequests.get(id);
          if (cr) {
            cr.resolve(payload.count);
            this.openCountRequests.delete(id);
          }
          return;
        }
        case "EOSE": {
          const so = this.openSubs.get(data[1]);
          if (!so)
            return;
          so.receivedEose();
          return;
        }
        case "OK": {
          const id = data[1];
          const ok = data[2];
          const reason = data[3];
          const ep = this.openEventPublishes.get(id);
          if (ep) {
            clearTimeout(ep.timeout);
            if (ok)
              ep.resolve(reason);
            else
              ep.reject(new Error(reason));
            this.openEventPublishes.delete(id);
          }
          return;
        }
        case "CLOSED": {
          const id = data[1];
          const so = this.openSubs.get(id);
          if (!so)
            return;
          so.closed = true;
          so.close(data[2]);
          return;
        }
        case "NOTICE":
          this.onnotice(data[1]);
          return;
        case "AUTH": {
          this.challenge = data[1];
          return;
        }
      }
    } catch (err) {
      return;
    }
  }
  async send(message) {
    if (!this.connectionPromise)
      throw new SendingOnClosedConnection(message, this.url);
    this.connectionPromise.then(() => {
      this.ws?.send(message);
    });
  }
  async auth(signAuthEvent) {
    const challenge2 = this.challenge;
    if (!challenge2)
      throw new Error("can't perform auth, no challenge was received");
    if (this.authPromise)
      return this.authPromise;
    this.authPromise = new Promise(async (resolve, reject) => {
      try {
        let evt = await signAuthEvent(makeAuthEvent(this.url, challenge2));
        let timeout = setTimeout(() => {
          let ep = this.openEventPublishes.get(evt.id);
          if (ep) {
            ep.reject(new Error("auth timed out"));
            this.openEventPublishes.delete(evt.id);
          }
        }, this.publishTimeout);
        this.openEventPublishes.set(evt.id, { resolve, reject, timeout });
        this.send('["AUTH",' + JSON.stringify(evt) + "]");
      } catch (err) {
        console.warn("subscribe auth function failed:", err);
      }
    });
    return this.authPromise;
  }
  async publish(event) {
    const ret = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        const ep = this.openEventPublishes.get(event.id);
        if (ep) {
          ep.reject(new Error("publish timed out"));
          this.openEventPublishes.delete(event.id);
        }
      }, this.publishTimeout);
      this.openEventPublishes.set(event.id, { resolve, reject, timeout });
    });
    this.send('["EVENT",' + JSON.stringify(event) + "]");
    return ret;
  }
  async count(filters, params) {
    this.serial++;
    const id = params?.id || "count:" + this.serial;
    const ret = new Promise((resolve, reject) => {
      this.openCountRequests.set(id, { resolve, reject });
    });
    this.send('["COUNT","' + id + '",' + JSON.stringify(filters).substring(1));
    return ret;
  }
  subscribe(filters, params) {
    const subscription = this.prepareSubscription(filters, params);
    subscription.fire();
    return subscription;
  }
  prepareSubscription(filters, params) {
    this.serial++;
    const id = params.id || (params.label ? params.label + ":" : "sub:") + this.serial;
    const subscription = new Subscription(this, id, filters, params);
    this.openSubs.set(id, subscription);
    return subscription;
  }
  close() {
    this.closeAllSubscriptions("relay connection closed by us");
    this._connected = false;
    this.ws?.close();
  }
  _onmessage(ev) {
    this.incomingMessageQueue.enqueue(ev.data);
    if (!this.queueRunning) {
      this.runQueue();
    }
  }
};
var Subscription = class {
  constructor(relay, id, filters, params) {
    __publicField(this, "relay");
    __publicField(this, "id");
    __publicField(this, "closed", false);
    __publicField(this, "eosed", false);
    __publicField(this, "filters");
    __publicField(this, "alreadyHaveEvent");
    __publicField(this, "receivedEvent");
    __publicField(this, "onevent");
    __publicField(this, "oneose");
    __publicField(this, "onclose");
    __publicField(this, "eoseTimeout");
    __publicField(this, "eoseTimeoutHandle");
    this.relay = relay;
    this.filters = filters;
    this.id = id;
    this.alreadyHaveEvent = params.alreadyHaveEvent;
    this.receivedEvent = params.receivedEvent;
    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;
    this.oneose = params.oneose;
    this.onclose = params.onclose;
    this.onevent = params.onevent || ((event) => {
      console.warn(
        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,
        event
      );
    });
  }
  fire() {
    this.relay.send('["REQ","' + this.id + '",' + JSON.stringify(this.filters).substring(1));
    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);
  }
  receivedEose() {
    if (this.eosed)
      return;
    clearTimeout(this.eoseTimeoutHandle);
    this.eosed = true;
    this.oneose?.();
  }
  close(reason = "closed by caller") {
    if (!this.closed && this.relay.connected) {
      try {
        this.relay.send('["CLOSE",' + JSON.stringify(this.id) + "]");
      } catch (err) {
        if (err instanceof SendingOnClosedConnection) {
        } else {
          throw err;
        }
      }
      this.closed = true;
    }
    this.relay.openSubs.delete(this.id);
    this.onclose?.(reason);
  }
};
var _WebSocket;
try {
  _WebSocket = WebSocket;
} catch {
}
var Relay = class extends AbstractRelay {
  constructor(url) {
    super(url, { verifyEvent, websocketImplementation: _WebSocket });
  }
  static async connect(url) {
    const relay = new Relay(url);
    await relay.connect();
    return relay;
  }
};
var _WebSocket2;
try {
  _WebSocket2 = WebSocket;
} catch {
}
var nip19_exports = {};
__export2(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  Bech32MaxSize: () => Bech32MaxSize,
  NostrTypeGuard: () => NostrTypeGuard,
  decode: () => decode16,
  decodeNostrURI: () => decodeNostrURI,
  encodeBytes: () => encodeBytes2,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nsecEncode: () => nsecEncode
});
var NostrTypeGuard = {
  isNProfile: (value) => /^nprofile1[a-z\d]+$/.test(value || ""),
  isNEvent: (value) => /^nevent1[a-z\d]+$/.test(value || ""),
  isNAddr: (value) => /^naddr1[a-z\d]+$/.test(value || ""),
  isNSec: (value) => /^nsec1[a-z\d]{58}$/.test(value || ""),
  isNPub: (value) => /^npub1[a-z\d]{58}$/.test(value || ""),
  isNote: (value) => /^note1[a-z\d]+$/.test(value || ""),
  isNcryptsec: (value) => /^ncryptsec1[a-z\d]+$/.test(value || "")
};
var Bech32MaxSize = 5e3;
var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(number7) {
  const uint8Array = new Uint8Array(4);
  uint8Array[0] = number7 >> 24 & 255;
  uint8Array[1] = number7 >> 16 & 255;
  uint8Array[2] = number7 >> 8 & 255;
  uint8Array[3] = number7 & 255;
  return uint8Array;
}
function decodeNostrURI(nip19code) {
  try {
    if (nip19code.startsWith("nostr:"))
      nip19code = nip19code.substring(6);
    return decode16(nip19code);
  } catch (_err) {
    return { type: "invalid", data: null };
  }
}
function decode16(code4) {
  let { prefix, words } = bech322.decode(code4, Bech32MaxSize);
  let data = new Uint8Array(bech322.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex5(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex5(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
          author: tlv[2]?.[0] ? bytesToHex5(tlv[2][0]) : void 0,
          kind: tlv[3]?.[0] ? parseInt(bytesToHex5(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for naddr");
      if (!tlv[2]?.[0])
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!tlv[3]?.[0])
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(tlv[0][0]),
          pubkey: bytesToHex5(tlv[2][0]),
          kind: parseInt(bytesToHex5(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex5(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t = rest[0];
    let l = rest[1];
    let v = rest.slice(2, 2 + l);
    rest = rest.slice(2 + l);
    if (v.length < l)
      throw new Error(`not enough data to read on TLV ${t}`);
    result[t] = result[t] || [];
    result[t].push(v);
  }
  return result;
}
function nsecEncode(key) {
  return encodeBytes2("nsec", key);
}
function npubEncode(hex2) {
  return encodeBytes2("npub", hexToBytes5(hex2));
}
function noteEncode(hex2) {
  return encodeBytes2("note", hexToBytes5(hex2));
}
function encodeBech32(prefix, data) {
  let words = bech322.toWords(data);
  return bech322.encode(prefix, words, Bech32MaxSize);
}
function encodeBytes2(prefix, bytes6) {
  return encodeBech32(prefix, bytes6);
}
function nprofileEncode(profile) {
  let data = encodeTLV({
    0: [hexToBytes5(profile.pubkey)],
    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
  });
  return encodeBech32("nprofile", data);
}
function neventEncode(event) {
  let kindArray;
  if (event.kind !== void 0) {
    kindArray = integerToUint8Array(event.kind);
  }
  let data = encodeTLV({
    0: [hexToBytes5(event.id)],
    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
    2: event.author ? [hexToBytes5(event.author)] : [],
    3: kindArray ? [new Uint8Array(kindArray)] : []
  });
  return encodeBech32("nevent", data);
}
function naddrEncode(addr) {
  let kind = new ArrayBuffer(4);
  new DataView(kind).setUint32(0, addr.kind, false);
  let data = encodeTLV({
    0: [utf8Encoder.encode(addr.identifier)],
    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
    2: [hexToBytes5(addr.pubkey)],
    3: [new Uint8Array(kind)]
  });
  return encodeBech32("naddr", data);
}
function encodeTLV(tlv) {
  let entries = [];
  Object.entries(tlv).reverse().forEach(([t, vs]) => {
    vs.forEach((v) => {
      let entry = new Uint8Array(v.length + 2);
      entry.set([parseInt(t)], 0);
      entry.set([v.length], 1);
      entry.set(v, 2);
      entries.push(entry);
    });
  });
  return concatBytes4(...entries);
}
var nip04_exports = {};
__export2(nip04_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2
});
function encrypt2(secretKey, pubkey, text) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex5(secretKey) : secretKey;
  const key = secp256k12.getSharedSecret(privkey, "02" + pubkey);
  const normalizedKey = getNormalizedX(key);
  let iv = Uint8Array.from(randomBytes4(16));
  let plaintext = utf8Encoder.encode(text);
  let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);
  let ctb64 = base643.encode(new Uint8Array(ciphertext));
  let ivb64 = base643.encode(new Uint8Array(iv.buffer));
  return `${ctb64}?iv=${ivb64}`;
}
function decrypt2(secretKey, pubkey, data) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex5(secretKey) : secretKey;
  let [ctb64, ivb64] = data.split("?iv=");
  let key = secp256k12.getSharedSecret(privkey, "02" + pubkey);
  let normalizedKey = getNormalizedX(key);
  let iv = base643.decode(ivb64);
  let ciphertext = base643.decode(ctb64);
  let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);
  return utf8Decoder.decode(plaintext);
}
function getNormalizedX(key) {
  return key.slice(1, 33);
}
var nip05_exports = {};
__export2(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  isNip05: () => isNip05,
  isValid: () => isValid,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
var isNip05 = (value) => NIP05_REGEX.test(value || "");
var _fetch;
try {
  _fetch = fetch;
} catch (_) {
  null;
}
function useFetchImplementation(fetchImplementation) {
  _fetch = fetchImplementation;
}
async function searchDomain(domain2, query = "") {
  try {
    const url = `https://${domain2}/.well-known/nostr.json?name=${query}`;
    const res = await _fetch(url, { redirect: "manual" });
    if (res.status !== 200) {
      throw Error("Wrong response code");
    }
    const json = await res.json();
    return json.names;
  } catch (_) {
    return {};
  }
}
async function queryProfile(fullname) {
  const match2 = fullname.match(NIP05_REGEX);
  if (!match2)
    return null;
  const [, name4 = "_", domain2] = match2;
  try {
    const url = `https://${domain2}/.well-known/nostr.json?name=${name4}`;
    const res = await _fetch(url, { redirect: "manual" });
    if (res.status !== 200) {
      throw Error("Wrong response code");
    }
    const json = await res.json();
    const pubkey = json.names[name4];
    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;
  } catch (_e) {
    return null;
  }
}
async function isValid(pubkey, nip05) {
  const res = await queryProfile(nip05);
  return res ? res.pubkey === pubkey : false;
}
var nip10_exports = {};
__export2(nip10_exports, {
  parse: () => parse2
});
function parse2(event) {
  const result = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: [],
    quotes: []
  };
  let maybeParent;
  let maybeRoot;
  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {
    const tag = event.tags[i2];
    if (tag[0] === "e" && tag[1]) {
      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;
      const eventPointer = {
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : [],
        author: eTagAuthor
      };
      if (eTagMarker === "root") {
        result.root = eventPointer;
        continue;
      }
      if (eTagMarker === "reply") {
        result.reply = eventPointer;
        continue;
      }
      if (eTagMarker === "mention") {
        result.mentions.push(eventPointer);
        continue;
      }
      if (!maybeParent) {
        maybeParent = eventPointer;
      } else {
        maybeRoot = eventPointer;
      }
      result.mentions.push(eventPointer);
      continue;
    }
    if (tag[0] === "q" && tag[1]) {
      const [_, eTagEventId, eTagRelayUrl] = tag;
      result.quotes.push({
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : []
      });
    }
    if (tag[0] === "p" && tag[1]) {
      result.profiles.push({
        pubkey: tag[1],
        relays: tag[2] ? [tag[2]] : []
      });
      continue;
    }
  }
  if (!result.root) {
    result.root = maybeRoot || maybeParent || result.reply;
  }
  if (!result.reply) {
    result.reply = maybeParent || result.root;
  }
  ;
  [result.reply, result.root].forEach((ref) => {
    if (!ref)
      return;
    let idx = result.mentions.indexOf(ref);
    if (idx !== -1) {
      result.mentions.splice(idx, 1);
    }
    if (ref.author) {
      let author = result.profiles.find((p) => p.pubkey === ref.author);
      if (author && author.relays) {
        if (!ref.relays) {
          ref.relays = [];
        }
        author.relays.forEach((url) => {
          if (ref.relays?.indexOf(url) === -1)
            ref.relays.push(url);
        });
        author.relays = ref.relays;
      }
    }
  });
  result.mentions.forEach((ref) => {
    if (ref.author) {
      let author = result.profiles.find((p) => p.pubkey === ref.author);
      if (author && author.relays) {
        if (!ref.relays) {
          ref.relays = [];
        }
        author.relays.forEach((url) => {
          if (ref.relays.indexOf(url) === -1)
            ref.relays.push(url);
        });
        author.relays = ref.relays;
      }
    }
  });
  return result;
}
var nip11_exports = {};
__export2(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch {
}
function useFetchImplementation2(fetchImplementation) {
  _fetch2 = fetchImplementation;
}
async function fetchRelayInformation(url) {
  return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export2(nip13_exports, {
  fastEventHash: () => fastEventHash,
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(hex2) {
  let count = 0;
  for (let i2 = 0; i2 < 64; i2 += 8) {
    const nibble = parseInt(hex2.substring(i2, i2 + 8), 16);
    if (nibble === 0) {
      count += 32;
    } else {
      count += Math.clz32(nibble);
      break;
    }
  }
  return count;
}
function minePow(unsigned, difficulty) {
  let count = 0;
  const event = unsigned;
  const tag = ["nonce", count.toString(), difficulty.toString()];
  event.tags.push(tag);
  while (true) {
    const now2 = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (now2 !== event.created_at) {
      count = 0;
      event.created_at = now2;
    }
    tag[1] = (++count).toString();
    event.id = fastEventHash(event);
    if (getPow(event.id) >= difficulty) {
      break;
    }
  }
  return event;
}
function fastEventHash(evt) {
  return bytesToHex5(
    sha2567(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))
  );
}
var nip17_exports = {};
__export2(nip17_exports, {
  unwrapEvent: () => unwrapEvent2,
  unwrapManyEvents: () => unwrapManyEvents2,
  wrapEvent: () => wrapEvent2,
  wrapManyEvents: () => wrapManyEvents2
});
var nip59_exports = {};
__export2(nip59_exports, {
  createRumor: () => createRumor,
  createSeal: () => createSeal,
  createWrap: () => createWrap,
  unwrapEvent: () => unwrapEvent,
  unwrapManyEvents: () => unwrapManyEvents,
  wrapEvent: () => wrapEvent,
  wrapManyEvents: () => wrapManyEvents
});
var nip44_exports = {};
__export2(nip44_exports, {
  decrypt: () => decrypt22,
  encrypt: () => encrypt22,
  getConversationKey: () => getConversationKey,
  v2: () => v2
});
var minPlaintextSize = 1;
var maxPlaintextSize = 65535;
function getConversationKey(privkeyA, pubkeyB) {
  const sharedX = secp256k12.getSharedSecret(privkeyA, "02" + pubkeyB).subarray(1, 33);
  return extract(sha2567, sharedX, "nip44-v2");
}
function getMessageKeys(conversationKey, nonce2) {
  const keys = expand(sha2567, conversationKey, nonce2, 76);
  return {
    chacha_key: keys.subarray(0, 32),
    chacha_nonce: keys.subarray(32, 44),
    hmac_key: keys.subarray(44, 76)
  };
}
function calcPaddedLen(len) {
  if (!Number.isSafeInteger(len) || len < 1)
    throw new Error("expected positive integer");
  if (len <= 32)
    return 32;
  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
  const chunk = nextPower <= 256 ? 32 : nextPower / 8;
  return chunk * (Math.floor((len - 1) / chunk) + 1);
}
function writeU16BE(num) {
  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)
    throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
  const arr = new Uint8Array(2);
  new DataView(arr.buffer).setUint16(0, num, false);
  return arr;
}
function pad3(plaintext) {
  const unpadded = utf8Encoder.encode(plaintext);
  const unpaddedLen = unpadded.length;
  const prefix = writeU16BE(unpaddedLen);
  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);
  return concatBytes4(prefix, unpadded, suffix);
}
function unpad(padded) {
  const unpaddedLen = new DataView(padded.buffer).getUint16(0);
  const unpadded = padded.subarray(2, 2 + unpaddedLen);
  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))
    throw new Error("invalid padding");
  return utf8Decoder.decode(unpadded);
}
function hmacAad(key, message, aad) {
  if (aad.length !== 32)
    throw new Error("AAD associated data must be 32 bytes");
  const combined = concatBytes4(aad, message);
  return hmac3(sha2567, key, combined);
}
function decodePayload(payload) {
  if (typeof payload !== "string")
    throw new Error("payload must be a valid string");
  const plen = payload.length;
  if (plen < 132 || plen > 87472)
    throw new Error("invalid payload length: " + plen);
  if (payload[0] === "#")
    throw new Error("unknown encryption version");
  let data;
  try {
    data = base643.decode(payload);
  } catch (error) {
    throw new Error("invalid base64: " + error.message);
  }
  const dlen = data.length;
  if (dlen < 99 || dlen > 65603)
    throw new Error("invalid data length: " + dlen);
  const vers = data[0];
  if (vers !== 2)
    throw new Error("unknown encryption version " + vers);
  return {
    nonce: data.subarray(1, 33),
    ciphertext: data.subarray(33, -32),
    mac: data.subarray(-32)
  };
}
function encrypt22(plaintext, conversationKey, nonce2 = randomBytes4(32)) {
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce2);
  const padded = pad3(plaintext);
  const ciphertext = chacha202(chacha_key, chacha_nonce, padded);
  const mac = hmacAad(hmac_key, ciphertext, nonce2);
  return base643.encode(concatBytes4(new Uint8Array([2]), nonce2, ciphertext, mac));
}
function decrypt22(payload, conversationKey) {
  const { nonce: nonce2, ciphertext, mac } = decodePayload(payload);
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce2);
  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce2);
  if (!equalBytes4(calculatedMac, mac))
    throw new Error("invalid MAC");
  const padded = chacha202(chacha_key, chacha_nonce, ciphertext);
  return unpad(padded);
}
var v2 = {
  utils: {
    getConversationKey,
    calcPaddedLen
  },
  encrypt: encrypt22,
  decrypt: decrypt22
};
var TWO_DAYS = 2 * 24 * 60 * 60;
var now = () => Math.round(Date.now() / 1e3);
var randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);
var nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);
var nip44Encrypt = (data, privateKey, publicKey) => encrypt22(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));
var nip44Decrypt = (data, privateKey) => JSON.parse(decrypt22(data.content, nip44ConversationKey(privateKey, data.pubkey)));
function createRumor(event, privateKey) {
  const rumor = {
    created_at: now(),
    content: "",
    tags: [],
    ...event,
    pubkey: getPublicKey(privateKey)
  };
  rumor.id = getEventHash(rumor);
  return rumor;
}
function createSeal(rumor, privateKey, recipientPublicKey) {
  return finalizeEvent(
    {
      kind: Seal,
      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),
      created_at: randomNow(),
      tags: []
    },
    privateKey
  );
}
function createWrap(seal, recipientPublicKey) {
  const randomKey = generateSecretKey();
  return finalizeEvent(
    {
      kind: GiftWrap,
      content: nip44Encrypt(seal, randomKey, recipientPublicKey),
      created_at: randomNow(),
      tags: [["p", recipientPublicKey]]
    },
    randomKey
  );
}
function wrapEvent(event, senderPrivateKey, recipientPublicKey) {
  const rumor = createRumor(event, senderPrivateKey);
  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);
  return createWrap(seal, recipientPublicKey);
}
function wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {
  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {
    throw new Error("At least one recipient is required.");
  }
  const senderPublicKey = getPublicKey(senderPrivateKey);
  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];
  recipientsPublicKeys.forEach((recipientPublicKey) => {
    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));
  });
  return wrappeds;
}
function unwrapEvent(wrap, recipientPrivateKey) {
  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);
  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);
}
function unwrapManyEvents(wrappedEvents, recipientPrivateKey) {
  let unwrappedEvents = [];
  wrappedEvents.forEach((e) => {
    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));
  });
  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);
  return unwrappedEvents;
}
function createEvent(recipients, message, conversationTitle, replyTo) {
  const baseEvent = {
    created_at: Math.ceil(Date.now() / 1e3),
    kind: PrivateDirectMessage,
    tags: [],
    content: message
  };
  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];
  recipientsArray.forEach(({ publicKey, relayUrl }) => {
    baseEvent.tags.push(relayUrl ? ["p", publicKey, relayUrl] : ["p", publicKey]);
  });
  if (replyTo) {
    baseEvent.tags.push(["e", replyTo.eventId, replyTo.relayUrl || "", "reply"]);
  }
  if (conversationTitle) {
    baseEvent.tags.push(["subject", conversationTitle]);
  }
  return baseEvent;
}
function wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {
  const event = createEvent(recipient, message, conversationTitle, replyTo);
  return wrapEvent(event, senderPrivateKey, recipient.publicKey);
}
function wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required.");
  }
  const senderPublicKey = getPublicKey(senderPrivateKey);
  return [{ publicKey: senderPublicKey }, ...recipients].map(
    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)
  );
}
var unwrapEvent2 = unwrapEvent;
var unwrapManyEvents2 = unwrapManyEvents;
var nip18_exports = {};
__export2(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(t, reposted, relayUrl, privateKey) {
  let kind;
  const tags = [...t.tags ?? [], ["e", reposted.id, relayUrl], ["p", reposted.pubkey]];
  if (reposted.kind === ShortTextNote) {
    kind = Repost;
  } else {
    kind = GenericRepost;
    tags.push(["k", String(reposted.kind)]);
  }
  return finalizeEvent(
    {
      kind,
      tags,
      content: t.content === "" || reposted.tags?.find((tag) => tag[0] === "-") ? "" : JSON.stringify(reposted),
      created_at: t.created_at
    },
    privateKey
  );
}
function getRepostedEventPointer(event) {
  if (![Repost, GenericRepost].includes(event.kind)) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
    const tag = event.tags[i2];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === "string"),
    author: lastPTag?.[1]
  };
}
function getRepostedEvent(event, { skipVerification } = {}) {
  const pointer = getRepostedEventPointer(event);
  if (pointer === void 0 || event.content === "") {
    return void 0;
  }
  let repostedEvent;
  try {
    repostedEvent = JSON.parse(event.content);
  } catch (error) {
    return void 0;
  }
  if (repostedEvent.id !== pointer.id) {
    return void 0;
  }
  if (!skipVerification && !verifyEvent(repostedEvent)) {
    return void 0;
  }
  return repostedEvent;
}
var nip21_exports = {};
__export2(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse22,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(value) {
  return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
}
function parse22(uri2) {
  const match2 = uri2.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!match2)
    throw new Error(`Invalid Nostr URI: ${uri2}`);
  return {
    uri: match2[0],
    value: match2[1],
    decoded: decode16(match2[1])
  };
}
var nip25_exports = {};
__export2(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(t, reacted, privateKey) {
  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p"));
  return finalizeEvent(
    {
      ...t,
      kind: Reaction,
      tags: [...t.tags ?? [], ...inheritedTags, ["e", reacted.id], ["p", reacted.pubkey]],
      content: t.content ?? "+"
    },
    privateKey
  );
}
function getReactedEventPointer(event) {
  if (event.kind !== Reaction) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
    const tag = event.tags[i2];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0 || lastPTag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),
    author: lastPTag[1]
  };
}
var nip27_exports = {};
__export2(nip27_exports, {
  parse: () => parse3
});
var noCharacter = /\W/m;
var noURLCharacter = /\W |\W$|$|,| /m;
function* parse3(content) {
  const max = content.length;
  let prevIndex = 0;
  let index = 0;
  while (index < max) {
    let u = content.indexOf(":", index);
    if (u === -1) {
      break;
    }
    if (content.substring(u - 5, u) === "nostr") {
      const m = content.substring(u + 60).match(noCharacter);
      const end = m ? u + 60 + m.index : max;
      try {
        let pointer;
        let { data, type } = decode16(content.substring(u + 1, end));
        switch (type) {
          case "npub":
            pointer = { pubkey: data };
            break;
          case "nsec":
          case "note":
            index = end + 1;
            continue;
          default:
            pointer = data;
        }
        if (prevIndex !== u - 5) {
          yield { type: "text", text: content.substring(prevIndex, u - 5) };
        }
        yield { type: "reference", pointer };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = u + 1;
        continue;
      }
    } else if (content.substring(u - 5, u) === "https" || content.substring(u - 4, u) === "http") {
      const m = content.substring(u + 4).match(noURLCharacter);
      const end = m ? u + 4 + m.index : max;
      const prefixLen = content[u - 1] === "s" ? 5 : 4;
      try {
        let url = new URL(content.substring(u - prefixLen, end));
        if (url.hostname.indexOf(".") === -1) {
          throw new Error("invalid url");
        }
        if (prevIndex !== u - prefixLen) {
          yield { type: "text", text: content.substring(prevIndex, u - prefixLen) };
        }
        if (url.pathname.endsWith(".png") || url.pathname.endsWith(".jpg") || url.pathname.endsWith(".jpeg") || url.pathname.endsWith(".gif") || url.pathname.endsWith(".webp")) {
          yield { type: "image", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        if (url.pathname.endsWith(".mp4") || url.pathname.endsWith(".avi") || url.pathname.endsWith(".webm") || url.pathname.endsWith(".mkv")) {
          yield { type: "video", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        if (url.pathname.endsWith(".mp3") || url.pathname.endsWith(".aac") || url.pathname.endsWith(".ogg") || url.pathname.endsWith(".opus")) {
          yield { type: "audio", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        yield { type: "url", url: url.toString() };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = end + 1;
        continue;
      }
    } else if (content.substring(u - 3, u) === "wss" || content.substring(u - 2, u) === "ws") {
      const m = content.substring(u + 4).match(noURLCharacter);
      const end = m ? u + 4 + m.index : max;
      const prefixLen = content[u - 1] === "s" ? 3 : 2;
      try {
        let url = new URL(content.substring(u - prefixLen, end));
        if (url.hostname.indexOf(".") === -1) {
          throw new Error("invalid ws url");
        }
        if (prevIndex !== u - prefixLen) {
          yield { type: "text", text: content.substring(prevIndex, u - prefixLen) };
        }
        yield { type: "relay", url: url.toString() };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = end + 1;
        continue;
      }
    } else {
      index = u + 1;
      continue;
    }
  }
  if (prevIndex !== max) {
    yield { type: "text", text: content.substring(prevIndex) };
  }
}
var nip28_exports = {};
__export2(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMetadataEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", t.channel_create_event_id], ...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMessageEvent = (t, privateKey) => {
  const tags = [["e", t.channel_create_event_id, t.relay_url, "root"]];
  if (t.reply_to_channel_message_event_id) {
    tags.push(["e", t.reply_to_channel_message_event_id, t.relay_url, "reply"]);
  }
  return finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...tags, ...t.tags ?? []],
      content: t.content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelHideMessageEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", t.channel_message_event_id], ...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMuteUserEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", t.pubkey_to_mute], ...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var nip30_exports = {};
__export2(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/;
var regex = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll(content) {
  const matches = content.matchAll(regex());
  for (const match2 of matches) {
    try {
      const [shortcode, name4] = match2;
      yield {
        shortcode,
        name: name4,
        start: match2.index,
        end: match2.index + shortcode.length
      };
    } catch (_e) {
    }
  }
}
function replaceAll(content, replacer) {
  return content.replaceAll(regex(), (shortcode, name4) => {
    return replacer({
      shortcode,
      name: name4
    });
  });
}
var nip39_exports = {};
__export2(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch {
}
function useFetchImplementation3(fetchImplementation) {
  _fetch3 = fetchImplementation;
}
async function validateGithub(pubkey, username, proof) {
  try {
    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();
    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
  } catch (_) {
    return false;
  }
}
var nip47_exports = {};
__export2(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(connectionString) {
  const { pathname, searchParams } = new URL(connectionString);
  const pubkey = pathname;
  const relay = searchParams.get("relay");
  const secret = searchParams.get("secret");
  if (!pubkey || !relay || !secret) {
    throw new Error("invalid connection string");
  }
  return { pubkey, relay, secret };
}
async function makeNwcRequestEvent(pubkey, secretKey, invoice) {
  const content = {
    method: "pay_invoice",
    params: {
      invoice
    }
  };
  const encryptedContent = encrypt2(secretKey, pubkey, JSON.stringify(content));
  const eventTemplate = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: encryptedContent,
    tags: [["p", pubkey]]
  };
  return finalizeEvent(eventTemplate, secretKey);
}
var nip54_exports = {};
__export2(nip54_exports, {
  normalizeIdentifier: () => normalizeIdentifier
});
function normalizeIdentifier(name4) {
  name4 = name4.trim().toLowerCase();
  name4 = name4.normalize("NFKC");
  return Array.from(name4).map((char) => {
    if (/\p{Letter}/u.test(char) || /\p{Number}/u.test(char)) {
      return char;
    }
    return "-";
  }).join("");
}
var nip57_exports = {};
__export2(nip57_exports, {
  getSatoshisAmountFromBolt11: () => getSatoshisAmountFromBolt11,
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch {
}
function useFetchImplementation4(fetchImplementation) {
  _fetch4 = fetchImplementation;
}
async function getZapEndpoint(metadata) {
  try {
    let lnurl = "";
    let { lud06, lud16 } = JSON.parse(metadata.content);
    if (lud06) {
      let { words } = bech322.decode(lud06, 1e3);
      let data = bech322.fromWords(words);
      lnurl = utf8Decoder.decode(data);
    } else if (lud16) {
      let [name4, domain2] = lud16.split("@");
      lnurl = new URL(`/.well-known/lnurlp/${name4}`, `https://${domain2}`).toString();
    } else {
      return null;
    }
    let res = await _fetch4(lnurl);
    let body = await res.json();
    if (body.allowsNostr && body.nostrPubkey) {
      return body.callback;
    }
  } catch (err) {
  }
  return null;
}
function makeZapRequest({
  profile,
  event,
  amount,
  relays,
  comment = ""
}) {
  if (!amount)
    throw new Error("amount not given");
  if (!profile)
    throw new Error("profile not given");
  let zr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: comment,
    tags: [
      ["p", profile],
      ["amount", amount.toString()],
      ["relays", ...relays]
    ]
  };
  if (event && typeof event === "string") {
    zr.tags.push(["e", event]);
  }
  if (event && typeof event === "object") {
    if (isReplaceableKind(event.kind)) {
      const a = ["a", `${event.kind}:${event.pubkey}:`];
      zr.tags.push(a);
    } else if (isAddressableKind(event.kind)) {
      let d = event.tags.find(([t, v]) => t === "d" && v);
      if (!d)
        throw new Error("d tag not found or is empty");
      const a = ["a", `${event.kind}:${event.pubkey}:${d[1]}`];
      zr.tags.push(a);
    }
  }
  return zr;
}
function validateZapRequest(zapRequestString) {
  let zapRequest;
  try {
    zapRequest = JSON.parse(zapRequestString);
  } catch (err) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(zapRequest))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(zapRequest))
    return "Invalid signature on zap request.";
  let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
  if (!p)
    return "Zap request doesn't have a 'p' tag.";
  if (!p[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
  if (e && !e[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'e' tag is not valid hex.";
  let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
  if (!relays)
    return "Zap request doesn't have a 'relays' tag.";
  return null;
}
function makeZapReceipt({
  zapRequest,
  preimage,
  bolt11,
  paidAt
}) {
  let zr = JSON.parse(zapRequest);
  let tagsFromZapRequest = zr.tags.filter(([t]) => t === "e" || t === "p" || t === "a");
  let zap = {
    kind: 9735,
    created_at: Math.round(paidAt.getTime() / 1e3),
    content: "",
    tags: [...tagsFromZapRequest, ["P", zr.pubkey], ["bolt11", bolt11], ["description", zapRequest]]
  };
  if (preimage) {
    zap.tags.push(["preimage", preimage]);
  }
  return zap;
}
function getSatoshisAmountFromBolt11(bolt11) {
  if (bolt11.length < 50) {
    return 0;
  }
  bolt11 = bolt11.substring(0, 50);
  const idx = bolt11.lastIndexOf("1");
  if (idx === -1) {
    return 0;
  }
  const hrp = bolt11.substring(0, idx);
  if (!hrp.startsWith("lnbc")) {
    return 0;
  }
  const amount = hrp.substring(4);
  if (amount.length < 1) {
    return 0;
  }
  const char = amount[amount.length - 1];
  const digit = char.charCodeAt(0) - "0".charCodeAt(0);
  const isDigit = digit >= 0 && digit <= 9;
  let cutPoint = amount.length - 1;
  if (isDigit) {
    cutPoint++;
  }
  if (cutPoint < 1) {
    return 0;
  }
  const num = parseInt(amount.substring(0, cutPoint));
  switch (char) {
    case "m":
      return num * 1e5;
    case "u":
      return num * 100;
    case "n":
      return num / 10;
    case "p":
      return num / 1e4;
    default:
      return num * 1e8;
  }
}
var nip98_exports = {};
__export2(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(loginUrl, httpMethod, sign2, includeAuthorizationScheme = false, payload) {
  const event = {
    kind: HTTPAuth,
    tags: [
      ["u", loginUrl],
      ["method", httpMethod]
    ],
    created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
    content: ""
  };
  if (payload) {
    event.tags.push(["payload", hashPayload(payload)]);
  }
  const signedEvent = await sign2(event);
  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
  return authorizationScheme + base643.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
}
async function validateToken(token, url, method) {
  const event = await unpackEventFromToken(token).catch((error) => {
    throw error;
  });
  const valid = await validateEvent2(event, url, method).catch((error) => {
    throw error;
  });
  return valid;
}
async function unpackEventFromToken(token) {
  if (!token) {
    throw new Error("Missing token");
  }
  token = token.replace(_authorizationScheme, "");
  const eventB64 = utf8Decoder.decode(base643.decode(token));
  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
    throw new Error("Invalid token");
  }
  const event = JSON.parse(eventB64);
  return event;
}
function validateEventTimestamp(event) {
  if (!event.created_at) {
    return false;
  }
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - event.created_at < 60;
}
function validateEventKind(event) {
  return event.kind === HTTPAuth;
}
function validateEventUrlTag(event, url) {
  const urlTag = event.tags.find((t) => t[0] === "u");
  if (!urlTag) {
    return false;
  }
  return urlTag.length > 0 && urlTag[1] === url;
}
function validateEventMethodTag(event, method) {
  const methodTag = event.tags.find((t) => t[0] === "method");
  if (!methodTag) {
    return false;
  }
  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();
}
function hashPayload(payload) {
  const hash3 = sha2567(utf8Encoder.encode(JSON.stringify(payload)));
  return bytesToHex5(hash3);
}
function validateEventPayloadTag(event, payload) {
  const payloadTag = event.tags.find((t) => t[0] === "payload");
  if (!payloadTag) {
    return false;
  }
  const payloadHash = hashPayload(payload);
  return payloadTag.length > 0 && payloadTag[1] === payloadHash;
}
async function validateEvent2(event, url, method, body) {
  if (!verifyEvent(event)) {
    throw new Error("Invalid nostr event, signature invalid");
  }
  if (!validateEventKind(event)) {
    throw new Error("Invalid nostr event, kind invalid");
  }
  if (!validateEventTimestamp(event)) {
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  }
  if (!validateEventUrlTag(event, url)) {
    throw new Error("Invalid nostr event, url tag invalid");
  }
  if (!validateEventMethodTag(event, method)) {
    throw new Error("Invalid nostr event, method tag invalid");
  }
  if (Boolean(body) && typeof body === "object" && Object.keys(body).length > 0) {
    if (!validateEventPayloadTag(event, body)) {
      throw new Error("Invalid nostr event, payload tag does not match request body hash");
    }
  }
  return true;
}

// src/witness/witness_nostr.ts
var WitnessNostr = class {
  constructor() {
    /**
    * Waits for an event from a specific author on a Nostr relay
    * 
    * @param relay - Connected Nostr relay instance
    * @param pk - Public key of the author to watch
    * @returns Promise resolving to the received Nostr event
    * 
    * This method:
    * - Subscribes to kind 1 events from specific author
    * - Returns first matching event received
    */
    this.waitForEventAuthor = async (relay, pk) => {
      return new Promise((resolve) => {
        relay.subscribe([
          {
            kinds: [1],
            authors: [pk]
          }
        ], {
          onevent(event) {
            resolve(event);
          }
        });
      });
    };
    /**
    * Waits for a specific event by ID on a Nostr relay
    * 
    * @param relay - Connected Nostr relay instance
    * @param id - Event ID to watch for
    * @returns Promise resolving to the received Nostr event
    * 
    * This method:
    * - Subscribes to events with specific ID
    * - Returns first matching event received
    */
    this.waitForEventId = async (relay, id) => {
      return new Promise((resolve) => {
        relay.subscribe([
          {
            ids: [id]
          }
        ], {
          onevent(event) {
            resolve(event);
          }
        });
      });
    };
    /**
    * Creates a witness event on Nostr network
    * 
    * @param witnessEventVerificationHash - Hash to be witnessed
    * @param credentials - Credentials containing Nostr secret key
    * @returns Promise resolving to [nevent, npub, timestamp]
    * 
    * This method:
    * - Validates Nostr credentials
    * - Creates and signs Nostr event
    * - Publishes event to relay
    * - Returns event details and timestamp
    * 
    * Uses damus.io relay and supports both browser and Node.js
    * environments with appropriate WebSocket handling.
    */
    this.witness = async (witnessEventVerificationHash, credentials) => {
      const skHex = credentials.nostr_sk;
      const relayUrl = "wss://relay.damus.io";
      if (!skHex) {
        throw new Error("Nostr SK key is required. Please get an API key from https://snort.social/login/sign-up");
      }
      const sk = hexToBytes(skHex);
      const pk = getPublicKey(sk);
      const npub = nip19_exports.npubEncode(pk);
      console.log("npub: ", npub);
      console.log("Witness event verification hash: ", witnessEventVerificationHash);
      console.log(`https://snort.social/${npub}`);
      const eventTemplate = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1e3),
        tags: [],
        content: witnessEventVerificationHash
      };
      const event = finalizeEvent(eventTemplate, sk);
      const isNode2 = typeof window === "undefined";
      let websocket;
      if (isNode2) {
        websocket = wrapper_default;
        global.WebSocket = websocket;
      }
      console.log("Is node: ", isNode2);
      const relay = await Relay.connect(relayUrl);
      console.log(`connected to ${relay.url}`);
      await relay.publish(event);
      const publishEvent = await this.waitForEventAuthor(relay, pk);
      relay.close();
      const nevent = nip19_exports.neventEncode({
        id: publishEvent.id,
        relays: [relay.url],
        author: publishEvent.pubkey
      });
      const witnessTimestamp = publishEvent.created_at;
      console.log(`got event https://snort.social/${nevent}`);
      return [nevent, npub, witnessTimestamp];
    };
    /**
    * Verifies a Nostr witness event
    * 
    * @param transactionHash - Nostr event identifier (nevent)
    * @param expectedMR - Expected Merkle root
    * @param expectedTimestamp - Expected event timestamp
    * @returns Promise resolving to boolean indicating verification success
    * 
    * This method:
    * - Decodes Nostr event identifier
    * - Retrieves event from relay
    * - Verifies timestamp and content match
    * - Supports both browser and Node.js environments
    */
    this.verify = async (transactionHash, expectedMR, expectedTimestamp) => {
      const decoded = nip19_exports.decode(transactionHash);
      const relayUrl = "wss://relay.damus.io";
      if (decoded.type !== "nevent") {
        return false;
      }
      const isNode2 = typeof window === "undefined";
      let websocket;
      if (isNode2) {
        websocket = wrapper_default;
        global.WebSocket = websocket;
      }
      console.log("Is node: ", isNode2);
      const relay = await Relay.connect(relayUrl);
      const publishEvent = await this.waitForEventId(relay, decoded.data.id);
      relay.close();
      if (expectedTimestamp !== publishEvent.created_at) {
        return false;
      }
      const merkleRoot = publishEvent.content;
      return merkleRoot === expectedMR;
    };
  }
};

// src/core/witness.ts
async function witnessAquaTreeUtil(aquaTreeView, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar = false) {
  let logs = [];
  let lastRevisionHash = "";
  if (aquaTreeView.revision == void 0 || aquaTreeView.revision == null || aquaTreeView.revision.length == 0) {
    const verificationHashes = Object.keys(aquaTreeView.aquaTree.revisions);
    lastRevisionHash = verificationHashes[verificationHashes.length - 1];
  } else {
    lastRevisionHash = aquaTreeView.revision;
  }
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const timestamp = formatMwTimestamp(now2.slice(0, now2.indexOf(".")));
  const revisionType = "witness";
  let verificationDataBasic = {
    previous_verification_hash: lastRevisionHash,
    local_timestamp: timestamp,
    revision_type: revisionType
  };
  verificationDataBasic["version"] = `https://aqua-protocol.org/docs/v3/schema_2 | SHA256 | Method: ${enableScalar ? "scalar" : "tree"}`;
  const revisionResultData = await prepareWitness(lastRevisionHash, witnessType, witnessPlatform, credentials, witnessNetwork);
  if (isErr(revisionResultData)) {
    revisionResultData.data.forEach((e) => logs.push(e));
    return Err(logs);
  }
  let witness = revisionResultData.data;
  let verificationDataRaw = { ...verificationDataBasic, ...witness };
  let verificationData = reorderRevisionsProperties(verificationDataRaw);
  const leaves = dict2Leaves(verificationData);
  let verification_hash = "";
  if (enableScalar) {
    verification_hash = "0x" + getHashSum(JSON.stringify(verificationData));
  } else {
    verification_hash = getMerkleRoot(leaves);
    verificationData.leaves = leaves;
  }
  const revisions = aquaTreeView.aquaTree.revisions;
  revisions[verification_hash] = verificationData;
  let aquaTreeWithTree = createAquaTree(aquaTreeView.aquaTree);
  if (!aquaTreeWithTree) {
    logs.push({
      log: `Failed to create AquaTree`,
      logType: "error" /* ERROR */
    });
    return Err(logs);
  }
  logs.push({
    log: `AquaTree witnessed succesfully`,
    logType: "success" /* SUCCESS */
  });
  let result = {
    aquaTree: aquaTreeWithTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(result);
}
async function witnessMultipleAquaTreesUtil(aquaTrees, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar = false) {
  let logs = [];
  let lastRevisionOrSpecifiedHashes = [];
  for (let item of aquaTrees) {
    if (item.revision != null && item.revision != void 0 && item.revision.length > 0) {
      lastRevisionOrSpecifiedHashes.push(item.revision);
    } else {
      const verificationHashes = Object.keys(item.aquaTree.revisions);
      lastRevisionOrSpecifiedHashes.push(verificationHashes[verificationHashes.length - 1]);
    }
  }
  let merkleRoot = getMerkleRoot(lastRevisionOrSpecifiedHashes);
  let revisionResultData = await prepareWitness(merkleRoot, witnessType, witnessPlatform, credentials, witnessNetwork);
  if (isErr(revisionResultData)) {
    revisionResultData.data.forEach((e) => logs.push(e));
    return Err(logs);
  }
  let revisionResult = revisionResultData.data;
  revisionResult.witness_merkle_proof = lastRevisionOrSpecifiedHashes;
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const timestamp = formatMwTimestamp(now2.slice(0, now2.indexOf(".")));
  const revisionType = "witness";
  let aquaTreesResult = [];
  let hasError = false;
  for (let item of aquaTrees) {
    let latestOrSpecifiedRevisionKey = "";
    if (item.revision != null && item.revision != void 0 && item.revision.length > 0) {
      latestOrSpecifiedRevisionKey = item.revision;
    } else {
      const verificationHashes = Object.keys(item.aquaTree.revisions);
      latestOrSpecifiedRevisionKey = verificationHashes[verificationHashes.length - 1];
    }
    let verificationData = {
      previous_verification_hash: latestOrSpecifiedRevisionKey,
      local_timestamp: timestamp,
      revision_type: revisionType,
      ...revisionResult
    };
    const revisions = item.aquaTree.revisions;
    const leaves = dict2Leaves(verificationData);
    if (!enableScalar) {
      verificationData.leaves = leaves;
    }
    const verificationHash = getMerkleRoot(leaves);
    revisions[verificationHash] = verificationData;
    item.aquaTree.revisions = revisions;
    let aquaTreeUpdatedData = createAquaTree(item.aquaTree);
    let aquaTreeUpdated = reorderAquaTreeRevisionsProperties(aquaTreeUpdatedData);
    if (aquaTreeUpdated) {
      aquaTreesResult.push(aquaTreeUpdated);
    }
  }
  if (hasError) {
    return Err(logs);
  }
  logs.push({
    log: `All aquaTrees witnessed succesfully`,
    logType: "success" /* SUCCESS */
  });
  let resutData = {
    aquaTree: null,
    logData: logs,
    aquaTrees: aquaTreesResult
  };
  return Ok(resutData);
}
function getWitnessNetwork(witnessType, witnessNetwork) {
  let witness_network = witnessNetwork;
  switch (witnessType) {
    case "nostr": {
      witness_network = "nostr";
      break;
    }
    case "tsa": {
      witness_network = "TSA_RFC3161";
      break;
    }
  }
  return witness_network;
}
var prepareWitness = async (verificationHash, witnessType, WitnessPlatformType3, credentials, witness_network = "sepolia") => {
  let logs = [];
  const merkle_root = verificationHash;
  let smart_contract_address, transactionHash, publisher, witnessTimestamp;
  switch (witnessType) {
    case "nostr": {
      let witnessNostr = new WitnessNostr();
      [transactionHash, publisher, witnessTimestamp] = await witnessNostr.witness(merkle_root, credentials);
      smart_contract_address = "N/A";
      break;
    }
    case "tsa": {
      const tsaUrl = "http://timestamp.digicert.com";
      let witnessTsa = new WitnessTSA();
      [transactionHash, publisher, witnessTimestamp] = await witnessTsa.witness(merkle_root, tsaUrl);
      smart_contract_address = tsaUrl;
      break;
    }
    case "eth": {
      smart_contract_address = "0x45f59310ADD88E6d23ca58A0Fa7A55BEE6d2a611";
      let network2 = "sepolia";
      if (witness_network == "holesky") {
        network2 = "holesky";
      } else if (witness_network == "mainnet") {
        network2 = "mainnet";
      }
      if (WitnessPlatformType3 === "cli") {
        if (credentials.alchemy_key == null || credentials.alchemy_key == void 0 || credentials.alchemy_key == "") {
          logs.push({
            log: `Alchemy key is missing`,
            logType: "debug_data" /* DEBUGDATA */
          });
          return Err(logs);
        }
        let alchemyProvider = `https://eth-${witness_network}.g.alchemy.com/v2/${credentials.alchemy_key}`;
        const maskedAlchemyUrl = alchemyProvider.replace(/(\/v2\/)([a-zA-Z0-9]+)/, "/v2/****");
        logs.push({
          log: `Using Alchemy provider: ${maskedAlchemyUrl}`,
          logType: "debug_data" /* DEBUGDATA */
        });
        if (credentials == null || credentials == void 0) {
          logs.push({
            log: `credentials not found`,
            logType: "error" /* ERROR */
          });
          return Err(logs);
        }
        let [_wallet, walletAddress, _publicKey] = await getWallet(credentials.mnemonic);
        logs.push({
          log: `Wallet address: ${_wallet}`,
          logType: "signature" /* SIGNATURE */
        });
        const [gasEstimateResult, logData] = await estimateWitnessGas(
          walletAddress,
          merkle_root,
          witness_network,
          smart_contract_address,
          alchemyProvider
        );
        logs.push(...logData);
        logs.push({
          log: `Gas estimate result: : ${gasEstimateResult}`,
          logType: "debug_data" /* DEBUGDATA */
        });
        if (gasEstimateResult.error !== null) {
          logs.push({
            log: `Unable to Estimate gas fee: ${gasEstimateResult.error}`,
            logType: "debug_data" /* DEBUGDATA */
          });
          return Err(logs);
        }
        if (!gasEstimateResult.hasEnoughBalance) {
          logs.push({
            log: `\u{1F537} You do not have enough balance to cater for gas fees : ${gasEstimateResult}`,
            logType: "debug_data" /* DEBUGDATA */
          });
          logs.push({
            log: `Add some faucets to this wallet address: ${walletAddress}
`,
            logType: "debug_data" /* DEBUGDATA */
          });
          return Err(logs);
        }
        let transactionResult = null;
        try {
          let [transactionResultData, resultLogData] = await WitnessEth.witnessCli(
            _wallet.privateKey,
            verificationHash,
            smart_contract_address,
            network2,
            alchemyProvider,
            credentials.alchemy_key
          );
          transactionResult = transactionResultData;
          logs.push(...resultLogData);
          logs.push({
            logType: "witness" /* WITNESS */,
            log: "cli witness result: \n" + JSON.stringify(transactionResult)
          });
        } catch (e) {
          logs.push({
            logType: "error" /* ERROR */,
            log: "An error witnessing using etherium "
          });
          return Err(logs);
        }
        if (transactionResult == null || transactionResult.error != null || !transactionResult.transactionHash) {
          logs.push({
            logType: "error" /* ERROR */,
            log: "An error witnessing using etherium (empty object or missing transaction hash)"
          });
          return Err(logs);
        }
        transactionHash = transactionResult.transactionHash;
        publisher = walletAddress;
      } else {
        let config = {
          smartContractAddress: smart_contract_address,
          witnessEventVerificationHash: merkle_root,
          witnessNetwork: network2
        };
        let witnessResult = await WitnessEth.witnessMetamask(
          config
        );
        transactionHash = witnessResult.transaction_hash;
        publisher = witnessResult.wallet_address;
      }
      witnessTimestamp = Math.floor(Date.now() / 1e3);
      break;
    }
    default: {
      console.error(`Unknown witness method: ${witnessType}`);
      return Err(logs);
    }
  }
  const witness = {
    witness_merkle_root: merkle_root,
    witness_timestamp: witnessTimestamp,
    witness_network: getWitnessNetwork(witnessType, witness_network),
    witness_smart_contract_address: smart_contract_address,
    witness_transaction_hash: transactionHash,
    witness_sender_account_address: publisher,
    witness_merkle_proof: [verificationHash]
  };
  return Ok(witness);
};
async function verifyWitness(witnessData, verificationHash, doVerifyMerkleProof, indentCharacter, credentials) {
  let logs = [];
  let isValid2 = false;
  const hasInternet = await checkInternetConnection();
  if (!hasInternet) {
    logs.push({
      log: `No internet connection available. Witness verification requires internet access.`,
      logType: "error" /* ERROR */,
      ident: indentCharacter
    });
    return [false, logs];
  }
  if (verificationHash === "") {
    logs.push({
      log: `The verification Hash MUST NOT be empty`,
      logType: "error" /* ERROR */,
      ident: indentCharacter
    });
    return [isValid2, logs];
  }
  if (witnessData.witness_network === "nostr") {
    let witnessNostr = new WitnessNostr();
    isValid2 = await witnessNostr.verify(
      witnessData.witness_transaction_hash,
      witnessData.witness_merkle_root,
      witnessData.witness_timestamp
    );
  } else if (witnessData.witness_network === "TSA_RFC3161") {
    let witnessTsa = new WitnessTSA();
    isValid2 = await witnessTsa.verify(
      witnessData.witness_transaction_hash,
      witnessData.witness_merkle_root,
      witnessData.witness_timestamp
    );
  } else {
    let logMessage = "";
    let alchemyProvider = null;
    let alchemyKey = null;
    if (credentials) {
      alchemyProvider = `https://eth-${witnessData.witness_network}.g.alchemy.com/v2/${credentials.alchemy_key}`;
      alchemyKey = credentials.alchemy_key;
    }
    ;
    [isValid2, logMessage] = await WitnessEth.verify(
      witnessData.witness_network,
      witnessData.witness_transaction_hash,
      witnessData.witness_merkle_root,
      witnessData.witness_timestamp,
      alchemyProvider,
      alchemyKey
    );
    logs.push({
      log: logMessage,
      logType: isValid2 ? "success" /* SUCCESS */ : "error" /* ERROR */,
      ident: indentCharacter
    });
  }
  if (doVerifyMerkleProof) {
    logs.push({
      log: `verifying merkle integrity`,
      logType: "info" /* INFO */,
      ident: indentCharacter
    });
    isValid2 = verifyMerkleIntegrity(
      // JSON.parse(witnessData.witness_merkle_proof),
      // verification_hash,
      witnessData.witness_merkle_proof ? witnessData.witness_merkle_proof : [],
      witnessData.witness_merkle_root
    );
    logs.push({
      log: `Merkle integrity is ${isValid2 ? "" : "NOT"} valid `,
      logType: isValid2 ? "success" /* SUCCESS */ : "error" /* ERROR */,
      ident: indentCharacter
    });
  }
  return [isValid2, logs];
}

// src/core/verify.ts
async function verifyAquaTreeRevisionUtil(aquaTree, revision, revisionItemHash, fileObject, credentials) {
  let logs = [];
  const isScalar = !revision.hasOwnProperty("leaves");
  let result = await verifyRevision(
    aquaTree,
    revision,
    revisionItemHash,
    fileObject,
    isScalar,
    "",
    credentials
  );
  result[1].forEach((e) => logs.push(e));
  if (result[0] == false) {
    return Err(logs);
  }
  let data = {
    aquaTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(data);
}
async function verifyAquaTreeUtil(aquaTree, fileObject, identCharacter = "", credentials) {
  let logs = [];
  let verificationHashes = Object.keys(aquaTree.revisions);
  let isSuccess = true;
  for (let revisionItemHash of verificationHashes) {
    let revision = aquaTree.revisions[revisionItemHash];
    let revisionIndex = verificationHashes.indexOf(revisionItemHash);
    logs.push({
      logType: "arrow" /* ARROW */,
      log: ` ${revisionIndex + 1}.Verifying Revision: ${revisionItemHash}`,
      ident: identCharacter
    });
    switch (revision.revision_type) {
      case "form":
        logs.push({
          logType: "form" /* FORM */,
          log: "Type: Form.",
          ident: `${identCharacter}	`
        });
        break;
      case "file":
        logs.push({
          logType: "file" /* FILE */,
          log: "Type: File.",
          ident: `${identCharacter}	`
        });
        break;
      case "signature":
        if (revision.signature_type)
          logs.push({
            logType: "signature" /* SIGNATURE */,
            log: `Type: Signature ${revision.signature_type}`,
            ident: `${identCharacter}	`
          });
        break;
      case "witness":
        logs.push({
          logType: "witness" /* WITNESS */,
          log: `Type: Witness ${revision.witness_network}`,
          ident: `${identCharacter}	`
        });
        break;
      case "link":
        logs.push({
          logType: "link" /* LINK */,
          log: "Type: Link.",
          ident: `${identCharacter}	`
        });
        break;
      default:
        logs.push({
          logType: "warning" /* WARNING */,
          log: `Type: Unknown ${revision.revision_type}.
`,
          ident: `${identCharacter}	`
        });
    }
    const isScalar = !revision.hasOwnProperty("leaves");
    let result = await verifyRevision(
      aquaTree,
      revision,
      revisionItemHash,
      fileObject,
      isScalar,
      identCharacter,
      credentials
    );
    if (result[1].length > 0) {
      logs.push(...result[1]);
    }
    if (!result[0]) {
      isSuccess = false;
    }
  }
  if (!isSuccess) {
    return Err(logs);
  }
  let data = {
    aquaTree,
    aquaTrees: [],
    logData: logs
  };
  return Ok(data);
}
function findNode2(tree2, hash3) {
  if (tree2.hash === hash3) {
    return tree2;
  }
  for (let i2 = 0; i2 < tree2.verificationGraphData.length; i2++) {
    const child = tree2.verificationGraphData[i2];
    const result = findNode2(child, hash3);
    if (result) {
      return result;
    }
  }
  return null;
}
async function verifyAndGetGraphDataRevisionUtil(aquaTree, revision, revisionItemHash, fileObject, credentials) {
  const logs = [];
  const isScalar = !revision.hasOwnProperty("leaves");
  let [isGenesisOkay, genesisLogData] = await verifyRevision(
    aquaTree,
    revision,
    revisionItemHash,
    fileObject,
    isScalar,
    "",
    credentials
  );
  genesisLogData.forEach((e) => logs.push(e));
  if (!isGenesisOkay) {
    Err(logs);
  }
  const genesisRevisionType = revision.revision_type;
  const fileGraphData = {
    isValidationSucessful: isGenesisOkay
  };
  const verificationResults = {
    hash: revisionItemHash,
    previous_verification_hash: getPreviousVerificationHash(
      aquaTree,
      revisionItemHash
    ),
    timestamp: revision.local_timestamp,
    isValidationSucessful: isGenesisOkay,
    revisionType: genesisRevisionType,
    verificationGraphData: [],
    linkVerificationGraphData: [],
    info: fileGraphData
  };
  return Ok(verificationResults);
}
async function verifyAndGetGraphDataUtil(_aquaTree, fileObject, identCharacter = "", credentials) {
  const aquaTree = OrderRevisionInAquaTree(_aquaTree);
  let verificationHashes = Object.keys(aquaTree.revisions);
  const logs = [];
  if (verificationHashes.length === 0) {
    logs.push({
      logType: "error" /* ERROR */,
      log: "Revisions should be greater than 0"
    });
    return Err(logs);
  }
  let genesisRevisionData = aquaTree.revisions[verificationHashes[0]];
  let infoGraphData = null;
  const isScalar = !genesisRevisionData.hasOwnProperty("leaves");
  let [isGenesisOkay, _genesisVerificationLogs] = await verifyRevision(
    aquaTree,
    genesisRevisionData,
    verificationHashes[0],
    fileObject,
    isScalar,
    identCharacter,
    credentials
  );
  const genesisRevisionType = aquaTree.revisions[verificationHashes[0]].revision_type;
  if (genesisRevisionData.revision_type === "form") {
    if (genesisRevisionData.leaves == void 0) {
      logs.push({
        logType: "error" /* ERROR */,
        log: `Leaves are required in a form revision.
`,
        ident: `${identCharacter}	`
      });
      return Err(logs);
    }
    let { formKeysGraphData } = verifyFormRevision(
      genesisRevisionData,
      genesisRevisionData.leaves
    );
    let formData = {
      formKeys: formKeysGraphData
    };
    infoGraphData = formData;
  } else {
    const fileGraphData = {
      isValidationSucessful: isGenesisOkay
    };
    infoGraphData = fileGraphData;
  }
  const verificationResults = {
    hash: verificationHashes[0],
    previous_verification_hash: genesisRevisionData.previous_verification_hash,
    timestamp: genesisRevisionData.local_timestamp,
    isValidationSucessful: isGenesisOkay,
    revisionType: genesisRevisionType,
    verificationGraphData: [],
    linkVerificationGraphData: [],
    info: infoGraphData
  };
  if (verificationHashes.length === 1) {
    return Ok(verificationResults);
  }
  let isSuccess = true;
  for (let revisionItemHash of verificationHashes.slice(1)) {
    let revision = aquaTree.revisions[revisionItemHash];
    let revisionIndex = verificationHashes.indexOf(revisionItemHash);
    logs.push({
      logType: "arrow" /* ARROW */,
      log: ` ${revisionIndex + 1}.Verifying Revision: ${revisionItemHash}`,
      ident: identCharacter
    });
    switch (revision.revision_type) {
      case "form":
        logs.push({
          logType: "form" /* FORM */,
          log: "Type:Form.",
          ident: `${identCharacter}	`
        });
        break;
      case "file":
        logs.push({
          logType: "file" /* FILE */,
          log: "Type: File.",
          ident: `${identCharacter}	`
        });
        break;
      case "signature":
        if (revision.signature_type)
          logs.push({
            logType: "signature" /* SIGNATURE */,
            log: `Type:Signature ${revision.signature_type}`,
            ident: `${identCharacter}	`
          });
        break;
      case "witness":
        logs.push({
          logType: "witness" /* WITNESS */,
          log: "Type:Witness.",
          ident: `${identCharacter}	`
        });
        break;
      case "link":
        logs.push({
          logType: "link" /* LINK */,
          log: "Type:Link.",
          ident: `${identCharacter}	`
        });
        break;
      default:
        logs.push({
          logType: "warning" /* WARNING */,
          log: `Type:Unknown ${revision.revision_type}.
`,
          ident: `${identCharacter}	`
        });
    }
    const isScalar2 = !revision.hasOwnProperty("leaves");
    let result = await verifyRevision(
      aquaTree,
      revision,
      revisionItemHash,
      fileObject,
      isScalar2,
      identCharacter,
      credentials
    );
    let verificationResultsNode = findNode2(
      verificationResults,
      revision.previous_verification_hash
    );
    if (verificationResultsNode === null) {
      logs.push({
        logType: "error" /* ERROR */,
        log: `A detached chain detected. Cannot find previous verification hash: ${revision.previous_verification_hash}`
      });
      isSuccess = false;
      break;
    }
    let linkedVerificationGraphData = [];
    if (revision.revision_type === "link") {
      let aqtreeFilename = aquaTree.file_index[revision.link_verification_hashes[0]];
      let name4 = `${aqtreeFilename}.aqua.json`;
      let linkedFileObject = getFileNameCheckingPaths(fileObject, name4);
      if (!linkedFileObject) {
        logs.push({
          logType: "error" /* ERROR */,
          log: "Linked aqua tree not found"
        });
        break;
      }
      const linkedAquaTree = OrderRevisionInAquaTree(linkedFileObject.fileContent);
      let result2 = await verifyAndGetGraphDataUtil(
        linkedAquaTree,
        fileObject,
        `${identCharacter}	`,
        credentials
      );
      if (result2.isOk()) {
        linkedVerificationGraphData = [result2.data];
      } else {
        isSuccess = false;
        logs.push({
          logType: "error" /* ERROR */,
          log: "Linked aqua tree failed to create graph data"
        });
        break;
      }
    }
    let data = void 0;
    if (revision.revision_type === "form") {
      let { formKeysGraphData } = verifyFormRevision(revision, revision.leaves);
      let formData = {
        formKeys: formKeysGraphData
      };
      data = formData;
    } else if (revision.revision_type === "file") {
      let formData = {
        isValidationSucessful: result[0]
      };
      data = formData;
    } else if (revision.revision_type === "link") {
      let formData = {
        isValidationSucessful: result[0]
      };
      data = formData;
    } else if (revision.revision_type === "signature") {
      let formData = {
        isValidationSucessful: result[0],
        walletAddress: revision.signature_wallet_address,
        chainHashIsValid: result[0],
        signature: revision.signature,
        signatureType: revision.signature_type
      };
      data = formData;
    } else if (revision.revision_type === "witness") {
      let formData = {
        isValidationSucessful: result[0],
        txHash: revision.witness_transaction_hash,
        merkleRoot: revision.witness_merkle_root
      };
      data = formData;
    }
    verificationResultsNode.verificationGraphData.push({
      hash: revisionItemHash,
      previous_verification_hash: revision.previous_verification_hash,
      timestamp: revision.local_timestamp,
      isValidationSucessful: result[0],
      revisionType: revision.revision_type,
      verificationGraphData: [],
      linkVerificationGraphData: linkedVerificationGraphData,
      info: data
    });
    if (result[1].length > 0) {
      logs.push(...result[1]);
    }
    if (!result[0]) {
      isSuccess = false;
    }
  }
  if (!isSuccess) {
    return Err(logs);
  }
  return Ok(verificationResults);
}
async function verifyRevision(aquaTree, revisionPar, verificationHash, fileObjects, isScalar, identCharacter = "", credentials) {
  let logs = [];
  let doVerifyMerkleProof = false;
  let isSuccess = true;
  let isScalarSuccess = true;
  let verifyWitnessMerkleProof = false;
  let revision = reorderRevisionsProperties(revisionPar);
  if (revision.revision_type === "witness" && revision.witness_merkle_proof.length > 1) {
    verifyWitnessMerkleProof = true;
  }
  if (isScalar && !verifyWitnessMerkleProof) {
    let revData = JSON.stringify(revision);
    const actualVH = "0x" + getHashSum(revData);
    isScalarSuccess = actualVH === verificationHash;
    if (!isScalarSuccess) {
      logs.push({
        logType: "debug_data" /* DEBUGDATA */,
        log: `calculated  hash ${actualVH} expected hash ${verificationHash} `,
        ident: `${identCharacter}	`
      });
      logs.push({
        logType: "debug_data" /* DEBUGDATA */,
        log: ` expected hash ${verificationHash} `,
        ident: `${identCharacter}	`
      });
      logs.push({
        logType: "error" /* ERROR */,
        log: `Scalar revision verification failed`,
        ident: `${identCharacter}	`
      });
    } else {
    }
  } else {
    if (doVerifyMerkleProof) {
      logs.push({
        logType: "info" /* INFO */,
        log: "Verifying revision merkle tree .",
        ident: `${identCharacter}	`
      });
      let [ok, result] = verifyRevisionMerkleTreeStructure(
        revision,
        verificationHash
      );
      if (!ok) {
        return [ok, result];
      }
    }
  }
  let linkIdentChar = `${identCharacter}	`;
  let logsResult = [];
  switch (revision.revision_type) {
    case "form":
      let res = verifyFormRevision(revision, revision.leaves, `${identCharacter}		`);
      isSuccess = res.isOk;
      logs.push(...res.logs);
      logs.push({
        log: `Verified form fields verifying json file`,
        logType: "info" /* INFO */,
        ident: `${identCharacter}	`
      });
      let fileContent1;
      if (!!revision.content) {
        fileContent1 = Buffer.from(revision.content, "utf8");
      } else {
        let fileName = aquaTree.file_index[verificationHash];
        let fileObjectItem = getFileNameCheckingPaths(fileObjects, fileName);
        if (fileObjectItem == void 0) {
          logs.push({
            // log: `file not found in file objects (form) fileObjectItem ${fileObjectItem} verificationHash ${verificationHash} fileObjects ${JSON.stringify(fileObjects, null, 4)}`,
            log: `file not found in file objects (form).`,
            logType: "error" /* ERROR */,
            ident: `${identCharacter}	`
          });
          return [false, logs];
        }
        if (fileObjectItem.fileContent instanceof Uint8Array) {
          fileContent1 = Buffer.from(fileObjectItem.fileContent);
        } else {
          if (typeof fileObjectItem.fileContent === "string") {
            fileContent1 = Buffer.from(fileObjectItem.fileContent);
          } else {
            fileContent1 = Buffer.from(
              JSON.stringify(fileObjectItem.fileContent)
            );
          }
        }
      }
      const fileHash1 = getHashSum(fileContent1);
      isSuccess = fileHash1 === revision.file_hash;
      if (!isSuccess) {
        logs.push({
          log: `File hash verification failed for form revision`,
          logType: "error" /* ERROR */,
          ident: `${identCharacter}	`
        });
      }
      break;
    case "file":
      let fileContent;
      if (!!revision.content) {
        fileContent = Buffer.from(revision.content, "utf8");
      } else {
        let fileName = aquaTree.file_index[verificationHash];
        let fileObjectItem = getFileNameCheckingPaths(fileObjects, fileName);
        if (fileObjectItem == void 0) {
          logs.push({
            log: `file not found in file objects`,
            logType: "error" /* ERROR */,
            ident: `${identCharacter}	`
          });
          return [false, logs];
        }
        if (fileObjectItem.fileContent instanceof Uint8Array) {
          fileContent = Buffer.from(fileObjectItem.fileContent);
        } else {
          if (typeof fileObjectItem.fileContent === "string") {
            fileContent = Buffer.from(fileObjectItem.fileContent);
          } else {
            fileContent = Buffer.from(
              JSON.stringify(fileObjectItem.fileContent)
            );
          }
        }
      }
      const fileHash = getHashSum(fileContent);
      isSuccess = fileHash === revision.file_hash;
      if (!isSuccess) {
        logs.push({
          log: `File hash verification failed for form revision`,
          logType: "error" /* ERROR */,
          ident: `${identCharacter}	`
        });
      }
      break;
    case "signature":
      ;
      [isSuccess, logsResult] = await verifySignature(
        revision,
        revision.previous_verification_hash,
        `${identCharacter}	`
      );
      break;
    case "witness":
      let hash_ = revision.previous_verification_hash;
      if (revision.previous_verification_hash !== revision.witness_merkle_root) {
        hash_ = revision.witness_merkle_root;
      }
      let [isSuccessResult, logsResultData] = await verifyWitness(
        revision,
        hash_,
        doVerifyMerkleProof,
        `${identCharacter}	`,
        credentials
      );
      logsResult = logsResultData;
      isSuccess = isSuccessResult;
      break;
    case "link":
      let linkOk = true;
      for (const [_idx, vh] of revision.link_verification_hashes.entries()) {
        const fileUriFromAquaTree = aquaTree.file_index[vh];
        let fileObj = void 0;
        let aquaFileUri = "";
        let fileUri = "";
        if (fileUriFromAquaTree) {
          fileUri = fileUriFromAquaTree;
          if (fileUriFromAquaTree.includes("/")) {
            fileUri = fileUriFromAquaTree.split("/").pop();
          }
          aquaFileUri = `${fileUri}.aqua.json`;
          fileObj = getFileNameCheckingPaths(fileObjects, aquaFileUri);
        }
        if (fileObj == void 0) {
          let throwError = true;
          for (let fileObjectItem of structuredClone(fileObjects)) {
            if (fileObjectItem.fileName.endsWith(".aqua.json")) {
              let aquaTree2 = fileObjectItem.fileContent;
              let revisionHashes = Object.keys(aquaTree2.revisions);
              if (revisionHashes.includes(vh)) {
                let genesisHash = getGenesisHash(aquaTree2);
                let fileName = aquaTree2.file_index[genesisHash];
                let msg = `revisionHashes ${revisionHashes.join(",")}  hash vh ${vh} genesisHash ${genesisHash} -- fileName ${fileName}, fileObjects ${JSON.stringify(fileObjects.map((e) => e.fileName), null, 4)}`;
                console.log("Msg: ", msg);
                if (fileName == void 0) {
                  break;
                }
                let fileUriObj = getFileNameCheckingPaths(structuredClone(fileObjects), fileName);
                if (fileUriObj == void 0) {
                  break;
                }
                let fileUri2 = fileUriObj.fileName;
                const aquaFileUri2 = `${fileUri2}.aqua.json`;
                logs.push({
                  log: `Deep Linking Verifying linked File ${aquaFileUri2}.`,
                  logType: "info" /* INFO */,
                  ident: `${identCharacter}	`
                });
                try {
                  let fileObj2 = getFileNameCheckingPaths(fileObjects, aquaFileUri2);
                  if (fileObj2 == void 0 || fileObj2 === null) {
                    logs.push({
                      log: `Aqua tree ${aquaFileUri2}  not found`,
                      logType: "error" /* ERROR */,
                      ident: `${identCharacter}	`
                    });
                    break;
                  }
                  const linkAquaTree = fileObj2.fileContent;
                  const _linkAquaTreeReordered = OrderRevisionInAquaTree(linkAquaTree);
                  let linkVerificationResult = await verifyAquaTreeUtil(
                    _linkAquaTreeReordered,
                    fileObjects,
                    `${linkIdentChar}	`,
                    credentials
                  );
                  if (isErr(linkVerificationResult)) {
                    linkOk = false;
                    logs.push(...linkVerificationResult.data);
                    logs.push({
                      log: `verification of ${fileUri2}.aqua.json failed `,
                      logType: "error" /* ERROR */,
                      ident: linkIdentChar
                      //`${identCharacter}\t`
                    });
                  } else {
                    logs.push(...linkVerificationResult.data.logData);
                    logs.push({
                      log: `successfully verified ${fileUri2}.aqua.json `,
                      logType: "success" /* SUCCESS */,
                      ident: linkIdentChar
                      //`${identCharacter}\t`
                    });
                  }
                } catch (error) {
                  linkOk = false;
                  logs.push({
                    log: `Error verifying linked file ${aquaFileUri2}: ${error}`,
                    logType: "error" /* ERROR */,
                    ident: `${identCharacter}	`
                  });
                }
                throwError = false;
                break;
              }
            }
          }
          if (throwError) {
            linkOk = false;
            logs.push({
              log: `File ${fileUri} not found in file objects`,
              logType: "error" /* ERROR */,
              ident: `${identCharacter}	`
            });
          }
        } else {
          logs.push({
            log: `Verifying linked File ${aquaFileUri}.`,
            logType: "info" /* INFO */,
            ident: `${identCharacter}	`
          });
          try {
            const linkAquaTree = fileObj.fileContent;
            let linkVerificationResult = await verifyAquaTreeUtil(
              linkAquaTree,
              fileObjects,
              `${linkIdentChar}	`,
              credentials
            );
            if (isErr(linkVerificationResult)) {
              linkOk = false;
              logs.push(...linkVerificationResult.data);
              logs.push({
                log: `verification of ${fileUri}.aqua.json failed `,
                logType: "error" /* ERROR */,
                ident: linkIdentChar
                //`${identCharacter}\t`
              });
            } else {
              logs.push(...linkVerificationResult.data.logData);
              logs.push({
                log: `successfully verified ${fileUri}.aqua.json `,
                logType: "success" /* SUCCESS */,
                ident: linkIdentChar
                //`${identCharacter}\t`
              });
            }
          } catch (error) {
            linkOk = false;
            logs.push({
              log: `Error verifying linked file ${aquaFileUri}: ${error}`,
              logType: "error" /* ERROR */,
              ident: `${identCharacter}	`
            });
          }
        }
      }
      isSuccess = linkOk;
      break;
  }
  logs.push(...logsResult);
  if (isSuccess && isScalarSuccess) {
    if (isScalar) {
      logs.push({
        log: `\u23FA\uFE0F  Scalar revision verified`,
        logType: "success" /* SUCCESS */,
        ident: identCharacter.length == 0 ? "	" : `${linkIdentChar}`
      });
    } else {
      logs.push({
        log: `\u{1F33F} Tree  revision verified`,
        logType: "success" /* SUCCESS */,
        ident: identCharacter.length == 0 ? "	" : `${linkIdentChar}`
      });
    }
    logs.push({
      log: `
`,
      logType: "empty" /* EMPTY */
    });
    return [true, logs];
  } else {
    logs.push({
      log: `Error verifying revision type:${revision.revision_type} with hash ${verificationHash}. `,
      logType: "error" /* ERROR */,
      ident: `${identCharacter}	`
    });
    logs.push({
      log: `
`,
      logType: "empty" /* EMPTY */
    });
    return [false, logs];
  }
}
function verifyFormRevision(input, leaves, identCharacter = "") {
  let logs = [];
  let contains_deleted_fields = false;
  let fieldsWithVerification = [];
  let fieldsWithPartialVerification = [];
  let ok = true;
  let formKeysGraphData = [];
  Object.keys(input).sort().forEach((field, i2) => {
    let hashString = `${field}:${input[field]}`;
    let new_hash = getHashSum(hashString);
    if (!field.endsWith(".deleted")) {
      if (field.startsWith("forms_")) {
        if (new_hash !== leaves[i2]) {
          ok = false;
          fieldsWithVerification.push(`\u{1F6AB} ${field}: ${input[field]} -- hashString ${hashString} -- new hash ${new_hash} -- index ${i2} -- leaves at ${leaves[i2]}`);
          formKeysGraphData.push({
            formKey: field,
            content: input[field],
            isValidationSucessful: false
          });
        } else {
          fieldsWithVerification.push(`\u2705 ${field}: ${input[field]}`);
          formKeysGraphData.push({
            formKey: field,
            content: input[field],
            isValidationSucessful: true
          });
        }
      }
    } else {
      contains_deleted_fields = true;
      fieldsWithPartialVerification.push(field);
    }
  });
  if (contains_deleted_fields) {
    logs.push({
      log: `Warning: The following fields cannot be verified:`,
      logType: "warning" /* WARNING */,
      ident: identCharacter
    });
    fieldsWithPartialVerification.forEach((field, i2) => {
      logs.push({
        log: `${i2 + 1}. ${field.replace(".deleted", "")}
`,
        logType: "warning" /* WARNING */
      });
    });
  }
  logs.push({
    log: `The following fields were verified:`,
    logType: "success" /* SUCCESS */,
    ident: identCharacter
  });
  fieldsWithVerification.forEach((field) => {
    logs.push({
      log: `${field}
`,
      logType: "success" /* SUCCESS */,
      ident: identCharacter
    });
  });
  return {
    isOk: ok,
    logs,
    formKeysGraphData
  };
}
function verifyRevisionMerkleTreeStructure(input, verificationHash) {
  let logs = [];
  let ok = true;
  let vhOk = true;
  const mandatory = {
    file: ["file_hash", "file_nonce"],
    link: ["link_verification_hashes"],
    signature: ["signature"],
    witness: ["witness_merkle_root"],
    form: []
  }[input.revision_type];
  const mandatoryClaims = [
    "previous_verification_hash",
    "local_timestamp",
    ...mandatory
  ];
  for (const claim of mandatoryClaims) {
    if (!(claim in input)) {
      logs.push({
        log: `mandatory field ${claim} is not present`,
        logType: "error" /* ERROR */
      });
      return [false, logs];
    }
  }
  const leaves = input.leaves;
  delete input.leaves;
  if (input.revision_type === "form") {
    let formVerificationResult = verifyFormRevision(input, leaves);
    logs.push(...formVerificationResult.logs);
    vhOk = formVerificationResult.isOk;
  } else if (input.revision_type === "witness" && input.witness_merkle_proof && input.witness_merkle_proof.length > 1) {
    let witnessMerkleProofLeaves = input.witness_merkle_proof;
    const hexRoot = getMerkleRoot(witnessMerkleProofLeaves);
    vhOk = hexRoot === input.witness_merkle_root;
  } else {
    for (const [i2, claim] of Object.keys(input).sort().entries()) {
      const actual = getHashSum(`${claim}:${input[claim]}`);
      const claimOk = leaves[i2] === actual;
      ok = ok && claimOk;
    }
    const leaves2 = dict2Leaves(input);
    const hexRoot = getMerkleRoot(leaves2);
    vhOk = hexRoot === verificationHash;
  }
  ok = ok && vhOk;
  return [ok, logs];
}

// package.json
var package_default = {
  name: "aqua-js-sdk",
  version: "3.2.1-47",
  description: "A TypeScript SDK Library for Aqua Protocol for data accounting",
  type: "module",
  repository: {
    type: "git",
    url: "https://github.com/inblockio/aqua-verifier-js-lib.git"
  },
  main: "dist/index.js",
  types: "dist/index.d.ts",
  scripts: {
    build: "tsup src/index.ts src/react-native.ts src/web.ts --dts --format esm,cjs --out-dir dist --tsconfig tsconfig.json",
    "build:browser": "webpack --mode production",
    "build:react-native": "webpack --config webpack.react-native.config.js --mode production",
    "build:all": "npm run build && npm run build:browser && npm run build:react-native",
    prepare: "npm run build:all",
    dev: "tsc",
    test: "NODE_OPTIONS='--experimental-vm-modules --no-warnings' npx jest --verbose",
    lint: "eslint src --ext .ts",
    format: "prettier --write src/**/*.ts",
    docs: "typedoc --out docs src"
  },
  exports: {
    ".": {
      types: {
        require: "./dist/index.d.cts",
        default: "./dist/index.d.ts"
      },
      browser: "./dist/aqua-js-sdk.min.js",
      web: {
        require: "./dist/web.cjs",
        default: "./dist/web.js"
      },
      "react-native": {
        require: "./dist/aqua-js-sdk-react-native.min.js",
        default: "./dist/aqua-js-sdk-react-native.min.js"
      },
      default: {
        require: "./dist/index.cjs",
        default: "./dist/index.js"
      }
    },
    "./web": {
      types: {
        require: "./dist/web.d.cts",
        default: "./dist/web.d.ts"
      },
      require: "./dist/web.cjs",
      default: "./dist/web.js"
    },
    "./react-native": {
      types: {
        require: "./dist/react-native.d.cts",
        default: "./dist/react-native.d.ts"
      },
      require: "./dist/aqua-js-sdk-react-native.min.js",
      default: "./dist/aqua-js-sdk-react-native.min.js"
    }
  },
  "react-native": "./dist/aqua-js-sdk-react-native.min.js",
  peerDependencies: {
    ethers: "^6.7.1"
  },
  peerDependenciesMeta: {
    "react-native-fs": {
      optional: true
    },
    "@react-native-async-storage/async-storage": {
      optional: true
    },
    "expo-crypto": {
      optional: true
    },
    "react-native-get-random-values": {
      optional: true
    },
    "react-native-url-polyfill": {
      optional: true
    }
  },
  optionalDependencies: {
    "did-resolver": "^4.1.0",
    dids: "^5.0.3",
    "key-did-provider-ed25519": "^4.0.2",
    "key-did-resolver": "^4.0.0",
    "node-forge": "^1.3.1",
    "nostr-tools": "^2.10.4",
    "openid-client": "^5.7.0",
    pkijs: "^3.2.4",
    ws: "^8.18.3"
  },
  dependencies: {
    "aqua-js-sdk": "file:aqua-js-sdk-3.2.1-47.tgz",
    asn1js: "^3.0.5",
    buffer: "^6.0.3",
    "crypto-browserify": "^3.12.1",
    ethers: "^6.7.1",
    "js-sha3": "^0.9.3",
    merkletreejs: "^0.5.0"
  },
  devDependencies: {
    "@types/asn1js": "^3.0.11",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.0.0",
    "@types/pkijs": "^3.0.1",
    "@types/sha.js": "^2.4.4",
    "@types/ws": "^8.5.14",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    eslint: "^8.57.0",
    "https-browserify": "^1.0.0",
    jest: "^29.7.0",
    "jsdoc-to-markdown": "^9.1.1",
    "null-loader": "^4.0.1",
    "path-browserify": "^1.0.1",
    prettier: "^3.2.5",
    process: "^0.11.10",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.4",
    tsup: "^8.3.6",
    typedoc: "^0.28.5",
    "typedoc-plugin-markdown": "^4.6.4",
    typescript: "^5.3.3",
    url: "^0.11.4",
    util: "^0.12.5",
    vitest: "^3.0.0",
    "vm-browserify": "^1.1.2",
    webpack: "^5.101.3",
    "webpack-cli": "^5.1.4"
  }
};

// src/aqua-v2.ts
var fs2 = __toESM(require("fs"), 1);
var path2 = __toESM(require("path"), 1);
var Aqua = class _Aqua {
  /**
   * Create a new Aqua instance with configuration
   * 
   * @param config - Configuration for operations
   */
  constructor(config) {
    this.tree = null;
    this.logs = [];
    this.config = {
      enableScalar: true,
      ...config
    };
  }
  /**
   * Update configuration
   * 
   * @param updates - Partial configuration updates
   */
  configure(updates) {
    this.config = { ...this.config, ...updates };
  }
  /**
   * Check if running in Node.js environment
   * 
   * @returns LogData array with error if in browser, empty array if Node.js
   */
  requiresNode() {
    if (typeof window !== "undefined") {
      const error = {
        logType: "error" /* ERROR */,
        log: "This operation requires Node.js environment"
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    return { isOk: () => true, isErr: () => false, data: void 0 };
  }
  /**
   * Static version of Node.js environment check
   * 
   * @returns Result with error if in browser, success if Node.js
   */
  static requiresNode() {
    if (typeof window !== "undefined") {
      const error = {
        logType: "error" /* ERROR */,
        log: "This operation requires Node.js environment"
      };
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    return { isOk: () => true, isErr: () => false, data: void 0 };
  }
  /**
   * Create genesis revision for file notarization
   * 
   * @param fileObject - File to notarize
   * @param options - Optional parameters
   */
  async createFromFileObject(fileObject, options = {}) {
    const { isForm = false, enableContent = false, enableScalar = this.config.enableScalar } = options;
    const result = await createGenesisRevision(fileObject, isForm, enableContent, enableScalar);
    if (result.isOk()) {
      this.tree = result.data.aquaTree;
      this.logs.push(...result.data.logData);
    } else {
      this.logs.push(...result.data);
    }
    return result;
  }
  /**
   * Sign the current tree
   * 
   * @param signConfig - Optional signing configuration override
   */
  async sign(signConfig) {
    if (!this.tree) {
      const error = {
        logType: "error" /* ERROR */,
        log: "No tree to sign. Call notarize() first.",
        ident: ""
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    const config = signConfig || this.config.signing;
    if (!config) {
      const error = {
        logType: "error" /* ERROR */,
        log: "No signing configuration provided"
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    const view = {
      aquaTree: this.tree,
      fileObject: {
        fileName: "placeholder",
        fileContent: "",
        path: "/placeholder"
      },
      revision: ""
    };
    const result = await signAquaTreeUtil(
      view,
      config.type,
      this.config.credentials,
      this.config.enableScalar,
      "",
      config.reactNativeOptions
    );
    if (result.isOk()) {
      this.tree = result.data.aquaTree;
      this.logs.push(...result.data.logData);
    } else {
      this.logs.push(...result.data);
    }
    return result;
  }
  /**
   * Witness the current tree
   * 
   * @param witnessConfig - Optional witness configuration override
   */
  async witness(witnessConfig) {
    if (!this.tree) {
      const error = {
        logType: "error" /* ERROR */,
        log: "No tree to witness. Call notarize() first."
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    const config = witnessConfig || this.config.witness;
    if (!config) {
      const error = {
        logType: "error" /* ERROR */,
        log: "No witness configuration provided"
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    const view = {
      aquaTree: this.tree,
      fileObject: void 0,
      revision: ""
    };
    const result = await witnessAquaTreeUtil(
      view,
      config.type,
      config.network,
      config.platform,
      this.config.credentials,
      this.config.enableScalar
    );
    if (result.isOk()) {
      this.tree = result.data.aquaTree;
      this.logs.push(...result.data.logData);
    } else {
      this.logs.push(...result.data);
    }
    return result;
  }
  /**
   * Verify the current tree
   * 
   * @param linkedFiles - Files needed for verification
   */
  async verify(linkedFiles = []) {
    if (!this.tree) {
      const error = {
        logType: "error" /* ERROR */,
        log: "No tree to verify. Call notarize() first."
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    const result = await verifyAquaTreeUtil(this.tree, linkedFiles, "", this.config.credentials);
    if (result.isOk()) {
      this.logs.push(...result.data.logData);
    } else {
      this.logs.push(...result.data);
    }
    return result;
  }
  /**
   * Get the current tree
   */
  getTree() {
    return this.tree;
  }
  /**
   * Get all operation logs
   */
  getLogs() {
    return [...this.logs];
  }
  /**
   * Clear logs
   */
  clearLogs() {
    this.logs = [];
  }
  /**
   * Reset the instance (clear tree and logs)
   */
  reset() {
    this.tree = null;
    this.logs = [];
  }
  /**
   * Load an existing aqua file from disk
   * 
   * @param aquaFilePath - Path to the .aqua.json file
   */
  loadAquaFile(aquaFilePath) {
    const nodeCheck = this.requiresNode();
    if (nodeCheck.isErr()) {
      return nodeCheck;
    }
    try {
      const fileContent = fs2.readFileSync(aquaFilePath, { encoding: "utf-8" });
      const aquaTree = JSON.parse(fileContent);
      this.tree = aquaTree;
      const log = {
        logType: "info" /* INFO */,
        log: `Loaded aqua file from ${aquaFilePath}`
      };
      this.logs.push(log);
      return { isOk: () => true, isErr: () => false, data: aquaTree };
    } catch (error) {
      const errorLog = {
        logType: "error" /* ERROR */,
        log: `Failed to load aqua file: ${error}`
      };
      this.logs.push(errorLog);
      return { isOk: () => false, isErr: () => true, data: [errorLog] };
    }
  }
  /**
  * Load an existing AquaTree object directly
  * 
  * @param aquaTree - The AquaTree object to load
  */
  loadAquaTree(aquaTree) {
    try {
      this.tree = aquaTree;
      const log = {
        logType: "info" /* INFO */,
        log: `Loaded AquaTree object with ${Object.keys(aquaTree.revisions).length} revisions`
      };
      this.logs.push(log);
      return { isOk: () => true, isErr: () => false, data: aquaTree };
    } catch (error) {
      const errorLog = {
        logType: "error" /* ERROR */,
        log: `Failed to load AquaTree: ${error}`
      };
      this.logs.push(errorLog);
      return { isOk: () => false, isErr: () => true, data: [errorLog] };
    }
  }
  /**
   * Save the current tree to an aqua file
   * 
   * @param aquaFilePath - Path where to save the .aqua.json file
   */
  save(aquaFilePath) {
    const nodeCheck = this.requiresNode();
    if (nodeCheck.isErr()) {
      return nodeCheck;
    }
    if (!this.tree) {
      const error = {
        logType: "error" /* ERROR */,
        log: "No tree to save. Call notarize() first."
      };
      this.logs.push(error);
      return { isOk: () => false, isErr: () => true, data: [error] };
    }
    try {
      const fileContent = JSON.stringify(this.tree, null, 4);
      fs2.writeFileSync(aquaFilePath, fileContent, { encoding: "utf-8" });
      const log = {
        logType: "info" /* INFO */,
        log: `Saved aqua file to ${aquaFilePath}`
      };
      this.logs.push(log);
      return { isOk: () => true, isErr: () => false, data: aquaFilePath };
    } catch (error) {
      const errorLog = {
        logType: "error" /* ERROR */,
        log: `Failed to save aqua file: ${error}`
      };
      this.logs.push(errorLog);
      return { isOk: () => false, isErr: () => true, data: [errorLog] };
    }
  }
  /**
   * Load a regular file and create FileObject
   * 
   * @param filePath - Path to the file
   * @returns FileObject for use with operations
   */
  static loadFile(filePath) {
    const nodeCheck = this.requiresNode();
    if (nodeCheck.isErr()) {
      return nodeCheck;
    }
    try {
      const fileContent = fs2.readFileSync(filePath, { encoding: "utf-8" });
      const fileName = path2.basename(filePath);
      const fileObject = {
        fileName,
        fileContent,
        path: filePath
      };
      return { isOk: () => true, isErr: () => false, data: fileObject };
    } catch (error) {
      const errorLog = {
        logType: "error" /* ERROR */,
        log: `Failed to load file: ${error}`
      };
      return { isOk: () => false, isErr: () => true, data: [errorLog] };
    }
  }
  /**
   * Implementation of createFile with method overloading
   */
  async create(fileOrPath, options = {}) {
    if (typeof fileOrPath === "string") {
      const nodeCheck = this.requiresNode();
      if (nodeCheck.isErr()) return nodeCheck;
      const fileResult = _Aqua.loadFile(fileOrPath);
      if (fileResult.isErr()) {
        this.logs.push(...fileResult.data);
        return fileResult;
      }
      return this.createFromFileObject(fileResult.data, options);
    } else {
      return this.createFromFileObject(fileOrPath, options);
    }
  }
  /**
   * Complete workflow: Load file, create, sign, witness
   * 
   * @param filePath - Path to file
   * @param operations - Which operations to perform
   */
  async processFile(filePath, operations = {}) {
    const createResult = await this.create(filePath);
    if (createResult.isErr()) {
      return createResult;
    }
    if (operations.sign) {
      const signConfig = typeof operations.sign === "boolean" ? void 0 : operations.sign;
      const signResult = await this.sign(signConfig);
      if (signResult.isErr()) {
        return signResult;
      }
    }
    if (operations.witness) {
      const witnessConfig = typeof operations.witness === "boolean" ? void 0 : operations.witness;
      const witnessResult = await this.witness(witnessConfig);
      if (witnessResult.isErr()) {
        return witnessResult;
      }
    }
    if (operations.verify) {
      const fileResult = _Aqua.loadFile(filePath);
      const files = fileResult.isOk() ? [fileResult.data] : [];
      const verifyResult = await this.verify(files);
      if (verifyResult.isErr()) {
        return verifyResult;
      }
    }
    if (operations.save) {
      const saveResult = this.save(operations.save);
      if (saveResult.isErr()) {
        return saveResult;
      }
    }
    return { isOk: () => true, isErr: () => false, data: this.tree };
  }
};
function createAqua(credentials, witness, signing, enableScalar = true) {
  return new Aqua({
    credentials,
    witness,
    signing,
    enableScalar
  });
}
var WitnessConfigs = {
  ethereumSepolia: { type: "eth", network: "sepolia", platform: "metamask" },
  ethereumMainnet: { type: "eth", network: "mainnet", platform: "metamask" },
  tsa: { type: "tsa", network: "sepolia", platform: "cli" },
  nostr: { type: "nostr", network: "sepolia", platform: "cli" }
};
var SignConfigs = {
  metamask: { type: "metamask" },
  cli: { type: "cli" },
  did: { type: "did" },
  p12: { type: "p12" }
};

// src/core/formatter.ts
var Reset = "\x1B[0m";
var Dim = "\x1B[2m";
var FgRed = "\x1B[31m";
var FgYellow = "\x1B[33m";
var FgGreen = "\x1B[32m";
function cliRedify(content) {
  return FgRed + content + Reset;
}
function cliYellowfy(content) {
  return FgYellow + content + Reset;
}
function cliGreenify(content) {
  return FgGreen + content + Reset;
}
function log_red(content) {
  console.log(cliRedify(content));
}
function log_yellow(content) {
  console.log(cliYellowfy(content));
}
function log_dim(content) {
  console.log(Dim + content + Reset);
}
function log_success(content) {
  console.log(cliGreenify(content));
}

// src/index.ts
var Aquafier = class {
  constructor() {
    // Revision
    /**
     * @method removeLastRevision
     * @description This method removes the last revision from the aqua tree
     * @param aquaTree - The aqua tree to remove the last revision from
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.at = (aquaTree, index) => {
      const hashes3 = Object.keys(aquaTree.revisions);
      let hashAtIndex = hashes3[index];
      if (hashAtIndex == void 0) {
        return null;
      }
      let revision = aquaTree.revisions[hashAtIndex];
      if (revision == void 0) {
        return null;
      }
      return revision;
    };
    this.removeLastRevision = (aquaTree) => {
      return removeLastRevisionUtil(aquaTree);
    };
    /**
     * @method createContentRevision
     * @description This method creates a content revision for the aqua tree
     * @param aquaTree - The aqua tree to create the content revision for
     * @param fileObject - The file object to create the content revision for
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.createContentRevision = async (aquaTree, fileObject, enableScalar = true) => {
      return createContentRevisionUtil(aquaTree, fileObject, enableScalar);
    };
    /**
     * @method createGenesisRevision
     * @description This method creates a genesis revision for the aqua tree
     * @param fileObject - The file object to create the genesis revision for
     * @param isForm - A boolean value to check if the file object is a form
     * @param enableContent - A boolean value to enable content
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.createGenesisRevision = async (fileObject, isForm = false, enableContent = false, enableScalar = true) => {
      return createGenesisRevision(fileObject, isForm, enableContent, enableScalar);
    };
    /**
     * @method verifyAquaTree
     * @description This method verifies the aqua tree
     * @param aquaTree - The aqua tree to verify
     * @param fileObject[] - The file objects of the aqua tree that will be useful for verification
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.verifyAquaTree = async (aquaTree, fileObject, credentials) => {
      return verifyAquaTreeUtil(aquaTree, fileObject, "", credentials);
    };
    /**
     * @method verifyAquaTreeRevision
     * @description This method verifies the aqua tree revision
     * @param aquaTree - The aqua tree to verify
     * @param revision - The revision to verify
     * @param revisionItemHash - The revision item hash to verify
     * @param fileObject[] - The file objects of the aqua tree that will be useful for verification
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.verifyAquaTreeRevision = async (aquaTree, revision, revisionItemHash, fileObject, credentials) => {
      return verifyAquaTreeRevisionUtil(aquaTree, revision, revisionItemHash, fileObject, credentials);
    };
    this.verifyAndGetGraphData = async (aquaTree, fileObject, credentials) => {
      return verifyAndGetGraphDataUtil(aquaTree, fileObject, "", credentials);
    };
    // we need aqua tree because of the file index and the previous verification hash
    this.verifyAndGetGraphDataRevision = async (aquaTree, revision, revisionItemHash, fileObject, credentials) => {
      return verifyAndGetGraphDataRevisionUtil(aquaTree, revision, revisionItemHash, fileObject, credentials);
    };
    /**
     * @method witnessAquaTree
     * @description This method witnesses the aqua tree
     * @param aquaTree - The aqua tree to witness
     * @param witnessType - The witness type to use
     * @param witnessNetwork - The witness network to use
     * @param witnessPlatform - The witness platform to use
     * @param credentials - The credentials to use
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.witnessAquaTree = async (aquaTree, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar = true) => {
      return witnessAquaTreeUtil(aquaTree, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar);
    };
    /**
     * @method witnessMultipleAquaTrees
     * @description This method witnesses multiple aqua trees
     * @param aquaTrees - The aqua trees to witness
     * @param witnessType - The witness type to use
     * @param witnessNetwork - The witness network to use
     * @param witnessPlatform - The witness platform to use
     * @param credentials - The credentials to use
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.witnessMultipleAquaTrees = async (aquaTrees, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar = true) => {
      return witnessMultipleAquaTreesUtil(aquaTrees, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar);
    };
    /**
     * @method signAquaTree
     * @description This method signs the aqua tree
     * @param aquaTree - The aqua tree to sign
     * @param signType - The sign type to use
     * @param credentials - The credentials to use
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.signAquaTree = async (aquaTree, signType, credentials, enableScalar = true, reactNativeOptions) => {
      return signAquaTreeUtil(aquaTree, signType, credentials, enableScalar, "", reactNativeOptions);
    };
    /**
     * @method signMultipleAquaTrees
     * @description This method signs multiple aqua trees
     * @param aquaTrees - The aqua trees to sign
     * @param signType - The sign type to use
     * @param credentials - The credentials to use
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.signMultipleAquaTrees = async (aquaTrees, signType, credentials) => {
      return signMultipleAquaTreesUtil(aquaTrees, signType, credentials);
    };
    /**
     * @method linkAquaTree
     * @description This method links an aqua tree to another aqua tree
     * @param aquaTreeView - The aqua tree to link
     * @param linkAquaTreeView - The aqua tree to link to
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.linkAquaTree = async (aquaTreeView, linkAquaTreeView, enableScalar = true) => {
      return linkAquaTreeUtil(aquaTreeView, linkAquaTreeView, enableScalar);
    };
    /**
     * @method linkMultipleAquaTrees
     * @description This method links multiple aqua trees to another aqua tree
     * @param aquaTreeViews - The aqua trees to link
     * @param linkAquaTreeView - The aqua tree to link to
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.linkMultipleAquaTrees = async (aquaTreeViews, linkAquaTreeView, enableScalar = true) => {
      return linkMultipleAquaTreesUtil(aquaTreeViews, linkAquaTreeView, enableScalar);
    };
    /**
     * @method linkAquaTreesToMultipleAquaTrees
     * @description This method links multiple aqua trees to multiple aqua trees
     * @param aquaTreeViews - The aqua trees to link
     * @param linkAquaTreeView - The aqua trees to link to
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.linkAquaTreesToMultipleAquaTrees = async (aquaTreeViews, linkAquaTreeView, enableScalar = true) => {
      return linkAquaTreesToMultipleAquaTreesUtil(aquaTreeViews, linkAquaTreeView, enableScalar);
    };
    /**
     * @method createFormRevision
     * @description This method creates a form revision for the aqua tree
     * @param aquaTree - The aqua tree to create the form revision for
     * @param fileObject - The file object to create the form revision for
     * @param enableScalar - A boolean value to enable scalar
     * @returns Result<AquaOperationData, Log[]>
     */
    this.createFormRevision = async (aquaTree, fileObject, enableScalar = true) => {
      return createFormRevisionUtil(aquaTree, fileObject, enableScalar);
    };
    /**
     * @method hideFormElements
     * @description This method hides form elements
     * @param aquaTree - The aqua tree to hide form elements
     * @param keyToHide - The key to hide
     * @returns Result<AquaOperationData, LogData[]>
     */
    this.hideFormElements = async (aquaTree, keyToHide) => {
      return hideFormElementsUtil(aquaTree, keyToHide);
    };
    /**
     * @method unHideFormElements
     * @description This method unhides form elements
     * @param aquaTree - The aqua tree to unhide form elements
     * @param keyToUnHide - The key to unhide
     * @param content - The content to unhide
     * @returns Result<AquaOperationData, Log[]>
     */
    this.unHideFormElements = async (aquaTree, keyToUnHide, content) => {
      return unHideFormElementsUtil(aquaTree, keyToUnHide, content);
    };
    //get files to be read to file objects 
    this.fetchFilesToBeRead = (aquaTree) => {
      return fetchFilesToBeReadUtil(aquaTree);
    };
    this.checkIfFileAlreadyNotarized = (aquaTree, fileObject) => {
      return checkIfFileAlreadyNotarizedUtil(aquaTree, fileObject);
    };
    // Revisions
    this.getRevisionByHash = (aquaTree, hash3) => {
      return getRevisionByHashUtil(aquaTree, hash3);
    };
    // Revisions
    this.getLastRevision = (aquaTree) => {
      return getLastRevisionUtil(aquaTree);
    };
    // get file
    this.getFileByHash = async (aquaTree, hash3) => {
      return getFileByHashUtil(aquaTree, hash3);
    };
    this.getFileHash = (fileContent) => {
      return getHashSum(fileContent);
    };
    this.getVersionFromPackageJson = () => {
      let version3 = "1.3.2.0";
      console.log(package_default.version);
      return package_default.version ? package_default.version : version3;
    };
    this.renderTree = (aquaTree) => {
      if (aquaTree.tree) {
        logAquaTree(aquaTree?.tree);
      }
    };
  }
};
var AquafierChainable = class {
  /**
  * Creates a new chainable Aqua operation sequence
  * 
  * @param initialValue - Optional initial Aqua Tree
  */
  constructor(initialValue) {
    /** Collected operation logs */
    this.logs = [];
    if (initialValue) {
      this.value = initialValue;
    }
  }
  /**
  * Extracts Aqua Tree from operation result
  * 
  * @param result - Result to unwrap
  * @returns Aqua Tree from result
  * @throws If result is Err
  */
  unwrap(result) {
    if (result.isErr()) {
      this.logs.push(...result.data);
      throw Error("an error occured");
    } else {
      this.logs.push(...result.data.logData);
    }
    return result.data.aquaTree;
  }
  /**
  * Creates a genesis revision for file notarization
  * 
  * @param fileObject - File to notarize
  * @param isForm - Whether file is a form
  * @param enableContent - Whether to include content
  * @param enableScalar - Whether to enable scalar values
  * @returns This instance for chaining
  */
  async notarize(fileObject, isForm = false, enableContent = false, enableScalar = true) {
    let data = await createGenesisRevision(fileObject, isForm, enableContent, enableScalar);
    if (data.isOk()) {
      this.value = this.unwrap(data);
      this.logs.push(...data.data.logData);
    } else {
      this.logs.push(...data.data);
    }
    return this;
  }
  /**
  * Signs the current Aqua Tree state
  * 
  * @param signType - Type of signature (cli, metamask, did)
  * @param credentials - Signing credentials
  * @param enableScalar - Whether to enable scalar values
  * @returns This instance for chaining
  */
  async sign(signType = "metamask", credentials = {
    mnemonic: "",
    nostr_sk: "",
    "did_key": "",
    alchemy_key: "",
    witness_eth_network: "",
    witness_method: ""
  }, enableScalar = true) {
    let data = await signAquaTreeUtil({
      aquaTree: this.value,
      fileObject: {
        fileName: "test.txt",
        fileContent: "",
        path: "/fake/path/test.txt"
      },
      revision: ""
    }, signType, credentials, enableScalar);
    if (data.isOk()) {
      this.value = this.unwrap(data);
      this.logs.push(...data.data.logData);
    } else {
      this.logs.push(...data.data);
    }
    return this;
  }
  /**
  * Witnesses the current Aqua Tree state
  * 
  * @param witnessType - Type of witness (eth, tsa, nostr)
  * @param witnessNetwork - Network for witnessing
  * @param witnessPlatform - Platform for witnessing
  * @param credentials - Witness credentials
  * @param enableScalar - Whether to enable scalar values
  * @returns This instance for chaining
  */
  async witness(witnessType = "eth", witnessNetwork = "sepolia", witnessPlatform = "metamask", credentials = {
    mnemonic: "",
    nostr_sk: "",
    "did_key": "",
    alchemy_key: "",
    witness_eth_network: "",
    witness_method: ""
  }, enableScalar = true) {
    let data = await witnessAquaTreeUtil({
      aquaTree: this.value,
      fileObject: void 0,
      revision: ""
    }, witnessType, witnessNetwork, witnessPlatform, credentials, enableScalar);
    if (data.isOk()) {
      this.value = this.unwrap(data);
      this.logs.push(...data.data.logData);
    } else {
      this.logs.push(...data.data);
    }
    return this;
  }
  /**
  * Verifies the current Aqua Tree state
  * 
  * @param linkedFileObject - Linked files for verification
  * @returns This instance for chaining
  */
  async verify(linkedFileObject = []) {
    let data = await verifyAquaTreeUtil(this.value, linkedFileObject);
    if (data.isOk()) {
      this.logs.push(...data.data.logData);
    } else {
      this.logs.push(...data.data);
    }
    this.verificationResult = data;
    return this;
  }
  /**
  * Gets the current Aqua Tree state
  * 
  * @returns Current Aqua Tree
  */
  getValue() {
    return this.value;
  }
  /**
  * Gets the result of last verification
  * 
  * @returns Verification result
  */
  getVerificationValue() {
    return this.verificationResult;
  }
  /**
  * Gets all collected operation logs
  * 
  * @returns Array of log entries
  */
  getLogs() {
    return this.logs;
  }
};

// src/web.ts
registerNodeModuleShims();
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined";
if (!isBrowser2) {
  console.warn(
    'You are importing from "aqua-js-sdk/web" but this does not appear to be a browser environment. This may cause unexpected behavior. Consider importing from "aqua-js-sdk" instead.'
  );
}
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    try {
      const bufferModule = require("buffer");
      window.Buffer = bufferModule.Buffer;
    } catch (e) {
      try {
        const bufferModule = require("buffer/");
        window.Buffer = bufferModule.Buffer;
      } catch (e2) {
        console.warn("Failed to load Buffer polyfill:", e2);
        window.Buffer = class MinimalBuffer {
          static from(data) {
            return data;
          }
          static isBuffer() {
            return false;
          }
        };
      }
    }
  }
}
var web_default = Aquafier;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Aqua,
  Aquafier,
  AquafierChainable,
  Err,
  ErrResult,
  LogType,
  LogTypeEmojis,
  None,
  NoneOption,
  Ok,
  OkResult,
  OrderRevisionInAquaTree,
  SignConfigs,
  Some,
  SomeOption,
  WitnessConfigs,
  checkFileHashAlreadyNotarized,
  checkInternetConnection,
  cliGreenify,
  cliRedify,
  cliYellowfy,
  createAqua,
  createCredentials,
  createNewAquaTree,
  dict2Leaves,
  estimateWitnessGas,
  findFormKey,
  findNextRevisionHashByArrayofRevisions,
  formatMwTimestamp,
  getAquaTreeFileName,
  getAquaTreeFileObject,
  getChainIdFromNetwork,
  getEntropy,
  getFileHashSum,
  getFileNameCheckingPaths,
  getGenesisHash,
  getHashSum,
  getLatestVH,
  getMerkleRoot,
  getPreviousVerificationHash,
  getTimestamp,
  getWallet,
  isAquaTree,
  isErr,
  isNone,
  isOk,
  isSome,
  log_dim,
  log_red,
  log_success,
  log_yellow,
  maybeUpdateFileIndex,
  prepareNonce,
  printGraphData,
  printLogs,
  printlinkedGraphData,
  recoverWalletAddress,
  reorderAquaTreeRevisionsProperties,
  reorderRevisionsProperties,
  verifyMerkleIntegrity
});
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/nist.js:
@noble/curves/esm/p256.js:
@noble/curves/esm/p384.js:
@noble/curves/esm/p521.js:
@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

pvtsutils/build/index.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2024 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

pkijs/build/index.es.js:
  (*!
   * Copyright (c) 2014, GlobalSign
   * Copyright (c) 2015-2019, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the {organization} nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)
*/
